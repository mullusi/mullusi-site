<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>VIRECAI v2.27 â€” Complete Symbolic Reality</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg-primary: #08080c;
      --bg-secondary: #0c0c14;
      --bg-tertiary: #12121e;
      --bg-quaternary: #1a1a2a;
      --border: #1e1e32;
      --border-active: #3a3a5a;
      --text-primary: #e8e8f0;
      --text-secondary: #9898a8;
      --text-tertiary: #606070;
      --text-muted: #404050;
      --accent-blue: #4a90ff;
      --accent-purple: #8855ff;
      --accent-cyan: #22ddee;
      --accent-green: #22cc88;
      --accent-orange: #ff8844;
      --accent-gold: #ffc744;
      --success: #44ddaa;
      --warning: #ffcc44;
      --error: #ff6666;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.4;
    }

    /* Header */
    .header {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 36px;
      padding: 0 12px;
      background: rgba(8,8,12,0.96);
      backdrop-filter: blur(12px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      border-bottom: 1px solid var(--border);
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .logo-icon {
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }
    .logo-text {
      font-weight: 700;
      font-size: 13px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .logo-version { font-size: 9px; color: var(--text-tertiary); }
    .chip {
      padding: 3px 8px;
      border-radius: 8px;
      font-size: 8px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .chip.mode-full { background: #4a40aa; color: #d4ccff; }
    .chip.mode-lite { background: #0a6644; color: #88eebb; }
    .chip.state { display: flex; align-items: center; gap: 4px; }
    .chip.state.idle { background: var(--bg-tertiary); color: var(--text-tertiary); }
    .chip.state.ready { background: #0a4030; color: var(--success); }
    .chip.state.recording { background: #4a1520; color: #ff8899; }
    .state-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: currentColor;
    }
    .chip.state.recording .state-dot { animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 5px var(--accent-cyan); } 50% { box-shadow: 0 0 15px var(--accent-cyan), 0 0 25px var(--accent-blue); } }
    @keyframes slideIn { from { transform: translateY(-10px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes dataFlow { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
    
    /* Score animations */
    .score-animated { transition: color 0.3s ease, transform 0.2s ease; }
    .score-animated.updated { transform: scale(1.1); }
    
    /* Card hover effects */
    .metric-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .theory-card:hover { border-color: var(--accent-purple); }
    
    /* Button feedback */
    .control-btn:active { transform: scale(0.95); }
    .download-btn:active { transform: scale(0.98); }
    
    /* Smooth transitions */
    .panel, .settings-panel, .theory-panel { transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); }
    .panel-backdrop { transition: opacity 0.2s ease; }
    
    /* Recording indicator pulse */
    .recording-active .state-dot { animation: pulse 0.8s infinite; }
    
    /* Data flow indicator */
    .pipeline-stage.active { 
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple), var(--accent-cyan));
      background-size: 200% 100%;
      animation: dataFlow 2s linear infinite;
    }

    /* Pipeline Bar - 7 Stages */
    .pipeline-bar {
      position: fixed;
      top: 36px; left: 0; right: 0;
      height: 26px;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 3px;
      z-index: 99;
      border-bottom: 1px solid var(--border);
    }
    .pipeline-stage {
      flex: 1;
      height: 16px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      border: 1px solid transparent;
      transition: all 0.15s;
    }
    .pipeline-stage:hover { transform: scaleY(1.1); }
    .pipeline-stage.active { border-color: var(--accent-blue); }
    .pipeline-stage-fill {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      width: 0%;
      border-radius: 3px;
      transition: width 0.1s;
    }
    .pipeline-stage.sense .pipeline-stage-fill { background: linear-gradient(90deg, #3366ff, #5588ff); }
    .pipeline-stage.sync .pipeline-stage-fill { background: linear-gradient(90deg, #7744ee, #9966ff); }
    .pipeline-stage.symbol .pipeline-stage-fill { background: linear-gradient(90deg, #cc44aa, #ee66cc); }
    .pipeline-stage.reason .pipeline-stage-fill { background: linear-gradient(90deg, #ff6644, #ff8866); }
    .pipeline-stage.validate .pipeline-stage-fill { background: linear-gradient(90deg, #22aa66, #44cc88); }
    .pipeline-stage.chain .pipeline-stage-fill { background: linear-gradient(90deg, #ddaa22, #ffcc44); }
    .pipeline-stage.store .pipeline-stage-fill { background: linear-gradient(90deg, #22aacc, #44ccee); }
    .pipeline-stage-label {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 7px;
      font-weight: 600;
      color: var(--text-tertiary);
      text-transform: uppercase;
      pointer-events: none;
    }
    .pipeline-stage.active .pipeline-stage-label { color: #fff; }
    .pipeline-connector { width: 8px; color: var(--text-muted); font-size: 7px; text-align: center; }

    /* Video */
    .video-container {
      position: fixed;
      top: 62px; left: 0; right: 0; bottom: 100px;
      background: #000;
    }
    #video { width: 100%; height: 100%; object-fit: cover; }
    #video.mirror { transform: scaleX(-1); }
    canvas.hidden { display: none; }

    /* Sensor Panel */
    .sensor-panel {
      position: fixed;
      top: 68px; left: 5px;
      width: 78px;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .sensor-card {
      background: rgba(8,8,16,0.94);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 5px 6px;
    }
    .sensor-card.healthy { border-color: #1a4030; }
    .sensor-card.degraded { border-color: #4a3515; }
    .sensor-card.stale { border-color: #4a3515; }
    .sensor-card.failed { border-color: #4a1520; }
    .sensor-card.disabled { opacity: 0.4; }
    .sensor-card.clickable { cursor: pointer; }
    .sensor-card.clickable:hover { border-color: var(--accent-blue); }
    .sensor-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
    .sensor-card-name { font-size: 7px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; }
    .sensor-card-health { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); }
    .sensor-card-health.healthy { background: var(--success); }
    .sensor-card-health.degraded { background: var(--warning); }
    .sensor-card-health.stale { background: var(--warning); }
    .sensor-card-health.failed { background: var(--error); }
    .sensor-card-health.init { background: var(--accent-blue); animation: pulse 1s infinite; }
    .sensor-card-value { font-size: 10px; font-family: monospace; color: var(--text-primary); line-height: 1.2; }
    .sensor-card-value.gps-value { font-size: 9px; }
    .sensor-card-meta { display: flex; justify-content: space-between; font-size: 6px; color: var(--text-muted); margin-top: 3px; }
    .sensor-card-conf { height: 2px; background: var(--bg-tertiary); border-radius: 1px; margin-top: 3px; }
    .sensor-card-conf-fill { height: 100%; background: var(--success); transition: width 0.3s; }
    .sensor-card-uncertainty { font-size: 6px; color: var(--text-muted); margin-top: 2px; font-family: monospace; }

    /* Metrics Panel */
    .metrics-panel {
      position: fixed;
      top: 68px; right: 5px;
      width: 82px;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .metric-card {
      background: rgba(8,8,16,0.94);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 7px;
    }
    .metric-card-title { font-size: 6px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 3px; }
    .metric-card-value { font-size: 18px; font-weight: 700; font-family: monospace; line-height: 1; }
    .metric-card-value.high { color: var(--success); }
    .metric-card-value.medium { color: var(--warning); }
    .metric-card-value.low { color: var(--error); }
    .metric-card-breakdown { display: flex; gap: 3px; margin-top: 5px; }
    .metric-card-breakdown-item { flex: 1; text-align: center; padding: 3px 2px; background: var(--bg-tertiary); border-radius: 3px; }
    .metric-card-breakdown-value { font-size: 9px; font-weight: 600; font-family: monospace; }
    .metric-card-breakdown-label { font-size: 5px; color: var(--text-muted); margin-top: 1px; }

    /* VF Card */
    .vf-card {
      background: rgba(8,8,16,0.94);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 5px;
    }
    .vf-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 1px; }
    .vf-cell { aspect-ratio: 1; border-radius: 1px; }
    .vf-stats { display: flex; justify-content: space-between; font-size: 6px; color: var(--text-muted); margin-top: 3px; font-family: monospace; }

    /* Causal Card */
    .causal-card {
      background: rgba(8,8,16,0.94);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 5px;
    }
    .causal-canvas { width: 100%; height: 50px; background: var(--bg-primary); border-radius: 4px; }
    .causal-stats { display: flex; justify-content: space-between; font-size: 6px; color: var(--text-muted); margin-top: 3px; font-family: monospace; }

    /* Theory Card - Mathematical Foundations */
    .theory-card {
      background: rgba(8,8,16,0.94);
      border: 1px solid var(--accent-purple);
      border-radius: 6px;
      padding: 5px;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .theory-card:hover { border-color: var(--accent-cyan); }
    .theory-title { font-size: 6px; color: var(--accent-purple); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
    .theory-stats { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; }
    .theory-stat { text-align: center; }
    .theory-label { display: block; font-size: 8px; color: var(--text-muted); font-family: serif; font-style: italic; }
    .theory-value { display: block; font-size: 8px; font-weight: 600; color: var(--text-primary); font-family: monospace; }
    .theory-value.high { color: var(--success); }
    .theory-value.mid { color: var(--warning); }
    .theory-value.low { color: var(--error); }

    /* WH Overlay */
    .wh-overlay {
      position: fixed;
      bottom: 106px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      background: rgba(8,8,16,0.95);
      border: 1px solid var(--accent-cyan);
      border-radius: 8px;
      padding: 8px 10px;
      z-index: 55;
      font-family: monospace;
      font-size: 8px;
      display: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .wh-overlay.visible { display: block; }
    .wh-title { 
      font-size: 7px; 
      color: var(--accent-cyan); 
      text-transform: uppercase; 
      margin-bottom: 6px; 
      border-bottom: 1px solid var(--border); 
      padding-bottom: 4px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    .wh-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .wh-row:last-child { border-bottom: none; }
    .wh-label { color: var(--accent-cyan); font-weight: 600; min-width: 50px; }
    .wh-value { color: var(--text-primary); max-width: 130px; overflow: hidden; text-overflow: ellipsis; text-align: right; }

    /* Recording Badge */
    .rec-badge {
      position: fixed;
      top: 68px; left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #cc2233, #aa1122);
      padding: 5px 12px;
      border-radius: 14px;
      font-size: 11px;
      font-weight: 700;
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 60;
    }
    .rec-badge.visible { display: flex; }
    .rec-badge-dot { width: 7px; height: 7px; background: #fff; border-radius: 50%; animation: pulse 1s infinite; }

    /* Controls */
    .controls {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 100px;
      background: var(--bg-primary);
      border-top: 1px solid var(--border);
      z-index: 100;
      display: flex;
      flex-direction: column;
      padding: 8px 12px 12px;
    }
    .controls-top { display: flex; justify-content: center; margin-bottom: 8px; }
    .mode-toggle { display: flex; background: var(--bg-tertiary); border-radius: 12px; padding: 3px; }
    .mode-btn {
      padding: 4px 12px;
      border: none;
      border-radius: 10px;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      background: transparent;
      color: var(--text-tertiary);
      transition: all 0.2s;
    }
    .mode-btn:hover { color: var(--text-secondary); }
    .mode-btn.active { background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); color: #fff; }
    .mode-btn.lite.active { background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan)); }
    .controls-main { display: flex; justify-content: center; align-items: center; gap: 12px; margin-bottom: 8px; }
    .btn {
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.94); }
    .btn:disabled { opacity: 0.35; cursor: not-allowed; }
    .btn-small {
      width: 38px;
      height: 38px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 14px;
      border: 1px solid var(--border);
    }
    .btn-small:hover:not(:disabled) { background: var(--bg-quaternary); color: var(--text-primary); }
    .btn-small.active { background: var(--accent-blue); color: #fff; }
    .btn-record {
      width: 52px;
      height: 52px;
      background: linear-gradient(135deg, #ee3344, #cc2233);
      color: #fff;
      font-size: 18px;
    }
    .btn-record.recording { background: var(--bg-tertiary); border: 2px solid var(--error); }
    .btn-record.recording::after { content: ''; width: 14px; height: 14px; background: var(--error); border-radius: 3px; }
    .controls-info { display: flex; justify-content: space-between; font-size: 8px; color: var(--text-tertiary); font-family: monospace; }
    .info-item { display: flex; align-items: center; gap: 4px; }
    .info-dot { width: 5px; height: 5px; border-radius: 50%; }
    .info-dot.green { background: var(--success); }
    .info-dot.yellow { background: var(--warning); }
    .info-dot.red { background: var(--error); }

    /* Start Overlay */
    .start-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 100000; /* Higher than all other elements */
    }
    .start-overlay.hidden { display: none; }
    .start-logo {
      width: 70px;
      height: 70px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      border-radius: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      margin-bottom: 14px;
    }
    .start-title {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
    }
    .start-version { font-size: 11px; color: var(--text-tertiary); margin-bottom: 10px; }
    .start-tagline { font-size: 12px; color: var(--text-secondary); text-align: center; max-width: 280px; line-height: 1.5; margin-bottom: 18px; }
    .start-features { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 18px; width: 100%; max-width: 300px; }
    .start-feature { background: var(--bg-tertiary); padding: 10px 6px; border-radius: 8px; text-align: center; border: 1px solid var(--border); }
    .start-feature-icon { font-size: 16px; margin-bottom: 4px; }
    .start-feature-name { font-size: 7px; color: var(--text-secondary); text-transform: uppercase; }
    .start-btn {
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      color: #fff;
      border: none;
      padding: 12px 28px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }
    .start-btn:hover { transform: scale(1.02); }
    .start-btn:active { transform: scale(0.98); }
    .start-btn:disabled { background: var(--bg-tertiary); color: var(--text-tertiary); }
    .start-log {
      margin-top: 12px;
      background: #000;
      padding: 8px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 8px;
      max-height: 90px;
      overflow-y: auto;
      width: 100%;
      max-width: 300px;
      border: 1px solid var(--border);
    }
    .log-line { display: flex; gap: 6px; margin-bottom: 2px; }
    .log-time { color: var(--text-muted); min-width: 35px; }
    .log-ok { color: var(--success); }
    .log-err { color: var(--error); }
    .log-warn { color: var(--warning); }
    .log-info { color: var(--accent-blue); }

    /* Panel */
    .panel-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.88); z-index: 150; display: none; }
    .panel-backdrop.open { display: block; }
    .panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: var(--bg-secondary);
      border-radius: 12px;
      max-height: 82vh;
      max-width: 96vw;
      width: 380px;
      overflow: hidden;
      transition: transform 0.2s;
      z-index: 200;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }
    .panel.open { transform: translate(-50%, -50%) scale(1); }
    .panel-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; border-bottom: 1px solid var(--border); }
    .panel-title { font-weight: 600; font-size: 12px; }
    .panel-close { background: none; border: none; color: var(--text-tertiary); font-size: 16px; cursor: pointer; padding: 4px 8px; border-radius: 6px; }
    .panel-close:hover { background: var(--bg-tertiary); color: var(--text-primary); }
    .panel-tabs { display: flex; gap: 2px; padding: 8px 10px; background: var(--bg-primary); border-bottom: 1px solid var(--border); overflow-x: auto; }
    .panel-tab {
      flex: 1;
      min-width: 45px;
      padding: 5px 8px;
      border: none;
      border-radius: 6px;
      font-size: 8px;
      font-weight: 600;
      cursor: pointer;
      background: transparent;
      color: var(--text-tertiary);
    }
    .panel-tab:hover { color: var(--text-secondary); }
    .panel-tab.active { background: var(--bg-tertiary); color: var(--text-primary); }
    .panel-content { padding: 10px 12px; overflow-y: auto; flex: 1; }
    .panel-section { margin-bottom: 12px; display: none; }
    .panel-section.active { display: block; }
    .panel-section-title { font-size: 8px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid var(--border); }
    .panel-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 10px; }
    .panel-label { color: var(--text-secondary); }
    .panel-value { color: var(--text-primary); font-family: monospace; }
    .panel-value.good { color: var(--success); }
    .panel-value.warn { color: var(--warning); }
    .panel-value.bad { color: var(--error); }
    .query-wrap { display: flex; gap: 6px; margin-top: 8px; }
    .query-input { flex: 1; background: var(--bg-tertiary); border: 1px solid var(--bg-quaternary); border-radius: 6px; padding: 8px 10px; color: var(--text-primary); font-size: 10px; }
    .query-input:focus { outline: none; border-color: var(--accent-blue); }
    .query-btn { background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border: none; border-radius: 6px; padding: 8px 14px; color: #fff; font-weight: 600; font-size: 9px; cursor: pointer; }
    .query-result { margin-top: 8px; background: var(--bg-primary); padding: 8px; border-radius: 6px; font-size: 8px; font-family: monospace; white-space: pre-wrap; max-height: 140px; overflow-y: auto; border: 1px solid var(--border); color: var(--text-secondary); line-height: 1.5; }
    .download-btn { width: 100%; background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan)); border: none; border-radius: 8px; padding: 10px; color: #fff; font-weight: 600; font-size: 11px; cursor: pointer; margin-top: 10px; }
    .download-btn:hover { filter: brightness(1.1); }
    .download-btn:disabled { background: var(--bg-tertiary); color: var(--text-tertiary); }

    /* Timeline Bar */
    .timeline-bar {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 44px;
      background: rgba(12,12,20,0.95);
      backdrop-filter: blur(12px);
      border-top: 1px solid var(--border);
      padding: 8px 12px;
      display: none;
      flex-direction: column;
      gap: 4px;
      z-index: 90;
    }
    .timeline-bar.visible { display: flex; }
    .timeline-track {
      position: relative;
      height: 14px;
      background: var(--bg-tertiary);
      border-radius: 7px;
      cursor: pointer;
      overflow: hidden;
    }
    .timeline-progress {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
      border-radius: 7px;
      width: 0%;
      transition: width 0.1s linear;
    }
    .timeline-segments {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
    }
    .timeline-segment {
      height: 100%;
      opacity: 0.7;
      border-right: 1px solid var(--bg-primary);
    }
    .timeline-markers {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
    }
    .timeline-marker {
      position: absolute;
      top: 0; bottom: 0;
      width: 2px;
      background: var(--accent-orange);
      opacity: 0.8;
    }
    .timeline-marker.scene { background: var(--accent-purple); }
    .timeline-marker.phase { background: var(--accent-gold); }
    .timeline-info {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      color: var(--text-secondary);
    }

    /* History List */
    .history-item {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .history-item:hover {
      border-color: var(--accent-cyan);
      background: var(--bg-secondary);
    }
    .history-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .history-item-name {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .history-item-date {
      font-size: 8px;
      color: var(--text-muted);
    }
    .history-item-stats {
      display: flex;
      gap: 12px;
      font-size: 9px;
      color: var(--text-secondary);
    }
    .history-item-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }
    .history-item-btn {
      flex: 1;
      padding: 5px 8px;
      border: none;
      border-radius: 4px;
      font-size: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    .history-item-btn.load { background: var(--accent-blue); color: #fff; }
    .history-item-btn.export { background: var(--accent-green); color: #fff; }
    .history-item-btn.delete { background: var(--error); color: #fff; }

    /* Playback Panel */
    .playback-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .playback-backdrop.open { opacity: 1; pointer-events: auto; }
    .playback-panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 320px;
      max-width: 95vw;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s;
    }
    .playback-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .playback-content {
      padding: 12px;
    }
    .playback-canvas-wrap {
      position: relative;
      background: var(--bg-primary);
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    #playback-canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .playback-overlay {
      position: absolute;
      top: 8px; right: 8px;
      background: rgba(0,0,0,0.6);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      color: var(--accent-cyan);
    }
    .playback-controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .playback-btn {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .playback-btn:hover { background: var(--accent-blue); }
    .playback-btn.active { background: var(--accent-green); }
    .playback-speed {
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 10px;
    }
    .playback-timeline {
      margin-bottom: 10px;
    }
    .playback-scrub {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      background: var(--bg-tertiary);
      border-radius: 4px;
      outline: none;
    }
    .playback-scrub::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent-cyan);
      border-radius: 50%;
      cursor: pointer;
    }
    .playback-time-info {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      color: var(--text-secondary);
      margin-top: 4px;
    }
    .playback-info {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      font-size: 8px;
      font-family: monospace;
      max-height: 150px;
      overflow-y: auto;
      white-space: pre-wrap;
      color: var(--text-secondary);
    }

    /* Compare Panel */
    .compare-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .compare-backdrop.open { opacity: 1; pointer-events: auto; }
    .compare-panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 320px;
      max-width: 95vw;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s;
    }
    .compare-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .compare-content {
      padding: 12px;
    }
    .compare-frames {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .compare-frame {
      flex: 1;
      text-align: center;
    }
    .compare-label {
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }
    .compare-frame canvas {
      width: 100%;
      height: auto;
      border-radius: 6px;
      background: var(--bg-primary);
    }
    .compare-input {
      width: 100%;
      padding: 6px;
      margin-top: 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      text-align: center;
    }
    .compare-result {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      font-size: 8px;
      font-family: monospace;
      max-height: 150px;
      overflow-y: auto;
      white-space: pre-wrap;
      color: var(--text-secondary);
      margin-top: 10px;
    }

    /* Analytics Panel */
    .analytics-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .analytics-backdrop.open { opacity: 1; pointer-events: auto; }
    .analytics-panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 380px;
      max-width: 95vw;
      max-height: 90vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s;
      overflow: hidden;
    }
    .analytics-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .analytics-content {
      padding: 12px;
      max-height: calc(90vh - 50px);
      overflow-y: auto;
    }
    .analytics-section {
      margin-bottom: 16px;
    }
    .analytics-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Metrics Graph */
    .metrics-graph-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
    }
    #metrics-canvas {
      width: 100%;
      height: 120px;
      display: block;
      cursor: crosshair;
    }
    .metrics-legend {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .metrics-legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    .metrics-legend-item.active { opacity: 1; }
    .metrics-legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    /* Filmstrip */
    .filmstrip-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      overflow-x: auto;
      white-space: nowrap;
    }
    #filmstrip-container {
      display: flex;
      gap: 4px;
    }
    .filmstrip-thumb {
      flex-shrink: 0;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }
    .filmstrip-thumb:hover {
      border-color: var(--accent-cyan);
      transform: scale(1.05);
    }
    .filmstrip-thumb.selected {
      border-color: var(--accent-blue);
      box-shadow: 0 0 8px rgba(74, 144, 255, 0.4);
    }

    /* Scene Timeline */
    .scene-timeline-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
    }
    #scene-timeline {
      display: flex;
      height: 24px;
      border-radius: 4px;
      overflow: hidden;
    }
    .scene-segment {
      height: 100%;
      position: relative;
      cursor: pointer;
      transition: all 0.15s;
      min-width: 4px;
    }
    .scene-segment:hover {
      filter: brightness(1.2);
      z-index: 1;
    }
    .scene-segment.highlighted {
      box-shadow: inset 0 0 0 2px #fff;
    }
    .scene-tag-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-size: 7px;
      padding: 1px 3px;
      border-radius: 3px;
    }
    .scene-legend {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .scene-legend-item {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 8px;
      color: var(--text-secondary);
    }
    .scene-legend-color {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    /* Annotation Panel */
    .annotation-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
    }
    .annotation-input-row {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    .annotation-frame-input {
      width: 60px;
      padding: 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 10px;
    }
    .annotation-text-input {
      flex: 1;
      padding: 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 10px;
    }
    .annotation-add-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      background: var(--accent-green);
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
    }
    .annotation-list {
      max-height: 120px;
      overflow-y: auto;
    }
    .annotation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px;
      background: var(--bg-secondary);
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 9px;
    }
    .annotation-item-frame {
      font-weight: 600;
      color: var(--accent-cyan);
      margin-right: 8px;
    }
    .annotation-item-text {
      flex: 1;
      color: var(--text-primary);
    }
    .annotation-item-delete {
      color: var(--error);
      cursor: pointer;
      padding: 2px 6px;
    }

    /* Search Results */
    .search-results-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      margin-top: 12px;
    }
    .search-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
      gap: 4px;
    }
    .search-result-thumb {
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }
    .search-result-thumb:hover {
      border-color: var(--accent-cyan);
      transform: scale(1.1);
      z-index: 1;
    }
    .search-more {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      border-radius: 4px;
      padding: 8px;
    }

    /* Quick Tags */
    .quick-tags-wrap {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .quick-tag {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 9px;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
      opacity: 0.6;
    }
    .quick-tag:hover { opacity: 1; }
    .quick-tag.active {
      opacity: 1;
      border-color: currentColor;
    }
    .quick-tag-icon { font-size: 10px; }

    /* Clip Export Panel */
    .clip-panel-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .clip-panel-backdrop.open { opacity: 1; pointer-events: auto; }
    .clip-panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 300px;
      max-width: 95vw;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s;
    }
    .clip-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .clip-panel-content { padding: 12px; }
    .clip-range-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }
    .clip-range-input {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
      text-align: center;
    }
    .clip-preview {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 12px;
      font-size: 10px;
      color: var(--text-secondary);
    }
    .clip-preview-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .clip-export-btns {
      display: flex;
      gap: 8px;
    }
    .clip-export-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
    }
    .clip-export-btn.json { background: var(--accent-blue); color: #fff; }
    .clip-export-btn.image { background: var(--accent-green); color: #fff; }

    /* Heatmap Controls */
    .heatmap-controls {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .heatmap-btn {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 9px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .heatmap-btn:hover { border-color: var(--accent-cyan); }
    .heatmap-btn.active {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }

    /* Report Panel */
    .report-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .report-backdrop.open { opacity: 1; pointer-events: auto; }
    .report-panel {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 340px;
      max-width: 95vw;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s;
    }
    .report-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .report-content { padding: 12px; }
    .report-section-toggle {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
    }
    .report-section-btn {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 9px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .report-section-btn.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: #fff;
    }
    .report-format-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .report-format-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
    }
    .report-format-btn.html { background: #ff6644; color: #fff; }
    .report-format-btn.md { background: #8855ff; color: #fff; }
    .report-format-btn.json { background: #22cc88; color: #fff; }

    /* Command Palette */
    .command-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 299;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
    }
    .command-backdrop.open { opacity: 1; pointer-events: auto; }
    .command-panel {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%) scale(0.95);
      width: 400px;
      max-width: 90vw;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: all 0.15s;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    .command-panel.open {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) scale(1);
    }
    .command-input {
      width: 100%;
      padding: 14px 16px;
      border: none;
      border-bottom: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 14px;
      outline: none;
    }
    .command-input::placeholder { color: var(--text-muted); }
    .command-list {
      max-height: 300px;
      overflow-y: auto;
    }
    .command-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      cursor: pointer;
      transition: background 0.1s;
    }
    .command-item:hover { background: var(--bg-tertiary); }
    .command-item.selected { background: var(--accent-blue)20; }
    .command-label { font-size: 12px; color: var(--text-primary); }
    .command-category { font-size: 10px; color: var(--text-muted); }
    .command-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Bookmarks */
    .bookmarks-wrap {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      margin-top: 12px;
    }
    .bookmark-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .bookmark-item:hover { background: var(--bg-secondary); }
    .bookmark-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .bookmark-name {
      flex: 1;
      font-size: 10px;
      color: var(--text-primary);
    }
    .bookmark-frame {
      font-size: 9px;
      color: var(--text-muted);
    }
    .bookmark-delete {
      font-size: 10px;
      color: var(--error);
      cursor: pointer;
      padding: 2px 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .bookmark-item:hover .bookmark-delete { opacity: 1; }

    /* Timeline Markers */
    .timeline-marker-dot {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 2;
      transition: transform 0.15s;
    }
    .timeline-marker-dot:hover {
      transform: translate(-50%, -50%) scale(1.5);
    }
    #timeline-markers-v2 {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #timeline-markers-v2 .timeline-marker-dot {
      pointer-events: auto;
    }

    /* Settings Panel */
    .settings-panel { max-width: 340px; }
    
    /* Theory Details Panel - Enhanced v2.26 */
    .theory-panel { 
      max-width: 400px; 
      min-height: 450px;
      width: 95vw;
    }
    .theory-panel .panel-content { 
      min-height: 380px; 
      max-height: 72vh;
      overflow-y: auto;
      padding: 12px;
    }
    .theory-panel .panel-section { 
      display: block !important; 
      visibility: visible !important;
      opacity: 1 !important;
    }
    .theory-detail-grid { 
      display: grid; 
      grid-template-columns: repeat(2, 1fr); 
      gap: 10px; 
      margin-bottom: 16px; 
    }
    @media (max-width: 360px) {
      .theory-detail-grid { grid-template-columns: 1fr; }
    }
    .theory-detail-card {
      background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .theory-detail-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 3px; height: 100%;
      background: var(--accent-cyan);
      opacity: 0;
      transition: opacity 0.2s;
    }
    .theory-detail-card:hover { 
      border-color: var(--accent-cyan); 
      transform: translateY(-1px);
    }
    .theory-detail-card:hover::before { opacity: 1; }
    .theory-detail-card.has-data { border-color: var(--border-active); }
    .theory-detail-card.has-data::before { opacity: 0.5; }
    .theory-detail-title { 
      font-size: 9px; 
      color: var(--accent-cyan); 
      font-weight: 600; 
      margin-bottom: 6px; 
      display: flex; 
      align-items: center; 
      gap: 5px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .theory-detail-title .theory-icon { font-size: 12px; }
    .theory-detail-value { 
      font-size: 16px; 
      font-weight: 700; 
      color: var(--text-primary); 
      font-family: 'SF Mono', 'Consolas', monospace;
      min-height: 20px;
    }
    .theory-detail-value.positive { color: var(--success); }
    .theory-detail-value.negative { color: var(--error); }
    .theory-detail-value.neutral { color: var(--warning); }
    .theory-detail-sub { 
      font-size: 8px; 
      color: var(--text-secondary); 
      margin-top: 4px;
      font-family: 'SF Mono', 'Consolas', monospace;
    }
    .theory-formula { font-family: serif; font-style: italic; font-size: 8px; color: var(--text-secondary); background: var(--bg-tertiary); padding: 2px 4px; border-radius: 3px; margin-top: 3px; display: inline-block; }
    .theory-phase-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 7px; font-weight: 600; text-transform: uppercase; }
    .theory-phase-badge.ordered { background: var(--success); color: #000; }
    .theory-phase-badge.disordered { background: var(--error); color: #fff; }
    .theory-phase-badge.critical { background: var(--warning); color: #000; }
    .sensor-toggle-item {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      margin-bottom: 8px;
    }
    .sensor-toggle-item.disabled { opacity: 0.5; }
    .sensor-toggle-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .sensor-toggle-name { font-size: 11px; font-weight: 600; }
    .sensor-toggle-status {
      font-size: 8px;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-quaternary);
    }
    .sensor-toggle-status.granted { background: #0a4030; color: var(--success); }
    .sensor-toggle-status.denied { background: #4a1520; color: var(--error); }
    .sensor-toggle-status.prompt { background: #3a3010; color: var(--warning); }
    .sensor-toggle-status.off { background: var(--bg-quaternary); color: var(--text-muted); }
    .sensor-toggle-note {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 36px;
      height: 20px;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--bg-quaternary);
      border-radius: 20px;
      transition: 0.3s;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background: var(--text-tertiary);
      border-radius: 50%;
      transition: 0.3s;
    }
    .toggle-switch input:checked + .toggle-slider { background: var(--accent-blue); }
    .toggle-switch input:checked + .toggle-slider:before { transform: translateX(16px); background: #fff; }
    .toggle-switch input:disabled + .toggle-slider { opacity: 0.5; cursor: not-allowed; }
    .permission-summary {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
    }
    .perm-item {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border);
    }
    .perm-item:last-child { border-bottom: none; }
    .perm-status { font-weight: 600; }
    .perm-status.granted { color: var(--success); }
    .perm-status.denied { color: var(--error); }
    .perm-status.prompt { color: var(--warning); }
    .settings-reset-btn {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      color: var(--text-secondary);
      font-size: 10px;
      cursor: pointer;
      margin-top: 10px;
    }
    .settings-reset-btn:hover { background: var(--bg-quaternary); color: var(--text-primary); }
    
    /* Manual Location */
    .manual-location {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
      display: none;
    }
    .manual-location.visible { display: block; }
    .manual-location-label { font-size: 8px; color: var(--text-muted); margin-bottom: 6px; }
    .manual-location-inputs { display: flex; gap: 4px; margin-bottom: 6px; }
    .manual-input {
      flex: 1;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 9px;
      color: var(--text-primary);
    }
    .manual-input:focus { outline: none; border-color: var(--accent-blue); }
    .manual-set-btn {
      background: var(--accent-blue);
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 8px;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
    }
    .manual-current-btn {
      width: 100%;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px;
      font-size: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    .manual-current-btn:hover { background: var(--bg-quaternary); color: var(--text-primary); }
    
    /* Sensor Status Badge in Header */
    .sensor-status-bar {
      position: fixed;
      top: 36px; right: 8px;
      display: flex;
      gap: 3px;
      z-index: 101;
      padding: 3px;
      background: rgba(8,8,12,0.9);
      border-radius: 8px;
    }
    .sensor-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
      position: relative;
    }
    .sensor-status-dot.active { background: var(--success); }
    .sensor-status-dot.denied { background: var(--error); }
    .sensor-status-dot.off { background: var(--text-muted); opacity: 0.4; }
    .sensor-status-dot.stale { background: var(--warning); }
    .sensor-status-dot.degraded { background: var(--warning); animation: pulse 2s infinite; }
    .sensor-status-dot.pending { background: var(--accent-blue); animation: pulse 1s infinite; }
    .sensor-health-badge {
      font-size: 7px;
      font-weight: 600;
      padding: 1px 4px;
      border-radius: 4px;
      margin-left: 2px;
      background: var(--bg-quaternary);
      color: var(--text-tertiary);
    }
    .sensor-health-badge.good { background: #0a4030; color: var(--success); }
    .sensor-health-badge.warn { background: #3a3010; color: var(--warning); }
    .sensor-health-badge.bad { background: #4a1520; color: var(--error); }
    .sensor-status-dot::after {
      content: attr(data-sensor);
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 5px;
      color: var(--text-muted);
      white-space: nowrap;
      display: none;
    }
    .sensor-status-bar:hover .sensor-status-dot::after { display: block; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SENSOR MONITOR DASHBOARD â€” v2.26
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .sensor-monitor-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .sensor-monitor-card {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      transition: all 0.2s;
    }
    .sensor-monitor-card.healthy { border-color: var(--success); }
    .sensor-monitor-card.degraded { border-color: var(--warning); }
    .sensor-monitor-card.failed { border-color: var(--error); }
    .sensor-monitor-card.init { border-color: var(--text-muted); }
    
    .sensor-monitor-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }
    .sensor-monitor-icon { font-size: 14px; }
    .sensor-monitor-name {
      flex: 1;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-primary);
    }
    .sensor-monitor-status {
      font-size: 8px;
      padding: 2px 6px;
      border-radius: 8px;
      text-transform: uppercase;
    }
    .sensor-monitor-status.healthy { background: var(--success); color: #000; }
    .sensor-monitor-status.degraded { background: var(--warning); color: #000; }
    .sensor-monitor-status.failed { background: var(--error); color: #fff; }
    .sensor-monitor-status.init { background: var(--text-muted); color: #000; }
    
    .sensor-monitor-body {
      display: flex;
      gap: 8px;
      align-items: center;
      min-height: 40px;
    }
    
    .sensor-mini-graph {
      width: 60px;
      height: 30px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
    }
    .sensor-mini-graph.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      color: var(--text-muted);
    }
    .sensor-mini-graph svg {
      width: 100%;
      height: 100%;
    }
    
    .sensor-monitor-values {
      flex: 1;
    }
    .sensor-monitor-value {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent-cyan);
    }
    .sensor-monitor-meta {
      font-size: 8px;
      color: var(--text-muted);
    }
    
    .sensor-monitor-stats {
      display: flex;
      gap: 8px;
      font-size: 8px;
      color: var(--text-secondary);
      border-top: 1px solid var(--border);
      margin-top: 6px;
      padding-top: 6px;
    }
    
    .sensor-monitor-controls {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }
    .sensor-ctrl-btn {
      flex: 1;
      padding: 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .sensor-ctrl-btn:hover {
      background: var(--accent-cyan);
      color: #000;
    }
    
    .sensor-monitor-summary {
      display: flex;
      gap: 8px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 12px;
    }
    .sensor-monitor-summary .summary-item {
      flex: 1;
      text-align: center;
      font-size: 9px;
      color: var(--text-secondary);
    }
    .sensor-monitor-summary .summary-item.good { color: var(--success); }
    .sensor-monitor-summary .summary-item.warn { color: var(--warning); }
    .sensor-monitor-summary .summary-item.bad { color: var(--error); }
    
    .sensor-calibration-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--accent-cyan);
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
    }
    .calibration-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 11px;
      font-weight: 600;
    }
    .calibration-header button {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 14px;
    }
    .calibration-body {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .calibration-body label {
      font-size: 10px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .calibration-body input {
      width: 60px;
      padding: 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 10px;
    }
    .cal-apply-btn, .cal-reset-btn {
      padding: 4px 10px;
      border: none;
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
    }
    .cal-apply-btn { background: var(--accent-cyan); color: #000; }
    .cal-reset-btn { background: var(--bg-tertiary); color: var(--text-primary); }
    
    /* Sensor Profile Selector */
    .sensor-profile-selector {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }
    .sensor-profile-btn {
      flex: 1;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 9px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
    }
    .sensor-profile-btn:hover {
      border-color: var(--accent-cyan);
    }
    .sensor-profile-btn.active {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }
    .sensor-profile-btn .profile-icon {
      display: block;
      font-size: 16px;
      margin-bottom: 2px;
    }
    
    /* Sensor Control Panel */
    .sensor-control-panel {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
    }
    .sensor-control-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .sensor-control-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-purple);
    }
    .sensor-control-actions {
      display: flex;
      gap: 4px;
    }
    .sensor-control-actions button {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 8px;
      cursor: pointer;
    }
    .sensor-control-actions button:hover {
      background: var(--accent-purple);
      color: #fff;
    }
    
    /* Policy Compliance */
    .policy-status {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .policy-item {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 3px 6px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
    }
    .policy-item.compliant { color: var(--success); }
    .policy-item.violation { color: var(--error); }
    .policy-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.11 â€” SYMBOL MESH NETWORK VISUALIZATION
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .mesh-panel {
      max-width: 380px;
      min-height: 500px;
    }
    .mesh-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
    }
    .mesh-svg {
      width: 100%;
      height: 250px;
      background: linear-gradient(135deg, #0a0a14 0%, #12121f 100%);
      border-radius: 6px;
    }
    .mesh-node {
      cursor: pointer;
      transition: r 0.15s;
    }
    .mesh-node:hover { filter: brightness(1.3); }
    .mesh-node.selected { stroke: #fff; stroke-width: 2; }
    .mesh-edge { opacity: 0.4; }
    .mesh-label {
      font-size: 8px;
      fill: var(--text-secondary);
      pointer-events: none;
    }
    .mesh-legend {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .mesh-legend-item {
      font-size: 9px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .mesh-stats {
      font-size: 9px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 6px;
    }
    .mesh-empty {
      padding: 40px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
    }
    .node-detail {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 10px;
      margin-top: 10px;
    }
    .node-detail-header {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 6px;
    }
    .node-detail-type, .node-detail-data {
      font-size: 9px;
      color: var(--text-secondary);
    }
    .node-detail-connections {
      font-size: 9px;
      color: var(--text-secondary);
      margin-top: 8px;
      line-height: 1.4;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.11 â€” CAUSAL CHAIN TIMELINE
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .chain-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .chain-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .chain-item {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .chain-item:hover { border-color: var(--accent-purple); }
    .chain-item.selected { border-color: var(--accent-cyan); background: var(--accent-cyan)10; }
    .chain-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .chain-id {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .chain-confidence {
      font-size: 8px;
      padding: 2px 6px;
      border-radius: 8px;
    }
    .chain-confidence.high { background: var(--success); color: #000; }
    .chain-confidence.medium { background: var(--warning); color: #000; }
    .chain-confidence.low { background: var(--error); color: #fff; }
    .chain-timeline {
      display: flex;
      align-items: center;
      gap: 2px;
      flex-wrap: wrap;
    }
    .chain-event {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .chain-event-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-purple);
    }
    .chain-event-label {
      font-size: 8px;
      color: var(--text-secondary);
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chain-arrow {
      color: var(--accent-orange);
      font-size: 10px;
      margin: 0 2px;
    }
    .chain-meta {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 6px;
    }
    .chain-summary {
      display: flex;
      justify-content: space-around;
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 8px;
      margin-top: 10px;
    }
    .chain-stat {
      font-size: 9px;
      color: var(--text-secondary);
    }
    .chain-empty {
      padding: 30px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
    }
    .chain-detail {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 10px;
      margin-top: 10px;
    }
    .chain-detail-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-purple);
      margin-bottom: 8px;
    }
    .chain-detail-flow {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .chain-detail-event {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px;
      background: var(--bg-primary);
      border-radius: 4px;
    }
    .chain-detail-frame {
      font-size: 9px;
      color: var(--accent-cyan);
      font-weight: 600;
    }
    .chain-detail-type {
      font-size: 9px;
      color: var(--text-primary);
      flex: 1;
    }
    .chain-detail-cause {
      font-size: 8px;
      color: var(--text-muted);
    }
    .chain-detail-arrow {
      font-size: 8px;
      color: var(--accent-orange);
      text-align: center;
      padding: 2px;
    }
    .chain-detail-meta {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: center;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.11 â€” MFIDEL ENCODING DISPLAY
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .mfidel-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-top: 10px;
    }
    .mfidel-encoding {
      font-family: 'Nyala', 'Abyssinica SIL', 'Noto Sans Ethiopic', serif;
      font-size: 18px;
      line-height: 1.6;
      color: var(--accent-cyan);
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 12px;
      word-break: break-all;
      text-align: center;
      letter-spacing: 2px;
    }
    .mfidel-signature {
      font-family: 'Nyala', 'Abyssinica SIL', 'Noto Sans Ethiopic', serif;
      font-size: 24px;
      color: var(--accent-purple);
      text-align: center;
      margin: 10px 0;
      letter-spacing: 4px;
    }
    .mfidel-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    .mfidel-stat {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }
    .mfidel-stat-label { color: var(--text-secondary); }
    .mfidel-stat-value { color: var(--accent-cyan); font-weight: 600; }
    .mfidel-legend {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: center;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.11 â€” NARRATIVE PANEL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .narrative-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .narrative-text {
      font-size: 11px;
      line-height: 1.6;
      color: var(--text-primary);
      text-align: justify;
    }
    .narrative-moments {
      margin-top: 12px;
      border-top: 1px solid var(--border);
      padding-top: 10px;
    }
    .narrative-moment {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 9px;
    }
    .narrative-moment-time {
      color: var(--accent-cyan);
      font-weight: 600;
      min-width: 40px;
    }
    .narrative-moment-label {
      color: var(--text-secondary);
    }
    .narrative-moment-type {
      padding: 1px 4px;
      border-radius: 4px;
      font-size: 7px;
      text-transform: uppercase;
    }
    .narrative-moment-type.motion { background: var(--accent-orange); color: #000; }
    .narrative-moment-type.scene { background: var(--accent-purple); color: #fff; }
    .narrative-moment-type.start { background: var(--success); color: #000; }
    .narrative-moment-type.end { background: var(--error); color: #fff; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.12 â€” INCEPTADIVE DEEP EXPLORER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .dive-panel {
      max-width: 400px;
      min-height: 520px;
    }
    .dive-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .dive-empty {
      padding: 40px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
    }
    .dive-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .dive-depth {
      font-size: 10px;
      color: var(--accent-purple);
      font-weight: 600;
    }
    .dive-frame {
      font-size: 10px;
      color: var(--text-muted);
    }
    .dive-current {
      background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
      border: 1px solid var(--accent-cyan);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: center;
    }
    .dive-dimension {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent-cyan);
      margin-bottom: 4px;
    }
    .dive-question {
      font-size: 10px;
      color: var(--text-secondary);
      text-transform: uppercase;
    }
    .dive-findings {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 12px;
      max-height: 120px;
      overflow-y: auto;
    }
    .dive-finding {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 10px;
      border-bottom: 1px solid var(--border);
    }
    .dive-finding:last-child { border-bottom: none; }
    .dive-finding-label {
      color: var(--text-muted);
      min-width: 80px;
    }
    .dive-finding-value {
      color: var(--text-primary);
      flex: 1;
    }
    .dive-finding-conf {
      color: var(--accent-cyan);
      font-size: 9px;
    }
    .dive-nav-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }
    .dive-nav-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .dive-nav-btn:hover:not(:disabled) {
      border-color: var(--dim-color, var(--accent-cyan));
      background: var(--bg-secondary);
    }
    .dive-nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .dive-nav-icon { font-size: 16px; }
    .dive-nav-label { font-size: 8px; margin-top: 2px; }
    .dive-patterns {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }
    .dive-pattern-btn {
      flex: 1;
      padding: 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 9px;
      cursor: pointer;
    }
    .dive-pattern-btn:hover:not(:disabled) {
      background: var(--accent-purple);
      color: #fff;
    }
    .dive-pattern-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .dive-path {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 8px;
    }
    .dive-path-title {
      font-size: 9px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }
    .dive-path-trail {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 4px;
    }
    .dive-path-node {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--node-color, var(--accent-cyan));
      color: #000;
      font-size: 8px;
      font-weight: 600;
    }
    .dive-path-arrow {
      color: var(--text-muted);
      font-size: 10px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.12 â€” SYMBOL ONTOLOGY BROWSER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .ontology-panel {
      max-width: 340px;
    }
    .ontology-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .ontology-tree {
      font-family: monospace;
      font-size: 11px;
    }
    .ontology-node {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
      cursor: pointer;
      transition: background 0.15s;
    }
    .ontology-node:hover {
      background: var(--bg-tertiary);
    }
    .ontology-toggle {
      width: 12px;
      text-align: center;
      color: var(--text-muted);
      font-size: 9px;
    }
    .ontology-icon { font-size: 12px; }
    .ontology-label { 
      flex: 1;
      color: var(--text-primary);
    }
    .ontology-count {
      background: var(--accent-cyan);
      color: #000;
      font-size: 9px;
      padding: 1px 6px;
      border-radius: 8px;
      font-weight: 600;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.12 â€” SYMBOLIC QUERY PANEL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .sql-panel {
      max-width: 450px;
    }
    .sql-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .sql-input-wrap {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }
    .sql-input {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
      font-family: monospace;
    }
    .sql-input:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }
    .sql-run-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      background: var(--accent-cyan);
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    .sql-examples {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 12px;
    }
    .sql-example {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 9px;
      cursor: pointer;
    }
    .sql-example:hover {
      border-color: var(--accent-cyan);
    }
    .sql-result {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 12px;
      font-family: monospace;
      font-size: 10px;
      line-height: 1.5;
      white-space: pre-wrap;
      color: var(--text-primary);
      max-height: 250px;
      overflow-y: auto;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.13 â€” AUDIO WAVEFORM VISUALIZER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .audio-panel {
      max-width: 380px;
    }
    .audio-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .audio-empty {
      padding: 30px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
    }
    .audio-waveform-svg {
      width: 100%;
      height: 80px;
      border-radius: 6px;
    }
    .audio-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    .audio-stat {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
    }
    .audio-stat span:first-child { color: var(--text-muted); }
    .audio-stat span:last-child { color: var(--accent-cyan); font-weight: 600; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.13 â€” MOTION TRAJECTORY OVERLAY
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .motion-panel {
      max-width: 380px;
    }
    .motion-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .motion-empty {
      padding: 30px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
    }
    .motion-trajectory-svg {
      width: 100%;
      height: 180px;
      border-radius: 6px;
    }
    .motion-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 10px;
      font-size: 10px;
      color: var(--text-secondary);
    }
    .motion-controls label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .motion-controls input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }
    .motion-frame {
      margin-left: auto;
      color: var(--accent-cyan);
      font-weight: 600;
    }
    .motion-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-top: 8px;
    }
    .motion-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
    }
    .motion-stat span:first-child { color: var(--text-muted); }
    .motion-stat span:last-child { font-weight: 600; }
    .motion-type-static { color: #666; }
    .motion-type-accelerating { color: #ff6644; }
    .motion-type-decelerating { color: #44aaff; }
    .motion-type-fast { color: #ff88aa; }
    .motion-type-steady { color: #88cc44; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.13 â€” MULLU EXPORT PANEL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .mullu-panel {
      max-width: 400px;
    }
    .mullu-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .mullu-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    .mullu-logo {
      font-size: 24px;
    }
    .mullu-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-purple);
    }
    .mullu-version {
      font-size: 9px;
      color: var(--text-muted);
    }
    .mullu-preview {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 10px;
      font-family: monospace;
      font-size: 9px;
      max-height: 150px;
      overflow-y: auto;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }
    .mullu-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    .mullu-stat {
      display: flex;
      justify-content: space-between;
      padding: 6px 10px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 10px;
    }
    .mullu-stat-label { color: var(--text-muted); }
    .mullu-stat-value { color: var(--accent-cyan); font-weight: 600; }
    .mullu-actions {
      display: flex;
      gap: 8px;
    }
    .mullu-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .mullu-btn-primary {
      background: var(--accent-purple);
      color: #fff;
    }
    .mullu-btn-primary:hover { background: #9966ff; }
    .mullu-btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    .mullu-btn-secondary:hover { border-color: var(--accent-cyan); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.13 â€” PERFORMANCE MONITOR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .perf-monitor {
      display: flex;
      gap: 8px;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
    }
    .perf-metric {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .perf-label { color: var(--text-muted); }
    .perf-value { font-weight: 600; }
    .perf-good { color: var(--success); }
    .perf-medium { color: var(--warning); }
    .perf-poor { color: var(--error); }
    .perf-mini-graph {
      width: 80px;
      height: 30px;
    }
    .perf-mini-label {
      font-size: 8px;
      fill: var(--text-secondary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.14 â€” PATTERN DETECTOR STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .pattern-panel {
      max-width: 400px;
    }
    .pattern-container {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .pattern-header {
      display: flex;
      justify-content: space-around;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .pattern-stat {
      text-align: center;
    }
    .pattern-stat-value {
      display: block;
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .pattern-stat-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .pattern-section {
      margin-bottom: 12px;
    }
    .pattern-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .pattern-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .pattern-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .pattern-item:hover {
      background: var(--bg-secondary);
      border-left: 2px solid var(--accent-cyan);
    }
    .pattern-item.highlight {
      border-left: 2px solid #ffcc44;
    }
    .pattern-item.anomaly {
      border-left: 2px solid #ff6644;
    }
    .pattern-item.anomaly.high {
      background: rgba(255, 102, 68, 0.1);
    }
    .pattern-type {
      flex: 1;
      color: var(--text-primary);
      text-transform: capitalize;
    }
    .pattern-frame {
      color: var(--text-muted);
      font-family: monospace;
    }
    .pattern-conf {
      color: var(--accent-cyan);
      font-weight: 600;
    }
    .pattern-score {
      color: #ffcc44;
      font-weight: 600;
    }
    .pattern-severity {
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 8px;
      text-transform: uppercase;
    }
    .pattern-severity.high { background: #ff6644; color: #fff; }
    .pattern-severity.medium { background: #ffcc44; color: #000; }
    .pattern-more {
      text-align: center;
      color: var(--text-muted);
      font-size: 9px;
      padding: 4px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.14 â€” HELP OVERLAY STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .help-panel {
      max-width: 600px;
      max-height: 80vh;
    }
    .help-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
    .help-section {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 12px;
    }
    .help-section-title {
      font-size: 11px;
      font-weight: 700;
      color: var(--accent-cyan);
      margin-bottom: 10px;
      text-transform: uppercase;
    }
    .help-shortcut {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }
    .help-key {
      display: inline-block;
      min-width: 50px;
      padding: 4px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      text-align: center;
      color: var(--text-primary);
    }
    .help-action {
      font-size: 10px;
      color: var(--text-secondary);
    }
    .help-footer {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .help-tip {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.14 â€” SMART TIMELINE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .smart-timeline-container {
      margin-top: 8px;
    }
    .smart-timeline-empty {
      text-align: center;
      padding: 10px;
      color: var(--text-muted);
      font-size: 10px;
    }
    .smart-timeline-track {
      position: relative;
      height: 32px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
    }
    .smart-timeline-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(34, 221, 238, 0.1) 0%,
        rgba(136, 85, 255, 0.1) 50%,
        rgba(34, 221, 238, 0.1) 100%);
    }
    .smart-timeline-scenes {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 12px;
    }
    .smart-timeline-scene {
      position: absolute;
      height: 100%;
      opacity: 0.6;
      transition: opacity 0.15s;
    }
    .smart-timeline-scene:hover { opacity: 1; }
    .smart-timeline-scene.bright { background: #ffcc44; }
    .smart-timeline-scene.dark { background: #4466aa; }
    .smart-timeline-scene.colorful { background: #ff88aa; }
    .smart-timeline-scene.flat { background: #888888; }
    .smart-timeline-scene.detailed { background: #88cc44; }
    .smart-timeline-scene.default { background: #666666; }
    .smart-timeline-markers {
      position: absolute;
      top: 14px;
      left: 0;
      right: 0;
      height: 8px;
    }
    .smart-timeline-marker {
      position: absolute;
      width: 3px;
      height: 100%;
      transform: translateX(-50%);
      border-radius: 1px;
    }
    .smart-timeline-marker.entropy_spike { background: #ff6644; }
    .smart-timeline-marker.motion_spike { background: #ffcc44; }
    .smart-timeline-marker.scene_change { background: #22ddee; }
    .smart-timeline-marker.luminance_shift { background: #8855ff; }
    .smart-timeline-marker.sustained_motion { background: #88cc44; }
    .smart-timeline-marker.stillness { background: #4466aa; }
    .smart-timeline-highlights {
      position: absolute;
      top: 24px;
      left: 0;
      right: 0;
      height: 8px;
    }
    .smart-timeline-highlight {
      position: absolute;
      transform: translateX(-50%);
      color: #ffcc44;
      font-size: 8px;
      cursor: pointer;
    }
    .smart-timeline-highlight:hover {
      transform: translateX(-50%) scale(1.3);
    }
    .smart-timeline-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #fff;
      transform: translateX(-50%);
      pointer-events: none;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
    }
    .smart-timeline-info {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      font-size: 9px;
      color: var(--text-muted);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.14 â€” SETTINGS PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .settings-section {
      margin-bottom: 16px;
    }
    .settings-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .settings-row:last-child { border-bottom: none; }
    .settings-label {
      font-size: 11px;
      color: var(--text-primary);
    }
    .settings-toggle {
      position: relative;
      width: 36px;
      height: 20px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .settings-toggle.active { background: var(--accent-cyan); }
    .settings-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.2s;
    }
    .settings-toggle.active::after { transform: translateX(16px); }
    .settings-select {
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 10px;
    }
    .theme-buttons {
      display: flex;
      gap: 8px;
    }
    .theme-btn {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 10px;
      cursor: pointer;
    }
    .theme-btn.active {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    .theme-btn:hover { background: var(--bg-secondary); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.15 â€” ONBOARDING GUIDE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    #onboarding-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10000;
    }
    .onboarding-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
    }
    .onboarding-modal {
      position: absolute;
      background: var(--bg-secondary);
      border: 1px solid var(--accent-cyan);
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    .onboarding-modal.center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .onboarding-modal.right {
      top: 50%;
      left: 60%;
      transform: translateY(-50%);
    }
    .onboarding-modal.bottom {
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
    }
    .onboarding-modal.top {
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
    }
    .onboarding-progress {
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .onboarding-progress-bar {
      height: 100%;
      background: var(--accent-cyan);
      transition: width 0.3s ease;
    }
    .onboarding-step {
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .onboarding-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0 0 12px 0;
    }
    .onboarding-content {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
      margin: 0 0 20px 0;
    }
    .onboarding-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    .onboarding-btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }
    .onboarding-btn.primary {
      background: var(--accent-cyan);
      color: #000;
    }
    .onboarding-btn.primary:hover {
      background: #44eeff;
    }
    .onboarding-btn.secondary {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    .onboarding-btn.secondary:hover {
      border-color: var(--text-secondary);
    }
    .onboarding-highlight {
      position: relative;
      z-index: 10001;
      box-shadow: 0 0 0 4px var(--accent-cyan), 0 0 20px var(--accent-cyan);
      border-radius: 8px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.15 â€” STATUS DASHBOARD STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    #status-dashboard {
      position: fixed;
      top: 60px;
      right: 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 16px;
      min-width: 160px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      display: none;
    }
    #status-dashboard.visible {
      display: block;
    }
    .status-state {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .status-icon {
      font-size: 18px;
    }
    .status-label {
      font-size: 14px;
      font-weight: 700;
      color: var(--state-color);
    }
    .status-metrics {
      display: flex;
      gap: 16px;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .status-metric {
      display: flex;
      flex-direction: column;
    }
    .status-metric-value {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .status-metric-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .status-hint {
      font-size: 10px;
      color: var(--text-muted);
    }
    .status-warning {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
      padding: 6px 10px;
      background: rgba(255, 170, 68, 0.15);
      border-radius: 6px;
      font-size: 10px;
      color: #ffaa44;
    }
    .status-warning-icon {
      font-size: 12px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.17 â€” RECORDING CONFIRMATION DIALOG
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .recording-confirm-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10000;
    }
    .recording-confirm-dialog .confirm-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
    }
    .recording-confirm-dialog .confirm-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 30px;
      min-width: 320px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    .recording-confirm-dialog .confirm-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    .recording-confirm-dialog .confirm-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    .recording-confirm-dialog .confirm-message {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .recording-confirm-dialog .confirm-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    .recording-confirm-dialog .confirm-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .recording-confirm-dialog .confirm-btn.save {
      background: var(--accent-cyan);
      color: #000;
    }
    .recording-confirm-dialog .confirm-btn.save:hover {
      background: #44eeff;
    }
    .recording-confirm-dialog .confirm-btn.discard {
      background: #ff4444;
      color: #fff;
    }
    .recording-confirm-dialog .confirm-btn.discard:hover {
      background: #ff6666;
    }
    .recording-confirm-dialog .confirm-btn.cancel {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }
    .recording-confirm-dialog .confirm-btn.cancel:hover {
      background: var(--bg-primary);
    }
    
    /* Paused state for record button */
    .btn-record.paused {
      background: linear-gradient(135deg, #ffaa44, #ff8800) !important;
      animation: pulse-paused 1.5s infinite;
    }
    @keyframes pulse-paused {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 170, 68, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(255, 170, 68, 0); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.18 â€” CLIP EDITOR STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .clip-editor-panel {
      max-width: 500px;
    }
    .clip-timeline-container {
      position: relative;
      height: 60px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .clip-timeline-track {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      height: 40px;
      background: var(--bg-primary);
      border-radius: 4px;
    }
    .clip-timeline-selection {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(34, 221, 238, 0.3);
      border: 2px solid var(--accent-cyan);
      border-radius: 4px;
      display: none;
    }
    .clip-timeline-marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background: #ff8844;
    }
    .clip-timeline-playhead {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background: #fff;
      z-index: 10;
    }
    .clip-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .clip-control-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .clip-control-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .clip-control-btn.primary {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }
    .clip-list {
      max-height: 250px;
      overflow-y: auto;
    }
    .clip-empty {
      text-align: center;
      padding: 30px;
      color: var(--text-muted);
    }
    .clip-hint {
      display: block;
      font-size: 10px;
      margin-top: 8px;
    }
    .clip-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 8px;
      transition: all 0.15s;
      border-left: 4px solid var(--clip-color, var(--accent-cyan));
    }
    .clip-item:hover {
      background: var(--bg-secondary);
    }
    .clip-item.selected {
      background: rgba(34, 221, 238, 0.15);
      border-left-color: var(--accent-cyan);
    }
    .clip-color-bar {
      width: 4px;
      height: 30px;
      background: var(--clip-color);
      border-radius: 2px;
    }
    .clip-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .clip-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .clip-meta {
      font-size: 10px;
      color: var(--text-muted);
    }
    .clip-tags {
      font-size: 9px;
      color: var(--accent-cyan);
    }
    .clip-actions {
      display: flex;
      gap: 4px;
    }
    .clip-btn {
      padding: 6px 8px;
      border: none;
      border-radius: 4px;
      background: var(--bg-primary);
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }
    .clip-btn:hover {
      background: var(--accent-cyan);
    }
    .clip-btn.delete:hover {
      background: #ff4444;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.18 â€” EXPORT PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .export-panel {
      max-width: 400px;
    }
    .export-formats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    .export-format-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.15s;
    }
    .export-format-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .export-format-btn.selected {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.2);
    }
    .export-format-icon {
      font-size: 24px;
    }
    .export-format-label {
      font-size: 11px;
      font-weight: 600;
    }
    .export-format-ext {
      font-size: 9px;
      color: var(--text-muted);
    }
    .export-progress {
      margin-top: 16px;
    }
    .export-progress-bar-container {
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      overflow: hidden;
    }
    .export-progress-bar {
      height: 100%;
      background: var(--accent-cyan);
      width: 0%;
      transition: width 0.3s;
    }
    .export-progress-text {
      text-align: center;
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
    }
    .export-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    .export-action-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .export-action-btn.primary {
      background: var(--accent-cyan);
      color: #000;
    }
    .export-action-btn.primary:hover {
      background: #44eeff;
    }
    .export-action-btn.secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.19 â€” ANNOTATION TIMELINE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .annotation-panel {
      max-width: 600px;
    }
    .timeline-container {
      background: #0a0a10;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    .timeline-canvas {
      display: block;
      width: 100%;
      cursor: crosshair;
    }
    .timeline-controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 0 0 8px 8px;
    }
    .timeline-zoom-btn {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
    }
    .timeline-zoom-btn:hover {
      border-color: var(--accent-cyan);
    }
    
    /* Marker Editor */
    .marker-editor {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 12px;
    }
    .marker-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .marker-add-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: var(--accent-cyan);
      color: #000;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
    }
    .marker-add-btn:hover {
      background: #44eeff;
    }
    .marker-type-selector {
      display: flex;
      gap: 4px;
    }
    .marker-type-btn {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .marker-type-btn:hover {
      border-color: var(--type-color, var(--accent-cyan));
    }
    .marker-type-btn.active {
      border-color: var(--type-color, var(--accent-cyan));
      background: color-mix(in srgb, var(--type-color, var(--accent-cyan)) 20%, transparent);
    }
    
    /* Marker Edit Form */
    .marker-edit-form {
      background: var(--bg-secondary);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .marker-edit-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .marker-edit-row:last-child {
      margin-bottom: 0;
    }
    .marker-edit-row label {
      font-size: 11px;
      color: var(--text-muted);
      width: 50px;
    }
    .marker-edit-row input[type="text"],
    .marker-edit-row input[type="number"] {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
    }
    .marker-edit-row input[type="color"] {
      width: 40px;
      height: 28px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .marker-edit-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .marker-goto-btn,
    .marker-delete-btn {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }
    .marker-goto-btn {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .marker-delete-btn {
      background: #ff4444;
      color: #fff;
    }
    
    /* Marker List */
    .marker-no-selection {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
    }
    .marker-no-selection .hint {
      font-size: 10px;
      margin-top: 8px;
    }
    .marker-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .marker-clear-btn {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-muted);
      font-size: 10px;
      cursor: pointer;
    }
    .marker-clear-btn:hover {
      background: #ff4444;
      color: #fff;
    }
    .marker-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .marker-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 11px;
    }
    .marker-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: all 0.15s;
      border-left: 3px solid var(--marker-color, var(--accent-cyan));
    }
    .marker-list-item:hover {
      background: var(--bg-primary);
    }
    .marker-list-item.selected {
      background: rgba(34, 221, 238, 0.15);
    }
    .marker-icon {
      font-size: 14px;
    }
    .marker-label {
      flex: 1;
      font-size: 12px;
      color: var(--text-primary);
    }
    .marker-frame {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }
    
    /* Notes Panel */
    .notes-panel {
      max-width: 400px;
    }
    .notes-frame-indicator {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .notes-textarea {
      width: 100%;
      height: 120px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
      resize: vertical;
    }
    .notes-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .notes-action-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
    }
    .notes-action-btn.save {
      background: var(--accent-cyan);
      color: #000;
    }
    .notes-action-btn.clear {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .notes-list {
      margin-top: 16px;
      max-height: 200px;
      overflow-y: auto;
    }
    .notes-list-header {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .note-item {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 6px;
    }
    .note-frame {
      font-size: 10px;
      color: var(--accent-cyan);
      font-family: monospace;
      white-space: nowrap;
    }
    .note-text {
      flex: 1;
      font-size: 11px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.20 â€” UNDO/REDO INDICATOR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .undo-redo-indicator {
      position: fixed;
      bottom: 80px;
      left: 20px;
      display: flex;
      gap: 4px;
      z-index: 100;
    }
    .undo-btn, .redo-btn {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .undo-btn:hover, .redo-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .undo-btn:disabled, .redo-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.20 â€” KEYBOARD CHEATSHEET STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .cheatsheet-panel {
      max-width: 800px;
      max-height: 80vh;
    }
    .cheatsheet-content {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      max-height: 60vh;
      overflow-y: auto;
      padding: 4px;
    }
    .cheatsheet-category {
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 12px;
    }
    .cheatsheet-category-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .cheatsheet-category-icon {
      font-size: 16px;
    }
    .cheatsheet-category-name {
      font-size: 12px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .cheatsheet-shortcuts {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .cheatsheet-shortcut {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .cheatsheet-keys {
      display: flex;
      align-items: center;
      gap: 2px;
    }
    .cheatsheet-key {
      display: inline-block;
      padding: 3px 6px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      color: var(--text-primary);
      min-width: 20px;
      text-align: center;
    }
    .key-plus {
      color: var(--text-muted);
      font-size: 10px;
      margin: 0 2px;
    }
    .cheatsheet-action {
      font-size: 10px;
      color: var(--text-secondary);
      text-align: right;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.20 â€” HISTORY PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .history-panel {
      max-width: 350px;
    }
    .history-header-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .history-clear-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-size: 10px;
      cursor: pointer;
    }
    .history-clear-btn:hover {
      background: #ff4444;
      color: #fff;
    }
    .history-list {
      max-height: 400px;
      overflow-y: auto;
    }
    .history-empty {
      text-align: center;
      padding: 30px;
      color: var(--text-muted);
      font-size: 12px;
    }
    .history-section-label {
      font-size: 10px;
      color: var(--text-muted);
      padding: 8px 0 4px;
      text-transform: uppercase;
    }
    .history-current {
      padding: 10px;
      background: rgba(34, 221, 238, 0.15);
      border-radius: 6px;
      font-size: 11px;
      color: var(--accent-cyan);
      text-align: center;
      margin: 8px 0;
    }
    .history-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .history-item:hover {
      background: var(--bg-secondary);
    }
    .history-item.undo {
      border-left: 3px solid #ffaa44;
    }
    .history-item.redo {
      border-left: 3px solid #4ecdc4;
      opacity: 0.7;
    }
    .history-icon {
      font-size: 12px;
      color: var(--text-muted);
    }
    .history-desc {
      font-size: 11px;
      color: var(--text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.20 â€” BATCH SELECTION STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .batch-mode-indicator {
      position: fixed;
      top: 80px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(136, 85, 255, 0.9);
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
      z-index: 100;
      display: none;
    }
    .batch-mode-indicator.visible {
      display: block;
    }
    .item-selected {
      outline: 2px solid var(--accent-cyan) !important;
      outline-offset: 2px;
    }
    .batch-actions-bar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 10px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      z-index: 100;
      display: none;
    }
    .batch-actions-bar.visible {
      display: flex;
    }
    .batch-action-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .batch-action-btn.delete {
      background: #ff4444;
      color: #fff;
    }
    .batch-action-btn.export {
      background: var(--accent-cyan);
      color: #000;
    }
    .batch-action-btn.cancel {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.21 â€” PROJECT BROWSER STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .project-panel {
      max-width: 600px;
      max-height: 80vh;
    }
    .project-browser {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .current-project-info {
      background: rgba(34, 221, 238, 0.1);
      border: 1px solid rgba(34, 221, 238, 0.3);
      border-radius: 10px;
      padding: 14px;
    }
    .project-info-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .project-name {
      font-size: 14px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .unsaved-badge {
      color: #ff8844;
      font-size: 16px;
    }
    .project-info-stats {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }
    .project-info-actions {
      display: flex;
      gap: 8px;
    }
    .project-action-btn {
      padding: 6px 14px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
    }
    .project-action-btn.primary {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }
    .project-action-btn:hover {
      border-color: var(--accent-cyan);
    }
    
    /* Project Tabs */
    .project-tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 4px;
    }
    .project-tab {
      padding: 8px 16px;
      border: none;
      border-radius: 6px 6px 0 0;
      background: transparent;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .project-tab:hover {
      color: var(--text-primary);
    }
    .project-tab.active {
      background: var(--bg-tertiary);
      color: var(--accent-cyan);
    }
    
    /* Project List */
    .project-content {
      max-height: 400px;
      overflow-y: auto;
    }
    .project-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .project-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .project-card:hover {
      border-color: var(--accent-cyan);
      background: var(--bg-secondary);
    }
    .project-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .project-card-name {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .project-card-actions {
      display: flex;
      gap: 4px;
    }
    .project-card-actions button {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: var(--bg-secondary);
      font-size: 12px;
      cursor: pointer;
      opacity: 0.7;
    }
    .project-card-actions button:hover {
      opacity: 1;
    }
    .project-card-actions button.delete:hover {
      background: #ff4444;
    }
    .project-card-desc {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .project-card-meta {
      display: flex;
      gap: 12px;
      font-size: 10px;
      color: var(--text-muted);
    }
    
    /* Empty State */
    .project-empty {
      text-align: center;
      padding: 40px 20px;
    }
    .project-empty-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }
    .project-empty-text {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
    .project-empty-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: var(--accent-cyan);
      color: #000;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Templates */
    .template-section {
      margin-bottom: 20px;
    }
    .template-section-header {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border);
    }
    .template-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .template-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
      position: relative;
    }
    .template-card:hover {
      border-color: var(--accent-cyan);
      transform: translateY(-2px);
    }
    .template-icon {
      font-size: 28px;
      margin-bottom: 8px;
    }
    .template-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }
    .template-desc {
      font-size: 10px;
      color: var(--text-muted);
      line-height: 1.3;
    }
    .template-actions {
      position: absolute;
      top: 6px;
      right: 6px;
    }
    .template-actions button {
      padding: 4px 6px;
      border: none;
      border-radius: 4px;
      background: var(--bg-secondary);
      font-size: 10px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .template-card:hover .template-actions button {
      opacity: 1;
    }
    .template-actions button:hover {
      background: #ff4444;
    }
    
    /* Project Footer */
    .project-footer {
      display: flex;
      gap: 8px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .project-footer-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
    }
    .project-footer-btn:hover {
      border-color: var(--accent-cyan);
    }
    
    /* New Project Dialog */
    .new-project-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .new-project-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .new-project-field label {
      font-size: 11px;
      color: var(--text-muted);
    }
    .new-project-field input,
    .new-project-field textarea {
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
    }
    .new-project-field textarea {
      resize: vertical;
      min-height: 60px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.22 â€” SHARE & COLLABORATION STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .share-panel {
      max-width: 550px;
      max-height: 80vh;
    }
    .share-ui {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .share-tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 4px;
    }
    .share-tab {
      padding: 8px 14px;
      border: none;
      border-radius: 6px 6px 0 0;
      background: transparent;
      color: var(--text-muted);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .share-tab:hover {
      color: var(--text-primary);
    }
    .share-tab.active {
      background: var(--bg-tertiary);
      color: var(--accent-cyan);
    }
    .share-content {
      max-height: 450px;
      overflow-y: auto;
    }
    
    /* Share Links */
    .share-create {
      margin-bottom: 16px;
    }
    .share-create-btn {
      width: 100%;
      padding: 12px;
      border: 2px dashed var(--border);
      border-radius: 10px;
      background: transparent;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .share-create-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .share-empty-state {
      text-align: center;
      padding: 40px 20px;
    }
    .share-empty-icon {
      font-size: 40px;
      margin-bottom: 10px;
      opacity: 0.5;
    }
    .share-empty-text {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }
    .share-empty-hint {
      font-size: 11px;
      color: var(--text-muted);
      opacity: 0.7;
    }
    .share-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .share-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      transition: all 0.15s;
    }
    .share-card.expired {
      opacity: 0.5;
    }
    .share-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .share-card-icon {
      font-size: 16px;
    }
    .share-card-views {
      font-size: 10px;
      color: var(--text-muted);
    }
    .share-card-url {
      font-family: monospace;
      font-size: 11px;
      color: var(--accent-cyan);
      background: var(--bg-primary);
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 8px;
      word-break: break-all;
    }
    .share-card-url:hover {
      background: var(--bg-secondary);
    }
    .share-card-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }
    .share-card-actions {
      display: flex;
      gap: 8px;
    }
    .share-action-btn {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 10px;
      cursor: pointer;
    }
    .share-action-btn:hover {
      border-color: var(--accent-cyan);
    }
    .share-action-btn.delete:hover {
      border-color: #ff4444;
      background: rgba(255, 68, 68, 0.2);
    }
    
    /* Collaborators */
    .collaborator-add {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .collaborator-add-btn, .collaborator-invite-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
    }
    .collaborator-add-btn:hover, .collaborator-invite-btn:hover {
      border-color: var(--accent-cyan);
    }
    .collaborator-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .collaborator-card {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .collaborator-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: #fff;
    }
    .collaborator-info {
      flex: 1;
      min-width: 0;
    }
    .collaborator-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .collaborator-email {
      font-size: 10px;
      color: var(--text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .collaborator-permission select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 10px;
    }
    .collaborator-status {
      font-size: 10px;
      font-weight: 600;
      text-transform: capitalize;
    }
    .collaborator-remove {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
    }
    .collaborator-remove:hover {
      background: #ff4444;
      color: #fff;
    }
    
    /* Comments */
    .comments-stats {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .comment-stat {
      flex: 1;
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .comment-stat.resolved {
      border-left: 3px solid #4ecdc4;
    }
    .comment-stat.unresolved {
      border-left: 3px solid #ff8844;
    }
    .stat-value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
    }
    .comments-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .comments-view-btn, .comments-add-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
    }
    .comments-add-btn {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }
    .comments-recent {
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 14px;
    }
    .comments-recent-header {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 10px;
      text-transform: uppercase;
    }
    .comments-recent-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .recent-comment {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: var(--bg-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .recent-comment:hover {
      background: var(--bg-primary);
    }
    .comment-author-badge {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      color: #fff;
    }
    .comment-preview {
      flex: 1;
      min-width: 0;
    }
    .comment-author-name {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .comment-text-preview {
      font-size: 10px;
      color: var(--text-secondary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .comment-frame-badge {
      padding: 2px 6px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 9px;
      font-family: monospace;
      color: var(--text-muted);
    }
    .no-comments {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 11px;
    }
    
    /* Add Collaborator Dialog */
    .add-collab-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .add-collab-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .add-collab-field label {
      font-size: 11px;
      color: var(--text-muted);
    }
    .add-collab-field input,
    .add-collab-field select {
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 12px;
    }
    
    /* Create Share Dialog */
    .create-share-form {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .share-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }
    .share-option-label {
      font-size: 12px;
      color: var(--text-primary);
    }
    .share-option-desc {
      font-size: 10px;
      color: var(--text-muted);
    }
    .share-toggle {
      position: relative;
      width: 40px;
      height: 22px;
    }
    .share-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .share-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--bg-tertiary);
      border-radius: 22px;
      transition: 0.2s;
    }
    .share-toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background-color: #fff;
      border-radius: 50%;
      transition: 0.2s;
    }
    .share-toggle input:checked + .share-toggle-slider {
      background-color: var(--accent-cyan);
    }
    .share-toggle input:checked + .share-toggle-slider:before {
      transform: translateX(18px);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.23 â€” GLOBAL SEARCH STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .search-panel {
      max-width: 650px;
      max-height: 85vh;
    }
    .search-ui {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .search-input-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--bg-primary);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 12px 16px;
      transition: border-color 0.15s;
    }
    .search-input-container:focus-within {
      border-color: var(--accent-cyan);
    }
    .search-icon {
      font-size: 18px;
      opacity: 0.6;
    }
    .search-input {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      outline: none;
    }
    .search-input::placeholder {
      color: var(--text-muted);
    }
    .search-clear {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      cursor: pointer;
    }
    .search-clear:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    
    /* Type Filters */
    .search-type-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .search-type-filter {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      border-radius: 20px;
      background: var(--bg-tertiary);
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s;
    }
    .search-type-filter input {
      display: none;
    }
    .search-type-filter.active {
      background: rgba(34, 221, 238, 0.2);
      color: var(--accent-cyan);
    }
    .search-type-filter:hover {
      background: var(--bg-secondary);
    }
    
    /* Filter Bar */
    .search-filter-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .filter-presets {
      display: flex;
      gap: 4px;
    }
    .filter-preset-btn {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .filter-preset-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .filter-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .filter-count {
      font-size: 10px;
      color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
      padding: 4px 8px;
      border-radius: 10px;
    }
    .clear-filters-btn {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-muted);
      font-size: 10px;
      cursor: pointer;
    }
    .clear-filters-btn:hover {
      color: var(--accent-cyan);
    }
    .sort-select {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 10px;
      cursor: pointer;
    }
    
    /* Search Content */
    .search-content {
      max-height: 500px;
      overflow-y: auto;
    }
    .search-section {
      margin-bottom: 20px;
    }
    .search-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .clear-history-btn {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-muted);
      font-size: 10px;
      cursor: pointer;
    }
    .clear-history-btn:hover {
      color: #ff6b6b;
    }
    
    /* Search History */
    .search-history {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .history-item {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .history-item:hover {
      border-color: var(--accent-cyan);
      color: var(--text-primary);
    }
    
    /* Saved Searches */
    .saved-searches {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .saved-search-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .saved-search-item:hover {
      background: var(--bg-secondary);
    }
    .saved-search-query {
      flex: 1;
      font-size: 12px;
      color: var(--text-primary);
    }
    .saved-search-name {
      font-size: 10px;
      color: var(--text-muted);
      padding: 2px 8px;
      background: var(--bg-secondary);
      border-radius: 10px;
    }
    .saved-search-delete {
      padding: 4px 6px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-muted);
      font-size: 10px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .saved-search-item:hover .saved-search-delete {
      opacity: 1;
    }
    .saved-search-delete:hover {
      color: #ff6b6b;
    }
    
    /* Empty States */
    .search-empty-state, .search-no-results {
      text-align: center;
      padding: 50px 20px;
    }
    .search-empty-icon, .no-results-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }
    .search-empty-text, .no-results-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }
    .search-empty-hint, .no-results-hint {
      font-size: 11px;
      color: var(--text-muted);
    }
    
    /* Results */
    .search-results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }
    .search-results-header span {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .save-search-btn {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: transparent;
      color: var(--text-primary);
      font-size: 10px;
      cursor: pointer;
    }
    .save-search-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .result-section {
      margin-bottom: 20px;
    }
    .result-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border);
    }
    .result-count {
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      font-size: 10px;
    }
    .result-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .result-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .result-item:hover {
      background: var(--bg-secondary);
      transform: translateX(4px);
    }
    .result-item-icon {
      font-size: 16px;
      opacity: 0.7;
    }
    .result-item-content {
      flex: 1;
      min-width: 0;
    }
    .result-item-title {
      font-size: 12px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-item-title mark {
      background: rgba(34, 221, 238, 0.3);
      color: var(--text-primary);
      padding: 0 2px;
      border-radius: 2px;
    }
    .result-item-subtitle {
      font-size: 10px;
      color: var(--text-muted);
    }
    .result-item-meta {
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
    }
    
    /* Quick Search Dropdown */
    .quick-search-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-top: 4px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    .quick-search-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .quick-search-item:hover {
      background: var(--bg-tertiary);
    }
    .quick-search-item-icon {
      font-size: 14px;
    }
    .quick-search-item-text {
      flex: 1;
      font-size: 12px;
      color: var(--text-primary);
    }
    .quick-search-item-type {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.25 â€” MAIN MENU STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .main-menu-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 9999;
      pointer-events: none;
    }
    .main-menu {
      display: none;
      pointer-events: auto;
    }
    .main-menu.open {
      display: block;
    }
    .menu-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.3);
      z-index: -1;
    }
    .menu-bar {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0 10px;
      padding-left: 60px; /* Space for toggle button */
      position: relative;
      z-index: 1;
    }
    .menu-section {
      position: relative;
    }
    .menu-section-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 14px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .menu-section-btn:hover, .menu-section-btn.active {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .menu-icon {
      font-size: 14px;
    }
    .menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 220px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      padding: 6px 0;
      z-index: 10000;
      animation: menuFadeIn 0.15s ease-out;
    }
    @keyframes menuFadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .menu-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 10px 16px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 12px;
      text-align: left;
      cursor: pointer;
      transition: background 0.1s;
    }
    .menu-item:hover {
      background: var(--bg-tertiary);
    }
    .menu-item-shortcut {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }
    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 6px 0;
    }
    
    /* Menu Toggle Button */
    .menu-toggle-btn {
      position: fixed;
      top: 12px;
      left: 12px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      font-size: 18px;
      cursor: pointer;
      z-index: 9998;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transition: all 0.15s;
    }
    .menu-toggle-btn:hover {
      background: var(--accent-cyan);
      color: #000;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.25 â€” INFO PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .info-panel {
      max-width: 500px;
      max-height: 85vh;
    }
    .info-panel-content {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .info-section {
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 14px;
    }
    .info-section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .info-icon {
      font-size: 16px;
    }
    .info-badge {
      margin-left: auto;
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .info-badge.healthy {
      background: rgba(34, 221, 100, 0.2);
      color: #22dd64;
    }
    .info-badge.degraded, .info-badge.warning {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }
    .info-badge.unhealthy {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .info-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .info-item.full-width {
      grid-column: span 2;
    }
    .info-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .info-value {
      font-size: 12px;
      color: var(--text-primary);
    }
    .info-checks {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .info-check {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-secondary);
      border-radius: 6px;
      font-size: 11px;
    }
    .info-check.ok .check-icon {
      color: #22dd64;
    }
    .info-check.error .check-icon {
      color: #ff6b6b;
    }
    .check-name {
      color: var(--text-primary);
      flex: 1;
    }
    .check-detail {
      color: var(--text-muted);
      font-size: 10px;
    }
    .info-memory {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .memory-bar {
      height: 8px;
      background: var(--bg-secondary);
      border-radius: 4px;
      overflow: hidden;
    }
    .memory-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
      border-radius: 4px;
      transition: width 0.3s;
    }
    .memory-stats {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-muted);
    }
    .info-stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    .stat-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: var(--bg-secondary);
      border-radius: 8px;
    }
    .stat-number {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .stat-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    .info-actions {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .info-action-btn {
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .info-action-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .info-footer {
      display: flex;
      justify-content: center;
      gap: 8px;
      font-size: 10px;
      color: var(--text-muted);
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }
    .info-footer a {
      color: var(--accent-cyan);
      text-decoration: none;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.25 â€” DASHBOARD STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .dashboard-panel {
      max-width: 700px;
      max-height: 90vh;
    }
    .dashboard {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }
    .dashboard-logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo-icon {
      font-size: 36px;
      color: var(--accent-cyan);
    }
    .logo-text {
      display: flex;
      flex-direction: column;
    }
    .logo-title {
      font-size: 22px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .logo-subtitle {
      font-size: 11px;
      color: var(--text-muted);
    }
    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 600;
    }
    .status-badge.healthy {
      background: rgba(34, 221, 100, 0.2);
      color: #22dd64;
    }
    .status-badge.warning {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }
    .dashboard-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .dashboard-section-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0;
    }
    .quick-start-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .quick-start-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 20px;
      border: 2px dashed var(--border);
      border-radius: 12px;
      background: var(--bg-tertiary);
      cursor: pointer;
      transition: all 0.15s;
      text-align: center;
    }
    .quick-start-card:hover {
      border-color: var(--accent-cyan);
      border-style: solid;
      background: rgba(34, 221, 238, 0.05);
    }
    .qs-icon {
      font-size: 28px;
    }
    .qs-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .qs-desc {
      font-size: 10px;
      color: var(--text-muted);
    }
    .current-project-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      border-left: 4px solid var(--accent-cyan);
    }
    .cp-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .cp-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .cp-meta {
      font-size: 11px;
      color: var(--text-muted);
    }
    .cp-actions {
      display: flex;
      gap: 8px;
    }
    .cp-actions button {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .cp-actions button:hover {
      background: var(--accent-cyan);
      color: #000;
    }
    .recent-projects-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .recent-project-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border: none;
      border-radius: 8px;
      background: var(--bg-tertiary);
      cursor: pointer;
      transition: all 0.15s;
      text-align: left;
      width: 100%;
    }
    .recent-project-item:hover {
      background: var(--bg-secondary);
      transform: translateX(4px);
    }
    .rp-icon {
      font-size: 18px;
    }
    .rp-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .rp-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .rp-meta {
      font-size: 10px;
      color: var(--text-muted);
    }
    .rp-arrow {
      color: var(--text-muted);
      font-size: 14px;
    }
    .no-projects {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 40px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }
    .np-icon {
      font-size: 36px;
      opacity: 0.5;
    }
    .np-text {
      font-size: 13px;
      color: var(--text-muted);
    }
    .np-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: var(--accent-cyan);
      color: #000;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .features-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .feature-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .feature-card:hover {
      background: var(--bg-secondary);
      transform: translateY(-2px);
    }
    .feat-icon {
      font-size: 22px;
    }
    .feat-title {
      font-size: 11px;
      color: var(--text-secondary);
    }
    .dashboard-footer {
      display: flex;
      justify-content: center;
      gap: 8px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      font-size: 10px;
      color: var(--text-muted);
    }
    .dashboard-footer a {
      color: var(--accent-cyan);
      text-decoration: none;
      cursor: pointer;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.25 â€” ABOUT DIALOG STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .about-panel {
      max-width: 400px;
    }
    .about-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      text-align: center;
    }
    .about-logo {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .about-icon {
      font-size: 48px;
      color: var(--accent-cyan);
    }
    .about-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .about-version {
      font-size: 14px;
      color: var(--accent-cyan);
    }
    .about-tagline {
      font-size: 12px;
      color: var(--text-muted);
    }
    .about-description {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.6;
      max-width: 320px;
    }
    .about-features {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .about-feature {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border-radius: 20px;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .about-credits {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }
    .credit-item {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
    }
    .credit-label {
      color: var(--text-muted);
    }
    .credit-value {
      color: var(--text-primary);
    }
    .credit-item a {
      color: var(--accent-cyan);
      text-decoration: none;
    }
    .about-copyright {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” STATUS BAR STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 28px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: none; /* Hidden by default, shown after initialization */
      align-items: center;
      padding: 0 12px;
      font-size: 11px;
      z-index: 9000;
      gap: 4px;
    }
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 10px;
      color: var(--text-secondary);
      border-right: 1px solid var(--border);
      height: 100%;
    }
    .status-item:last-child {
      border-right: none;
      margin-left: auto;
    }
    .status-item.clickable {
      cursor: pointer;
      transition: background 0.1s;
    }
    .status-item.clickable:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .status-icon {
      font-size: 12px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }
    .status-dot.recording {
      background: #ff4444;
      animation: statusPulse 1s infinite;
    }
    .status-dot.playing {
      background: #22dd64;
    }
    .status-dot.paused {
      background: #ffc107;
    }
    @keyframes statusPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .status-badge {
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .status-badge.saved {
      background: rgba(34, 221, 100, 0.2);
      color: #22dd64;
    }
    .status-badge.unsaved {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” BREADCRUMB STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .breadcrumbs {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      overflow-x: auto;
    }
    .breadcrumb-item {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-muted);
      white-space: nowrap;
    }
    .breadcrumb-item.clickable {
      cursor: pointer;
      transition: color 0.1s;
    }
    .breadcrumb-item.clickable:hover {
      color: var(--accent-cyan);
    }
    .breadcrumb-item.current {
      color: var(--text-primary);
      font-weight: 600;
    }
    .breadcrumb-separator {
      color: var(--text-muted);
      font-size: 10px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” CONTEXT MENU STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .context-menu {
      position: fixed;
      min-width: 180px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      padding: 6px 0;
      z-index: 99999;
      animation: contextFadeIn 0.1s ease-out;
    }
    @keyframes contextFadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      padding: 8px 14px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 12px;
      text-align: left;
      cursor: pointer;
      transition: background 0.1s;
    }
    .context-menu-item:hover {
      background: var(--bg-tertiary);
    }
    .context-menu-item.danger {
      color: #ff6b6b;
    }
    .context-menu-item.disabled {
      color: var(--text-muted);
      pointer-events: none;
    }
    .context-menu-item-icon {
      width: 16px;
      text-align: center;
    }
    .context-menu-item-shortcut {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }
    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 6px 0;
    }
    .context-menu-header {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” TIMELINE MINIMAP STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .timeline-minimap {
      height: 24px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      margin: 8px 0;
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }
    .minimap-track {
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      background: var(--bg-secondary);
      border-radius: 2px;
    }
    .minimap-density {
      position: absolute;
      top: 0;
      bottom: 0;
      background: var(--accent-cyan);
      opacity: 0.3;
    }
    .minimap-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent-magenta);
    }
    .minimap-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 3px;
      background: #fff;
      box-shadow: 0 0 4px rgba(0,0,0,0.5);
      z-index: 2;
    }
    .minimap-viewport {
      position: absolute;
      top: 0;
      bottom: 0;
      background: rgba(34, 221, 238, 0.15);
      border: 1px solid var(--accent-cyan);
      border-radius: 2px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” NOTIFICATION CENTER STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .notification-bell {
      position: relative;
      cursor: pointer;
    }
    .notification-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 16px;
      height: 16px;
      background: #ff4444;
      color: #fff;
      font-size: 9px;
      font-weight: 700;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
    }
    .notification-panel {
      position: fixed;
      top: 60px;
      right: 20px;
      width: 320px;
      max-height: 400px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      z-index: 9999;
      display: none;
    }
    .notification-panel.open {
      display: block;
    }
    .notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
    }
    .notification-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .notification-clear {
      font-size: 11px;
      color: var(--accent-cyan);
      background: none;
      border: none;
      cursor: pointer;
    }
    .notification-list {
      max-height: 320px;
      overflow-y: auto;
    }
    .notification-item {
      display: flex;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      transition: background 0.1s;
    }
    .notification-item:hover {
      background: var(--bg-tertiary);
    }
    .notification-item:last-child {
      border-bottom: none;
    }
    .notification-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }
    .notification-icon.success {
      background: rgba(34, 221, 100, 0.2);
    }
    .notification-icon.warning {
      background: rgba(255, 193, 7, 0.2);
    }
    .notification-icon.error {
      background: rgba(255, 107, 107, 0.2);
    }
    .notification-icon.info {
      background: rgba(34, 221, 238, 0.2);
    }
    .notification-content {
      flex: 1;
      min-width: 0;
    }
    .notification-message {
      font-size: 12px;
      color: var(--text-primary);
      margin-bottom: 4px;
    }
    .notification-time {
      font-size: 10px;
      color: var(--text-muted);
    }
    .notification-empty {
      padding: 40px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” FLOATING ACTIONS BAR STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .floating-actions {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      padding: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 30px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 8000;
    }
    .floating-action-group {
      display: flex;
      gap: 4px;
      padding-right: 8px;
      border-right: 1px solid var(--border);
    }
    .floating-action-group:last-child {
      padding-right: 0;
      border-right: none;
    }
    .floating-action-btn {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .floating-action-btn:hover {
      background: var(--accent-cyan);
      color: #000;
      transform: scale(1.1);
    }
    .floating-action-btn.recording {
      background: #ff4444;
      color: #fff;
      animation: floatPulse 1s infinite;
    }
    @keyframes floatPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255,68,68,0.4); }
      50% { box-shadow: 0 0 0 8px rgba(255,68,68,0); }
    }
    .floating-action-btn.active {
      background: var(--accent-cyan);
      color: #000;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.27 â€” ENHANCED UX STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Loading spinner for async operations */
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-cyan);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .spinner.small { width: 14px; height: 14px; border-width: 2px; }
    .spinner.large { width: 32px; height: 32px; border-width: 3px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Progress bar for exports/operations */
    .progress-bar {
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    .progress-bar.indeterminate .progress-bar-fill {
      width: 30%;
      animation: indeterminate 1.5s ease-in-out infinite;
    }
    @keyframes indeterminate {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(400%); }
    }
    
    /* Better button states */
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    .btn.loading {
      position: relative;
      color: transparent !important;
    }
    .btn.loading::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      top: 50%;
      left: 50%;
      margin: -8px 0 0 -8px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    /* Enhanced tooltips */
    [data-tooltip] {
      position: relative;
    }
    [data-tooltip]::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-4px);
      padding: 6px 10px;
      background: var(--bg-quaternary);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s, transform 0.15s;
      z-index: 10000;
    }
    [data-tooltip]:hover::before {
      opacity: 1;
      transform: translateX(-50%) translateY(-8px);
    }
    
    /* Keyboard shortcut badges */
    .kbd {
      display: inline-block;
      padding: 2px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 10px;
      font-family: monospace;
      color: var(--text-secondary);
    }
    
    /* Recording pulse ring */
    .recording-ring {
      position: absolute;
      inset: -4px;
      border: 2px solid var(--error);
      border-radius: 50%;
      animation: recordingRing 1.5s ease-out infinite;
      pointer-events: none;
    }
    @keyframes recordingRing {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }
    
    /* Frame capture flash */
    .capture-flash {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.1);
      pointer-events: none;
      opacity: 0;
      z-index: 9999;
    }
    .capture-flash.active {
      animation: captureFlash 0.15s ease-out;
    }
    @keyframes captureFlash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Status indicator improvements */
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    .status-indicator.recording {
      background: rgba(255,68,68,0.2);
      color: #ff8888;
    }
    .status-indicator.paused {
      background: rgba(255,170,68,0.2);
      color: #ffcc88;
    }
    .status-indicator.ready {
      background: rgba(68,221,170,0.2);
      color: #88ffcc;
    }
    
    /* Improved mobile touch targets */
    @media (max-width: 768px) {
      .btn { min-height: 44px; min-width: 44px; }
      .floating-action-btn { width: 48px; height: 48px; }
      .quick-action-btn { min-height: 48px; padding: 10px 16px; }
      .menu-item { min-height: 44px; }
      .panel-tab { min-height: 40px; }
    }
    
    /* Smooth scrollbars */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-active);
    }
    
    /* Focus ring for accessibility */
    :focus-visible {
      outline: 2px solid var(--accent-cyan);
      outline-offset: 2px;
    }
    
    /* Skeleton loading */
    .skeleton {
      background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-quaternary) 50%, var(--bg-tertiary) 75%);
      background-size: 200% 100%;
      animation: skeleton 1.5s ease-in-out infinite;
      border-radius: 4px;
    }
    @keyframes skeleton {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    /* Error state styling */
    .error-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
      color: var(--text-secondary);
    }
    .error-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    .error-state-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    .error-state-message {
      font-size: 13px;
      max-width: 280px;
      margin-bottom: 16px;
    }
    
    /* Empty state styling */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
      color: var(--text-tertiary);
    }
    .empty-state-icon {
      font-size: 40px;
      margin-bottom: 12px;
      opacity: 0.4;
    }
    .empty-state-text {
      font-size: 13px;
    }
    
    /* V2.27 Keyboard Shortcuts Overlay */
    .shortcuts-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 99999;
      align-items: center;
      justify-content: center;
    }
    .shortcuts-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(4px);
    }
    .shortcuts-modal {
      position: relative;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: modalSlideIn 0.2s ease-out;
    }
    @keyframes modalSlideIn {
      from { transform: scale(0.95); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .shortcuts-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }
    .shortcuts-header h3 {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }
    .shortcuts-close {
      width: 28px;
      height: 28px;
      border: none;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    .shortcuts-close:hover {
      background: var(--bg-quaternary);
      color: var(--text-primary);
    }
    .shortcuts-content {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      max-height: 50vh;
      overflow-y: auto;
    }
    .shortcuts-category h4 {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-cyan);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0 0 10px 0;
    }
    .shortcuts-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .shortcut-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .shortcut-keys {
      display: flex;
      gap: 4px;
    }
    .shortcut-action {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .shortcuts-footer {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      text-align: center;
      font-size: 11px;
      color: var(--text-tertiary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” EXPORT PRESETS STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .export-presets {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }
    .export-preset-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: var(--bg-tertiary);
      border: 2px solid transparent;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .export-preset-card:hover {
      border-color: var(--border);
    }
    .export-preset-card.selected {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }
    .export-preset-icon {
      font-size: 24px;
    }
    .export-preset-info {
      flex: 1;
    }
    .export-preset-name {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .export-preset-desc {
      font-size: 10px;
      color: var(--text-muted);
    }
    .export-preset-check {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: transparent;
    }
    .export-preset-card.selected .export-preset-check {
      border-color: var(--accent-cyan);
      background: var(--accent-cyan);
      color: #000;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” STARRED/FAVORITES STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .star-btn {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.15s;
      padding: 4px;
    }
    .star-btn:hover {
      color: #ffc107;
      transform: scale(1.2);
    }
    .star-btn.starred {
      color: #ffc107;
    }
    .starred-section {
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }
    .starred-section-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #ffc107;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” RECENT ACTIONS PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .recent-actions {
      max-height: 200px;
      overflow-y: auto;
    }
    .recent-action-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border);
    }
    .recent-action-item:last-child {
      border-bottom: none;
    }
    .recent-action-icon {
      font-size: 14px;
    }
    .recent-action-text {
      flex: 1;
    }
    .recent-action-time {
      font-size: 9px;
      color: var(--text-muted);
    }
    .recent-action-undo {
      font-size: 10px;
      color: var(--accent-cyan);
      background: none;
      border: none;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.1s;
    }
    .recent-action-item:hover .recent-action-undo {
      opacity: 1;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” WORKSPACE LAYOUT STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .workspace-layouts {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .workspace-layout-btn {
      flex: 1;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
      text-align: center;
    }
    .workspace-layout-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-primary);
    }
    .workspace-layout-btn.active {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
      color: var(--accent-cyan);
    }
    .workspace-layout-icon {
      font-size: 20px;
      display: block;
      margin-bottom: 6px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” SYMBOL PALETTE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .symbol-palette {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }
    .symbol-palette-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 12px 8px;
      border: 1px dashed var(--border);
      border-radius: 8px;
      background: var(--bg-secondary);
      cursor: grab;
      transition: all 0.15s;
    }
    .symbol-palette-item:hover {
      border-color: var(--accent-cyan);
      border-style: solid;
      transform: translateY(-2px);
    }
    .symbol-palette-item:active {
      cursor: grabbing;
    }
    .symbol-palette-icon {
      font-size: 20px;
    }
    .symbol-palette-label {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.26 â€” WH QUERY BUILDER STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .wh-query-builder {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }
    .wh-query-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .wh-query-label {
      min-width: 60px;
      padding: 6px 10px;
      background: var(--accent-cyan);
      color: #000;
      font-size: 11px;
      font-weight: 700;
      border-radius: 6px;
      text-align: center;
    }
    .wh-query-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 12px;
    }
    .wh-query-input:focus {
      border-color: var(--accent-cyan);
      outline: none;
    }
    .wh-query-execute {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: var(--accent-cyan);
      color: #000;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .wh-query-execute:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(34, 221, 238, 0.3);
    }

    /* Adjust main content for status bar */
    body {
      padding-bottom: 28px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.15 â€” QUICK ACTIONS BAR STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Quick Actions Bar - hidden by default, original controls are used instead */
    #quick-actions-bar {
      display: none !important;
    }
    .quick-action-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      border: none;
      border-radius: 30px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .quick-action-btn:hover {
      background: var(--accent-cyan);
      color: #000;
    }
    .quick-action-btn.record {
      background: #ff4444;
      color: #fff;
    }
    .quick-action-btn.record:hover {
      background: #ff6666;
    }
    .quick-action-btn.recording {
      background: #ff4444;
      color: #fff;
      animation: pulse-recording 1s infinite;
    }
    @keyframes pulse-recording {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
    }
    .quick-action-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .quick-action-btn.disabled:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .quick-action-btn.help {
      padding: 10px 12px;
    }
    .quick-action-icon {
      font-size: 14px;
    }
    .quick-action-label {
      font-size: 11px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.15 â€” TOAST NOTIFICATION STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    #toast-container {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10000;
      pointer-events: none;
    }
    .toast {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      pointer-events: auto;
    }
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .toast-success { border-color: #88cc44; }
    .toast-error { border-color: #ff4444; }
    .toast-warning { border-color: #ffaa44; }
    .toast-info { border-color: var(--accent-cyan); }
    .toast-icon {
      font-size: 16px;
    }
    .toast-message {
      font-size: 12px;
      color: var(--text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.16 â€” PWA & MOBILE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Online/Offline indicator */
    .online-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-left: 8px;
    }
    .online-indicator.online { background: #88cc44; }
    .online-indicator.offline { background: #ff4444; }
    
    /* PWA Install button */
    #pwa-install-btn {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: var(--accent-cyan);
      color: #000;
      border: none;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      margin-left: 10px;
    }
    #pwa-install-btn:hover {
      background: #44eeff;
    }
    
    /* Mobile-specific styles */
    .mobile-device #quick-actions-bar {
      padding: 6px 10px;
      gap: 4px;
    }
    .mobile-device .quick-action-btn {
      padding: 12px 14px;
    }
    .mobile-device .quick-action-label {
      display: none;
    }
    .mobile-device #status-dashboard {
      top: auto;
      bottom: 160px;
      right: 10px;
      max-width: 140px;
      font-size: 11px;
    }
    
    /* Landscape mobile */
    #quick-actions-bar.landscape {
      flex-direction: column;
      bottom: auto;
      right: 10px;
      top: 50%;
      left: auto;
      transform: translateY(-50%);
      border-radius: 30px;
    }
    
    /* Portrait mode warning */
    .orientation-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      border: 1px solid var(--accent-cyan);
      border-radius: 12px;
      padding: 30px;
      text-align: center;
      z-index: 10000;
      display: none;
    }
    .mobile-device[data-orientation="portrait"] .orientation-warning {
      display: block;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.16 â€” DATA PANEL STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .data-panel {
      max-width: 450px;
    }
    .data-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .data-panel-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .data-panel-count {
      padding: 4px 10px;
      background: var(--accent-cyan);
      color: #000;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
    }
    .data-panel-empty {
      text-align: center;
      padding: 30px;
      color: var(--text-muted);
    }
    .data-panel-hint {
      display: block;
      margin-top: 8px;
      font-size: 10px;
    }
    .data-panel-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    .data-panel-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      transition: all 0.15s;
    }
    .data-panel-item:hover {
      background: var(--bg-secondary);
      border-left: 3px solid var(--accent-cyan);
    }
    .data-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .data-item-name {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .data-item-meta {
      font-size: 10px;
      color: var(--accent-cyan);
    }
    .data-item-date {
      font-size: 9px;
      color: var(--text-muted);
    }
    .data-item-actions {
      display: flex;
      gap: 4px;
    }
    .data-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      background: var(--bg-primary);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }
    .data-btn:hover {
      background: var(--accent-cyan);
    }
    .data-btn.delete:hover {
      background: #ff4444;
    }
    .data-panel-footer {
      display: flex;
      gap: 10px;
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .data-action-btn {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: transparent;
      color: var(--text-primary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .data-action-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(34, 221, 238, 0.1);
    }

    /* Storage indicator */
    .storage-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
      font-size: 10px;
      color: var(--text-muted);
    }
    .storage-bar {
      flex: 1;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      overflow: hidden;
    }
    .storage-bar-fill {
      height: 100%;
      background: var(--accent-cyan);
      transition: width 0.3s;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.17 â€” ACCESSIBILITY STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Screen reader only content */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    
    /* Skip link */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--accent-cyan);
      color: #000;
      padding: 8px 16px;
      z-index: 100000;
      text-decoration: none;
      font-weight: 600;
      border-radius: 0 0 8px 0;
    }
    .skip-link:focus {
      top: 0;
    }
    
    /* Focus styles */
    :focus-visible {
      outline: 2px solid var(--accent-cyan);
      outline-offset: 2px;
    }
    
    button:focus-visible,
    .quick-action-btn:focus-visible {
      outline: 2px solid var(--accent-cyan);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(34, 221, 238, 0.3);
    }
    
    /* Reduced motion */
    .reduce-motion * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    /* High contrast improvements */
    @media (prefers-contrast: high) {
      :root {
        --border: #888;
        --text-muted: #aaa;
      }
      .quick-action-btn {
        border: 2px solid currentColor;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.17 â€” CAMERA CONTROLS STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    .camera-controls {
      padding: 16px;
    }
    .camera-control-section {
      margin-bottom: 16px;
    }
    .camera-label {
      display: block;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    .camera-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .camera-btn {
      padding: 8px 14px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .camera-btn:hover {
      border-color: var(--accent-cyan);
    }
    .camera-btn.active {
      background: var(--accent-cyan);
      color: #000;
      border-color: var(--accent-cyan);
    }
    .camera-btn.wide {
      flex: 1;
      min-width: 100px;
    }
    .camera-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      appearance: none;
      cursor: pointer;
    }
    .camera-slider::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-cyan);
      cursor: pointer;
    }
    .camera-info {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      font-size: 10px;
      color: var(--text-muted);
    }
    .camera-info-item {
      display: inline-block;
      margin-right: 16px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       V2.17 â€” PERFORMANCE STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Light throttle: reduce animations */
    .reduce-animations .panel {
      transition: none;
    }
    .reduce-animations .toast {
      transition: opacity 0.1s;
    }
    
    /* Heavy throttle: minimal updates */
    .minimal-updates .smart-timeline-markers,
    .minimal-updates .motion-trails {
      display: none;
    }
    
    /* Performance indicator */
    .perf-badge {
      position: fixed;
      top: 60px;
      left: 10px;
      padding: 4px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 9px;
      font-family: monospace;
      color: var(--text-muted);
      z-index: 100;
    }
    .perf-badge.warning { border-color: #ffaa44; color: #ffaa44; }
    .perf-badge.critical { border-color: #ff4444; color: #ff4444; }
  </style>
</head>
<body>
  <!-- V2.25 Main Menu Container -->
  <div id="main-menu-container"></div>
  
  <!-- V2.25 Menu Toggle Button -->
  <button class="menu-toggle-btn" id="menu-toggle" onclick="toggleMainMenu()" title="Menu (Alt+M)">â˜°</button>
  
  <!-- V2.17 UI Containers -->
  <div id="onboarding-container"></div>
  <div id="status-dashboard"></div>
  <div id="quick-actions-bar"></div>
  <div id="toast-container"></div>
  <div id="online-indicator" class="online-indicator online" title="Online"></div>
  
  <header class="header">
    <div class="logo" style="cursor: pointer;" onclick="openDashboard()" title="Open Dashboard">
      <div class="logo-icon">ðŸŽ¬</div>
      <span class="logo-text">VIRECAI</span>
      <span class="logo-version">v2.26</span>
    </div>
    <span class="chip mode-full" id="mode-chip">Full</span>
    <div class="chip state idle" id="state-chip">
      <span class="state-dot"></span>
      <span id="state-text">Idle</span>
    </div>
    <button onclick="openInfoPanel()" style="margin-left: auto; padding: 6px 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-secondary); font-size: 11px; cursor: pointer;" title="System Info">â„¹ï¸ Info</button>
  </header>

  <div class="pipeline-bar" id="pipeline-bar">
    <div class="sensor-status-bar" id="sensor-status-bar">
      <div class="sensor-status-dot" id="dot-video" data-sensor="VID" title="Video"></div>
      <div class="sensor-status-dot" id="dot-audio" data-sensor="AUD" title="Audio"></div>
      <div class="sensor-status-dot" id="dot-gps" data-sensor="GPS" title="GPS"></div>
      <div class="sensor-status-dot" id="dot-motion" data-sensor="MOT" title="Motion"></div>
      <div class="sensor-status-dot" id="dot-env" data-sensor="ENV" title="Environment"></div>
      <div class="sensor-health-badge" id="sensor-health-badge" title="Sensor Health">â€”</div>
    </div>
    <div class="pipeline-stage sense" id="stage-sense"><div class="pipeline-stage-fill" id="fill-sense"></div><span class="pipeline-stage-label">Sense</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage sync" id="stage-sync"><div class="pipeline-stage-fill" id="fill-sync"></div><span class="pipeline-stage-label">Sync</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage symbol" id="stage-symbol"><div class="pipeline-stage-fill" id="fill-symbol"></div><span class="pipeline-stage-label">Symbol</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage reason" id="stage-reason"><div class="pipeline-stage-fill" id="fill-reason"></div><span class="pipeline-stage-label">Reason</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage validate" id="stage-validate"><div class="pipeline-stage-fill" id="fill-validate"></div><span class="pipeline-stage-label">Valid</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage chain" id="stage-chain"><div class="pipeline-stage-fill" id="fill-chain"></div><span class="pipeline-stage-label">Chain</span></div>
    <div class="pipeline-connector">â€º</div>
    <div class="pipeline-stage store" id="stage-store"><div class="pipeline-stage-fill" id="fill-store"></div><span class="pipeline-stage-label">Store</span></div>
  </div>

  <div class="video-container"><video id="video" autoplay muted playsinline></video></div>
  <canvas id="vf-canvas" class="hidden" width="128" height="72"></canvas>
  <canvas id="frame-canvas" class="hidden" width="320" height="180"></canvas>

  <div class="sensor-panel" id="sensor-panel">
    <div class="sensor-card" id="card-video">
      <div class="sensor-card-header"><span class="sensor-card-name">Video</span><span class="sensor-card-health" id="health-video"></span></div>
      <div class="sensor-card-value" id="val-video">â€”</div>
      <div class="sensor-card-meta"><span id="meta-video-fps">â€”</span><span id="meta-video-res">â€”</span></div>
      <div class="sensor-card-conf"><div class="sensor-card-conf-fill" id="conf-video" style="width:0%"></div></div>
      <div class="sensor-card-uncertainty" id="unc-video">Ïƒ: â€”</div>
    </div>
    <div class="sensor-card" id="card-audio">
      <div class="sensor-card-header"><span class="sensor-card-name">Audio</span><span class="sensor-card-health" id="health-audio"></span></div>
      <div class="sensor-card-value" id="val-audio">â€”</div>
      <div class="sensor-card-meta"><span id="meta-audio-freq">â€”</span><span id="meta-audio-clip">â€”</span></div>
      <div class="sensor-card-conf"><div class="sensor-card-conf-fill" id="conf-audio" style="width:0%"></div></div>
      <div class="sensor-card-uncertainty" id="unc-audio">Ïƒ: â€”</div>
    </div>
    <div class="sensor-card" id="card-gps">
      <div class="sensor-card-header"><span class="sensor-card-name">GPS</span><span class="sensor-card-health" id="health-gps"></span></div>
      <div class="sensor-card-value gps-value" id="val-gps" title="Hover for full coords">â€”</div>
      <div class="sensor-card-meta"><span id="meta-gps-acc">â€”</span><span id="meta-gps-age">â€”</span></div>
      <div class="sensor-card-conf"><div class="sensor-card-conf-fill" id="conf-gps" style="width:0%"></div></div>
      <div class="sensor-card-uncertainty" id="unc-gps">Ïƒ: â€”</div>
    </div>
    <div class="sensor-card" id="card-motion">
      <div class="sensor-card-header"><span class="sensor-card-name">Motion</span><span class="sensor-card-health" id="health-motion"></span></div>
      <div class="sensor-card-value" id="val-motion">â€”</div>
      <div class="sensor-card-meta"><span id="meta-motion-rate">â€”</span><span id="meta-motion-mag">â€”</span></div>
      <div class="sensor-card-conf"><div class="sensor-card-conf-fill" id="conf-motion" style="width:0%"></div></div>
      <div class="sensor-card-uncertainty" id="unc-motion">Ïƒ: â€”</div>
    </div>
    <div class="sensor-card" id="card-env">
      <div class="sensor-card-header"><span class="sensor-card-name">Environ</span><span class="sensor-card-health" id="health-env"></span></div>
      <div class="sensor-card-value" id="val-env">â€”</div>
      <div class="sensor-card-meta"><span id="meta-env-src">â€”</span><span id="meta-env-conf">â€”</span></div>
      <div class="sensor-card-conf"><div class="sensor-card-conf-fill" id="conf-env" style="width:0%"></div></div>
      <div class="sensor-card-uncertainty" id="unc-env">Ïƒ: â€”</div>
    </div>
  </div>

  <div class="metrics-panel" id="metrics-panel">
    <div class="metric-card">
      <div class="metric-card-title">Reality Score</div>
      <div class="metric-card-value" id="metric-score">â€”</div>
      <div class="metric-card-breakdown">
        <div class="metric-card-breakdown-item"><div class="metric-card-breakdown-value" id="metric-int">â€”</div><div class="metric-card-breakdown-label">Int</div></div>
        <div class="metric-card-breakdown-item"><div class="metric-card-breakdown-value" id="metric-cont">â€”</div><div class="metric-card-breakdown-label">Cont</div></div>
        <div class="metric-card-breakdown-item"><div class="metric-card-breakdown-value" id="metric-qual">â€”</div><div class="metric-card-breakdown-label">Qual</div></div>
      </div>
    </div>
    <div class="causal-card" id="causal-card">
      <canvas class="causal-canvas" id="causal-canvas" width="74" height="50"></canvas>
      <div class="causal-stats"><span id="causal-count">0 chains</span><span id="causal-depth">d:0</span></div>
    </div>
    <div class="theory-card" id="theory-card">
      <div class="theory-title">ðŸ“ Theoretical Foundations</div>
      <div class="theory-stats">
        <div class="theory-stat"><span class="theory-label">H</span><span class="theory-value" id="theory-entropy" title="Shannon Entropy">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">Ï„</span><span class="theory-value" id="theory-topology" title="Topological Continuity">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">Î»</span><span class="theory-value" id="theory-lyapunov" title="Lyapunov (Stability)">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">Î£</span><span class="theory-value" id="theory-symmetry" title="Radial Symmetry">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">Îº</span><span class="theory-value" id="theory-curvature" title="Mean Curvature">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">âˆ‡</span><span class="theory-value" id="theory-gradient" title="Gradient Coherence">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">âŠ—</span><span class="theory-value" id="theory-causal" title="Causal Strength">â€”</span></div>
        <div class="theory-stat"><span class="theory-label">Î˜</span><span class="theory-value" id="theory-score" title="Composite Score">â€”</span></div>
      </div>
    </div>
    <div class="vf-card" id="vf-card">
      <div class="vf-grid" id="vf-grid"></div>
      <div class="vf-stats"><span id="vf-lum">L:â€”</span><span id="vf-mot">M:â€”</span><span id="vf-hash">â€”</span></div>
    </div>
  </div>

  <div class="wh-overlay" id="wh-overlay">
    <div class="wh-title">ðŸ” Symbolic Analysis</div>
    <div class="wh-section">
      <div class="wh-row"><span class="wh-label">WHAT</span><span class="wh-value" id="wh-what">â€”</span></div>
      <div class="wh-row"><span class="wh-label">WHERE</span><span class="wh-value" id="wh-where">â€”</span></div>
      <div class="wh-row"><span class="wh-label">WHEN</span><span class="wh-value" id="wh-when">â€”</span></div>
      <div class="wh-row"><span class="wh-label">HOW</span><span class="wh-value" id="wh-how">â€”</span></div>
      <div class="wh-row"><span class="wh-label">WHY</span><span class="wh-value" id="wh-why">â€”</span></div>
    </div>
    <div class="wh-section" style="border-top:1px dashed var(--border);margin-top:4px;padding-top:4px">
      <div class="wh-row"><span class="wh-label" style="color:var(--accent-purple)">BECAUSE</span><span class="wh-value" id="wh-because">â€”</span></div>
    </div>
    <div class="wh-section" style="border-top:1px dashed var(--accent-purple);margin-top:4px;padding-top:4px">
      <div class="wh-row"><span class="wh-label" style="color:var(--accent-orange)">ENTROPY</span><span class="wh-value" id="wh-entropy">â€”</span></div>
      <div class="wh-row"><span class="wh-label" style="color:var(--accent-orange)">TOPOLOGY</span><span class="wh-value" id="wh-topo">â€”</span></div>
      <div class="wh-row"><span class="wh-label" style="color:var(--accent-orange)">SYMMETRY</span><span class="wh-value" id="wh-symmetry">â€”</span></div>
    </div>
  </div>

  <div class="rec-badge" id="rec-badge">
    <span class="rec-badge-dot"></span>
    <span id="rec-time">0:00</span>
    <span>â€¢</span>
    <span id="rec-frames">0f</span>
  </div>

  <div class="controls">
    <div class="controls-top">
      <div class="mode-toggle">
        <button class="mode-btn active" id="mode-full">Full</button>
        <button class="mode-btn lite" id="mode-lite">Lite</button>
      </div>
    </div>
    <div class="controls-main">
      <button class="btn btn-small" id="btn-flip">ðŸ”„</button>
      <button class="btn btn-small" id="btn-settings">âš™ï¸</button>
      <button class="btn btn-record" id="btn-record">âº</button>
      <button class="btn btn-small" id="btn-wh">ðŸ”</button>
      <button class="btn btn-small" id="btn-report">ðŸ“Š</button>
    </div>
    <div class="controls-info">
      <div class="info-item"><span class="info-dot green" id="info-pipe-dot"></span><span id="info-pipe">Idle</span></div>
      <div class="info-item"><span id="info-frames">0 frames</span></div>
      <div class="info-item"><span id="info-symbols">0 symbols</span></div>
      <div class="info-item"><span id="info-size">0 KB</span></div>
    </div>
  </div>

  <div class="start-overlay" id="start-overlay">
    <div class="start-logo">ðŸŽ¬</div>
    <div class="start-title">VIRECAI</div>
    <div class="start-version">v2.27 â€” Complete Symbolic Reality</div>
    <div class="start-tagline">7-stage pipeline with information theory, topological analysis, causal inference, dynamical systems, and mathematical foundations.</div>
    <div class="start-features">
      <div class="start-feature"><div class="start-feature-icon">ðŸ“Š</div><div class="start-feature-name">Entropy</div></div>
      <div class="start-feature"><div class="start-feature-icon">ðŸ”®</div><div class="start-feature-name">Topology</div></div>
      <div class="start-feature"><div class="start-feature-icon">âš¡</div><div class="start-feature-name">Causal</div></div>
      <div class="start-feature"><div class="start-feature-icon">ðŸŒ€</div><div class="start-feature-name">Dynamics</div></div>
      <div class="start-feature"><div class="start-feature-icon">ðŸ”—</div><div class="start-feature-name">Graph</div></div>
      <div class="start-feature"><div class="start-feature-icon">ðŸŽ¯</div><div class="start-feature-name">Measure</div></div>
      <div class="start-feature"><div class="start-feature-icon">ðŸ§¬</div><div class="start-feature-name">Symbol</div></div>
      <div class="start-feature"><div class="start-feature-icon">âœ“</div><div class="start-feature-name">Unified</div></div>
    </div>
    <button class="start-btn" id="start-btn">Initialize System</button>
    <div class="start-log" id="start-log"></div>
  </div>

  <div class="panel-backdrop" id="panel-backdrop"></div>
  
  <!-- Settings Panel -->
  <div class="panel-backdrop" id="settings-backdrop"></div>
  <div class="panel settings-panel" id="settings-panel">
    <div class="panel-header">
      <span class="panel-title">âš™ï¸ Sensor Settings</span>
      <button class="panel-close" id="settings-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="panel-section active">
        <div class="panel-section-title">Sensor Controls</div>
        <p style="font-size:9px;color:var(--text-secondary);margin-bottom:10px">Toggle sensors on/off. Disabled sensors won't be captured.</p>
        
        <div class="sensor-toggle-item" id="toggle-video">
          <div class="sensor-toggle-info">
            <span class="sensor-toggle-name">ðŸŽ¥ Video</span>
            <span class="sensor-toggle-status" id="status-video">â€”</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="switch-video" checked disabled>
            <span class="toggle-slider"></span>
          </label>
          <div class="sensor-toggle-note">Required â€” cannot be disabled</div>
        </div>
        
        <div class="sensor-toggle-item" id="toggle-audio">
          <div class="sensor-toggle-info">
            <span class="sensor-toggle-name">ðŸŽ¤ Audio</span>
            <span class="sensor-toggle-status" id="status-audio">â€”</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="switch-audio" checked>
            <span class="toggle-slider"></span>
          </label>
          <div class="sensor-toggle-note" id="note-audio"></div>
        </div>
        
        <div class="sensor-toggle-item" id="toggle-gps">
          <div class="sensor-toggle-info">
            <span class="sensor-toggle-name">ðŸ“ GPS Location</span>
            <span class="sensor-toggle-status" id="status-gps">â€”</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="switch-gps" checked>
            <span class="toggle-slider"></span>
          </label>
          <div class="sensor-toggle-note" id="note-gps"></div>
          <div class="manual-location" id="manual-location-wrap">
            <div class="manual-location-label">Manual Location (fallback):</div>
            <div class="manual-location-inputs">
              <input type="text" id="manual-lat" placeholder="Latitude" class="manual-input">
              <input type="text" id="manual-lng" placeholder="Longitude" class="manual-input">
              <button class="manual-set-btn" id="btn-set-manual-location">Set</button>
            </div>
            <button class="manual-current-btn" id="btn-use-ip-location">ðŸ“¡ Use IP-based Location</button>
          </div>
        </div>
        
        <div class="sensor-toggle-item" id="toggle-motion">
          <div class="sensor-toggle-info">
            <span class="sensor-toggle-name">ðŸ“ Motion/Orientation</span>
            <span class="sensor-toggle-status" id="status-motion">â€”</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="switch-motion" checked>
            <span class="toggle-slider"></span>
          </label>
          <div class="sensor-toggle-note" id="note-motion"></div>
        </div>
        
        <div class="sensor-toggle-item" id="toggle-env">
          <div class="sensor-toggle-info">
            <span class="sensor-toggle-name">ðŸ’¡ Environment (Light)</span>
            <span class="sensor-toggle-status" id="status-env">â€”</span>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="switch-env" checked>
            <span class="toggle-slider"></span>
          </label>
          <div class="sensor-toggle-note" id="note-env">Derived from video</div>
        </div>
      </div>
      
      <div class="panel-section-title" style="margin-top:12px">Permission Status</div>
      <div class="permission-summary" id="permission-summary">
        <div class="perm-item"><span>Camera</span><span id="perm-camera" class="perm-status">â€”</span></div>
        <div class="perm-item"><span>Microphone</span><span id="perm-mic" class="perm-status">â€”</span></div>
        <div class="perm-item"><span>Location</span><span id="perm-location" class="perm-status">â€”</span></div>
        <div class="perm-item"><span>Motion</span><span id="perm-motion" class="perm-status">â€”</span></div>
      </div>
      
      <button class="settings-reset-btn" id="btn-retry-permissions">ðŸ”„ Retry Denied Permissions</button>
    </div>
  </div>
  
  <!-- Theory Details Panel -->
  <div class="panel-backdrop" id="theory-backdrop"></div>
  <div class="panel theory-panel" id="theory-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“ Theoretical Analysis</span>
      <button class="panel-close" id="theory-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="panel-section active">
        <div class="panel-section-title">11-Theory Framework</div>
        <div class="theory-detail-grid">
          <div class="theory-detail-card" id="td-info">
            <div class="theory-detail-title"><span class="theory-icon">ðŸ“Š</span> Information Theory</div>
            <div class="theory-detail-value" id="td-info-val">â€”</div>
            <div class="theory-detail-sub" id="td-info-sub">Shannon entropy</div>
            <div class="theory-formula">H = -Î£ p log p</div>
          </div>
          <div class="theory-detail-card" id="td-topo">
            <div class="theory-detail-title"><span class="theory-icon">ðŸ”®</span> Topology</div>
            <div class="theory-detail-value" id="td-topo-val">â€”</div>
            <div class="theory-detail-sub" id="td-topo-sub">Continuity measure</div>
            <div class="theory-formula">Ï„ = lim Îµâ†’0</div>
          </div>
          <div class="theory-detail-card" id="td-causal">
            <div class="theory-detail-title"><span class="theory-icon">âš¡</span> Causal Structure</div>
            <div class="theory-detail-value" id="td-causal-val">â€”</div>
            <div class="theory-detail-sub" id="td-causal-sub">Pearl do-calculus</div>
            <div class="theory-formula">P(Y|do(X))</div>
          </div>
          <div class="theory-detail-card" id="td-graph">
            <div class="theory-detail-title"><span class="theory-icon">ðŸ”—</span> Graph Theory</div>
            <div class="theory-detail-value" id="td-graph-val">â€”</div>
            <div class="theory-detail-sub" id="td-graph-sub">Network analysis</div>
            <div class="theory-formula">PageRank</div>
          </div>
          <div class="theory-detail-card" id="td-dyn">
            <div class="theory-detail-title"><span class="theory-icon">ðŸŒ€</span> Dynamical Systems</div>
            <div class="theory-detail-value" id="td-dyn-val">â€”</div>
            <div class="theory-detail-sub" id="td-dyn-sub">Lyapunov stability</div>
            <div class="theory-formula">Î» = lim 1/t ln|Î´|</div>
          </div>
          <div class="theory-detail-card" id="td-measure">
            <div class="theory-detail-title"><span class="theory-icon">ðŸŽ¯</span> Measure Theory</div>
            <div class="theory-detail-value" id="td-measure-val">â€”</div>
            <div class="theory-detail-sub" id="td-measure-sub">Uncertainty fusion</div>
            <div class="theory-formula">P(H|E) âˆ P(E|H)P(H)</div>
          </div>
          <div class="theory-detail-card" id="td-group">
            <div class="theory-detail-title"><span class="theory-icon">â­•</span> Group Theory</div>
            <div class="theory-detail-value" id="td-group-val">â€”</div>
            <div class="theory-detail-sub" id="td-group-sub">Symmetries</div>
            <div class="theory-formula">f(gÂ·x) = f(x)</div>
          </div>
          <div class="theory-detail-card" id="td-diffgeo">
            <div class="theory-detail-title"><span class="theory-icon">ðŸ“</span> Diff. Geometry</div>
            <div class="theory-detail-value" id="td-diffgeo-val">â€”</div>
            <div class="theory-detail-sub" id="td-diffgeo-sub">Curvature</div>
            <div class="theory-formula">Îº = âˆ‡Â²f</div>
          </div>
          <div class="theory-detail-card" id="td-spectral">
            <div class="theory-detail-title"><span class="theory-icon">ã€°ï¸</span> Spectral Analysis</div>
            <div class="theory-detail-value" id="td-spectral-val">â€”</div>
            <div class="theory-detail-sub" id="td-spectral-sub">Frequency domain</div>
            <div class="theory-formula">F(Ï‰) = âˆ«f(t)e^(-iÏ‰t)</div>
          </div>
          <div class="theory-detail-card" id="td-thermo">
            <div class="theory-detail-title"><span class="theory-icon">ðŸŒ¡ï¸</span> Stat. Mechanics</div>
            <div class="theory-detail-value" id="td-thermo-val">â€”</div>
            <div class="theory-detail-sub" id="td-thermo-sub">Thermodynamics</div>
            <div class="theory-formula">S = k ln W</div>
          </div>
          <div class="theory-detail-card" id="td-category">
            <div class="theory-detail-title"><span class="theory-icon">âŸ³</span> Category Theory</div>
            <div class="theory-detail-value" id="td-category-val">â€”</div>
            <div class="theory-detail-sub" id="td-category-sub">Structural</div>
            <div class="theory-formula">g âˆ˜ f</div>
          </div>
        </div>
        <div class="panel-section-title">Thermodynamic Phase</div>
        <div class="panel-row">
          <span class="panel-label">Phase State</span>
          <span class="theory-phase-badge" id="td-phase">â€”</span>
        </div>
        <div class="panel-row"><span class="panel-label">Temperature</span><span class="panel-value" id="td-temp">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Free Energy</span><span class="panel-value" id="td-free">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Order Parameter</span><span class="panel-value" id="td-order">â€”</span></div>
        
        <div class="panel-section-title">Composite Score</div>
        <div class="panel-row"><span class="panel-label">Î˜ (Theoretical Score)</span><span class="panel-value" style="font-size:16px;color:var(--accent-cyan)" id="td-score">â€”</span></div>
      </div>
    </div>
  </div>
  
  <div class="panel" id="panel">
    <div class="panel-header">
      <span class="panel-title">Reality Analysis</span>
      <button class="panel-close" id="panel-close">âœ•</button>
    </div>
    <div class="panel-tabs">
      <button class="panel-tab active" data-tab="overview">Overview</button>
      <button class="panel-tab" data-tab="sensors">Sensors</button>
      <button class="panel-tab" data-tab="causal">Causal</button>
      <button class="panel-tab" data-tab="query">Query</button>
      <button class="panel-tab" data-tab="history">History</button>
    </div>
    <div class="panel-content">
      <div class="panel-section active" id="tab-overview">
        <div class="panel-section-title">Capture</div>
        <div class="panel-row"><span class="panel-label">Mode</span><span class="panel-value" id="p-mode">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Frames</span><span class="panel-value" id="p-frames">0</span></div>
        <div class="panel-row"><span class="panel-label">Symbols</span><span class="panel-value" id="p-symbols">0</span></div>
        <div class="panel-row"><span class="panel-label">Relations</span><span class="panel-value" id="p-relations">0</span></div>
        <div class="panel-row"><span class="panel-label">Size</span><span class="panel-value" id="p-size">0 KB</span></div>
        <div class="panel-section-title">Theoretical Analysis</div>
        <div class="panel-row"><span class="panel-label">Theory Score (Î˜)</span><span class="panel-value" id="p-theory-score" style="color:var(--accent-cyan)">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Frames Analyzed</span><span class="panel-value" id="p-theory-frames">0</span></div>
        <div class="panel-row"><span class="panel-label">Avg Entropy (H)</span><span class="panel-value" id="p-theory-entropy">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Phase State</span><span class="panel-value" id="p-theory-phase">â€”</span></div>
        <div class="panel-section-title">v2.26 Architecture</div>
        <div class="panel-row"><span class="panel-label">Scenes</span><span class="panel-value" id="p-scenes">0</span></div>
        <div class="panel-row"><span class="panel-label">Moments</span><span class="panel-value" id="p-moments">0</span></div>
        <div class="panel-row"><span class="panel-label">Compression</span><span class="panel-value" id="p-compress">1.0x</span></div>
        <div class="panel-row"><span class="panel-label">Events</span><span class="panel-value" id="p-events">0</span></div>
        <div class="panel-section-title">Performance</div>
        <div class="panel-row"><span class="panel-label">FPS</span><span class="panel-value" id="p-fps">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Sync Quality</span><span class="panel-value" id="p-syncqual">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Uncertainty</span><span class="panel-value" id="p-uncertainty">â€”</span></div>
        <div class="panel-row"><span class="panel-label">Memory</span><span class="panel-value" id="p-memory">â€”</span></div>
      </div>
      <div class="panel-section" id="tab-sensors">
        <div class="panel-section-title">Sensor Profiles</div>
        <div class="sensor-profile-selector" id="profile-selector">
          <button class="sensor-profile-btn active" data-profile="full" onclick="applySensorProfile('full')">
            <span class="profile-icon">ðŸ”‹</span>Full
          </button>
          <button class="sensor-profile-btn" data-profile="lite" onclick="applySensorProfile('lite')">
            <span class="profile-icon">ðŸª¶</span>Lite
          </button>
          <button class="sensor-profile-btn" data-profile="indoor" onclick="applySensorProfile('indoor')">
            <span class="profile-icon">ðŸ </span>Indoor
          </button>
          <button class="sensor-profile-btn" data-profile="outdoor" onclick="applySensorProfile('outdoor')">
            <span class="profile-icon">ðŸŒ³</span>Outdoor
          </button>
        </div>
        
        <div class="sensor-control-panel">
          <div class="sensor-control-header">
            <span class="sensor-control-title">âš¡ Quick Actions</span>
            <div class="sensor-control-actions">
              <button onclick="sensorController.optimizeForBattery()">ðŸ”‹ Battery</button>
              <button onclick="sensorController.optimizeForQuality()">âœ¨ Quality</button>
              <button onclick="resetAllSensors()">ðŸ”„ Reset All</button>
            </div>
          </div>
          <div class="policy-status" id="policy-status"></div>
        </div>
        
        <div class="panel-section-title">Live Monitor</div>
        <div id="sensor-details"></div>
      </div>
      <div class="panel-section" id="tab-causal">
        <div class="panel-section-title">Causal Inference</div>
        <div class="panel-row"><span class="panel-label">Total Inferences</span><span class="panel-value" id="p-inferences">0</span></div>
        <div class="panel-row"><span class="panel-label">Patterns</span><span class="panel-value" id="p-patterns">0</span></div>
        <div id="causal-list"></div>
      </div>
      <div class="panel-section" id="tab-query">
        <div class="panel-section-title">Query Reality</div>
        <div class="query-wrap">
          <input type="text" class="query-input" id="query-input" placeholder="overview, wh, causal, frame N...">
          <button class="query-btn" id="query-btn">Ask</button>
        </div>
        <div class="query-result" id="query-result">Type 'help' for all commands. Quick: overview, wh, theory, causal, stats, entropy, phase</div>
      </div>
      <div class="panel-section" id="tab-history">
        <div class="panel-section-title">Recording History</div>
        <div class="panel-row"><span class="panel-label">Saved Recordings</span><span class="panel-value" id="p-recording-count">0</span></div>
        <div class="panel-row"><span class="panel-label">Total Storage</span><span class="panel-value" id="p-storage-size">0 KB</span></div>
        <div id="history-list" style="margin-top:12px;max-height:280px;overflow-y:auto"></div>
        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="query-btn" id="btn-clear-history" style="flex:1;background:var(--error);font-size:10px">Clear All</button>
          <button class="query-btn" id="btn-import" style="flex:1;font-size:10px">Import</button>
        </div>
        <input type="file" id="import-input" accept=".vrc,.json" style="display:none">
      </div>
      <div style="display:flex;gap:8px;margin-top:12px">
        <button class="download-btn" id="btn-download" style="flex:1">ðŸ“¥ Export .vrc</button>
        <button class="download-btn" id="btn-download-json" style="flex:1;background:var(--accent-purple)">ðŸ“„ Export .json</button>
      </div>
      <button class="download-btn" id="btn-save" style="margin-top:8px;background:var(--accent-green)">ðŸ’¾ Save to History</button>
    </div>
  </div>
  
  <!-- Timeline Bar -->
  <div class="timeline-bar" id="timeline-bar">
    <div class="timeline-track" id="timeline-track">
      <div class="timeline-progress" id="timeline-progress"></div>
      <div class="timeline-markers" id="timeline-markers"></div>
    </div>
    <div class="timeline-info">
      <span id="timeline-time">0:00</span>
      <span id="timeline-frames">0 frames</span>
    </div>
  </div>
  
  <!-- Playback Panel -->
  <div class="playback-backdrop" id="playback-backdrop"></div>
  <div class="playback-panel" id="playback-panel">
    <div class="panel-header">
      <span class="panel-title">Frame Viewer</span>
      <button class="panel-close" id="playback-close">âœ•</button>
    </div>
    <div class="playback-content">
      <div class="playback-canvas-wrap">
        <canvas id="playback-canvas" width="240" height="180"></canvas>
        <div class="playback-overlay" id="playback-overlay"></div>
      </div>
      <div class="playback-controls">
        <button class="playback-btn" id="pb-prev" title="Previous Frame">â®</button>
        <button class="playback-btn" id="pb-play" title="Play/Pause">â–¶</button>
        <button class="playback-btn" id="pb-next" title="Next Frame">â­</button>
        <button class="playback-btn" id="pb-stop" title="Stop">â¹</button>
        <select class="playback-speed" id="pb-speed">
          <option value="0.25">0.25x</option>
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </div>
      <div class="playback-timeline">
        <input type="range" id="pb-scrub" min="0" max="100" value="0" class="playback-scrub">
        <div class="playback-time-info">
          <span id="pb-current-frame">F0</span>
          <span id="pb-time">0:00</span>
          <span id="pb-total-frames">/ 0</span>
        </div>
      </div>
      <div class="playback-info" id="pb-info">
        Select a recording from History to view frames.
      </div>
    </div>
  </div>
  
  <!-- Compare Panel -->
  <div class="compare-backdrop" id="compare-backdrop"></div>
  <div class="compare-panel" id="compare-panel">
    <div class="panel-header">
      <span class="panel-title">Compare Frames</span>
      <button class="panel-close" id="compare-close">âœ•</button>
    </div>
    <div class="compare-content">
      <div class="compare-frames">
        <div class="compare-frame">
          <div class="compare-label">Frame A</div>
          <canvas id="compare-canvas-a" width="120" height="90"></canvas>
          <input type="number" id="compare-input-a" min="0" value="0" class="compare-input">
        </div>
        <div class="compare-frame">
          <div class="compare-label">Frame B</div>
          <canvas id="compare-canvas-b" width="120" height="90"></canvas>
          <input type="number" id="compare-input-b" min="0" value="1" class="compare-input">
        </div>
      </div>
      <button class="query-btn" id="compare-btn" style="width:100%;margin-top:10px">Compare</button>
      <div class="compare-result" id="compare-result"></div>
    </div>
  </div>
  
  <!-- Analytics Panel -->
  <div class="analytics-backdrop" id="analytics-backdrop"></div>
  <div class="analytics-panel" id="analytics-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“Š Analytics Dashboard</span>
      <button class="panel-close" id="analytics-close">âœ•</button>
    </div>
    <div class="analytics-content">
      <!-- Metrics Graph -->
      <div class="analytics-section">
        <div class="analytics-section-title">Metrics Over Time</div>
        <div class="metrics-graph-wrap">
          <canvas id="metrics-canvas" width="340" height="120"></canvas>
          <div class="metrics-legend">
            <div class="metrics-legend-item active" data-metric="entropy">
              <span class="metrics-legend-dot" style="background:#22ddee"></span>
              <span>Entropy</span>
            </div>
            <div class="metrics-legend-item active" data-metric="motion">
              <span class="metrics-legend-dot" style="background:#ff8844"></span>
              <span>Motion</span>
            </div>
            <div class="metrics-legend-item" data-metric="score">
              <span class="metrics-legend-dot" style="background:#8855ff"></span>
              <span>Score</span>
            </div>
            <div class="metrics-legend-item" data-metric="luminance">
              <span class="metrics-legend-dot" style="background:#ffc744"></span>
              <span>Luminance</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Scene Timeline -->
      <div class="analytics-section">
        <div class="analytics-section-title">Scene Segments</div>
        <div class="scene-timeline-wrap">
          <div id="scene-timeline"></div>
          <div class="scene-legend">
            <div class="scene-legend-item"><span class="scene-legend-color" style="background:#ffdd88"></span>Bright</div>
            <div class="scene-legend-item"><span class="scene-legend-color" style="background:#334455"></span>Dark</div>
            <div class="scene-legend-item"><span class="scene-legend-color" style="background:#88ccff"></span>Detailed</div>
            <div class="scene-legend-item"><span class="scene-legend-color" style="background:#5588aa"></span>Normal</div>
          </div>
        </div>
      </div>
      
      <!-- Filmstrip -->
      <div class="analytics-section">
        <div class="analytics-section-title">Frame Preview</div>
        <div class="filmstrip-wrap">
          <div id="filmstrip-container"></div>
        </div>
      </div>
      
      <!-- Annotations -->
      <div class="analytics-section">
        <div class="analytics-section-title">Annotations (<span id="annotation-count">0</span>)</div>
        <div class="annotation-wrap">
          <div class="annotation-input-row">
            <input type="number" id="annotation-frame" class="annotation-frame-input" placeholder="F#" min="0">
            <input type="text" id="annotation-text" class="annotation-text-input" placeholder="Add note...">
            <button class="annotation-add-btn" id="annotation-add">+</button>
          </div>
          <div class="annotation-list" id="annotation-list"></div>
        </div>
      </div>
      
      <!-- Search Results Section -->
      <div class="analytics-section">
        <div class="analytics-section-title">Search Results</div>
        <div class="search-results-wrap">
          <div id="search-results"></div>
        </div>
      </div>
      
      <!-- Quick Tags Section -->
      <div class="analytics-section">
        <div class="analytics-section-title">Quick Tags for Current Frame</div>
        <div class="quick-tags-wrap" id="quick-tags"></div>
      </div>
      
      <!-- Heatmap Controls -->
      <div class="analytics-section">
        <div class="analytics-section-title">Heatmap Overlay</div>
        <div class="heatmap-controls">
          <button class="heatmap-btn active" data-mode="none">Off</button>
          <button class="heatmap-btn" data-mode="entropy">Entropy</button>
          <button class="heatmap-btn" data-mode="motion">Motion</button>
          <button class="heatmap-btn" data-mode="attention">Attention</button>
          <button class="heatmap-btn" data-mode="luminance">Luminance</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Clip Export Panel -->
  <div class="clip-panel-backdrop" id="clip-backdrop"></div>
  <div class="clip-panel" id="clip-panel">
    <div class="panel-header">
      <span class="panel-title">âœ‚ï¸ Export Clip</span>
      <button class="panel-close" id="clip-close">âœ•</button>
    </div>
    <div class="clip-panel-content">
      <div class="clip-range-row">
        <input type="number" id="clip-start" class="clip-range-input" placeholder="Start" min="0" value="0">
        <span style="color:var(--text-muted)">â†’</span>
        <input type="number" id="clip-end" class="clip-range-input" placeholder="End" min="0" value="0">
      </div>
      <div class="clip-preview" id="clip-preview">
        <div class="clip-preview-row">
          <span>Frames:</span><span id="clip-frame-count">0</span>
        </div>
        <div class="clip-preview-row">
          <span>Duration:</span><span id="clip-duration">0:00</span>
        </div>
        <div class="clip-preview-row">
          <span>Avg Entropy:</span><span id="clip-entropy">â€”</span>
        </div>
        <div class="clip-preview-row">
          <span>Avg Motion:</span><span id="clip-motion">â€”</span>
        </div>
      </div>
      <div class="clip-export-btns">
        <button class="clip-export-btn json" id="clip-export-json">ðŸ“„ Export JSON</button>
        <button class="clip-export-btn image" id="clip-export-image">ðŸ–¼ Export Image</button>
      </div>
    </div>
  </div>
  
  <!-- Report Panel -->
  <div class="report-backdrop" id="report-backdrop"></div>
  <div class="report-panel" id="report-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“‹ Generate Report</span>
      <button class="panel-close" id="report-close">âœ•</button>
    </div>
    <div class="report-content">
      <div class="analytics-section-title">Include Sections</div>
      <div class="report-section-toggle" id="report-sections">
        <button class="report-section-btn active" data-section="overview">Overview</button>
        <button class="report-section-btn active" data-section="stats">Statistics</button>
        <button class="report-section-btn active" data-section="scenes">Scenes</button>
        <button class="report-section-btn active" data-section="causal">Causal</button>
        <button class="report-section-btn active" data-section="theory">Theory</button>
        <button class="report-section-btn active" data-section="annotations">Notes</button>
        <button class="report-section-btn active" data-section="timeline">Tags</button>
      </div>
      <div class="analytics-section-title">Export Format</div>
      <div class="report-format-row">
        <button class="report-format-btn html" id="report-html">ðŸŒ HTML</button>
        <button class="report-format-btn md" id="report-md">ðŸ“ Markdown</button>
        <button class="report-format-btn json" id="report-json">ðŸ“Š JSON</button>
      </div>
    </div>
  </div>
  
  <!-- Symbol Mesh Network Panel -->
  <div class="panel-backdrop" id="mesh-backdrop"></div>
  <div class="panel mesh-panel" id="mesh-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ•¸ï¸ Symbol Mesh Network</span>
      <button class="panel-close" id="mesh-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="mesh-container" id="mesh-container"></div>
      <div class="node-detail" id="mesh-node-detail">
        <div style="text-align:center;color:var(--text-muted);font-size:10px;">Click a node to see details</div>
      </div>
    </div>
  </div>
  
  <!-- Causal Chain Panel -->
  <div class="panel-backdrop" id="chain-backdrop"></div>
  <div class="panel" id="chain-panel" style="max-width:380px;">
    <div class="panel-header">
      <span class="panel-title">â›“ï¸ Causal Chains</span>
      <button class="panel-close" id="chain-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="chain-container" id="chain-container"></div>
      <div class="chain-detail" id="chain-detail">
        <div style="text-align:center;color:var(--text-muted);font-size:10px;">Click a chain to see details</div>
      </div>
    </div>
  </div>
  
  <!-- Mfidel Encoding Panel -->
  <div class="panel-backdrop" id="mfidel-backdrop"></div>
  <div class="panel" id="mfidel-panel" style="max-width:380px;">
    <div class="panel-header">
      <span class="panel-title">áŠá‹°áˆ Mfidel Encoding</span>
      <button class="panel-close" id="mfidel-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="mfidel-container">
        <div class="analytics-section-title">Recording Signature</div>
        <div class="mfidel-signature" id="mfidel-signature">â€”</div>
        
        <div class="analytics-section-title">Full Encoding</div>
        <div class="mfidel-encoding" id="mfidel-encoding">â€”</div>
        
        <div class="mfidel-legend">
          áˆ€=entropy áˆˆ=motion áˆ=scene áˆ˜=causal á¢=boundary
        </div>
        
        <div class="analytics-section-title" style="margin-top:12px;">Symbol Statistics</div>
        <div class="mfidel-stats" id="mfidel-stats"></div>
      </div>
    </div>
  </div>
  
  <!-- Narrative Panel -->
  <div class="panel-backdrop" id="narrative-backdrop"></div>
  <div class="panel" id="narrative-panel" style="max-width:400px;">
    <div class="panel-header">
      <span class="panel-title">ðŸ“– Narrative</span>
      <button class="panel-close" id="narrative-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="narrative-container">
        <div class="narrative-text" id="narrative-text">Record some content to generate a narrative.</div>
        <div class="narrative-moments" id="narrative-moments"></div>
      </div>
    </div>
  </div>
  
  <!-- InceptaDive Deep Explorer Panel -->
  <div class="panel-backdrop" id="dive-backdrop"></div>
  <div class="panel dive-panel" id="dive-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ” InceptaDive Explorer</span>
      <button class="panel-close" id="dive-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="dive-container" id="dive-container">
        <div class="dive-empty">Select a frame to begin WH exploration.</div>
      </div>
    </div>
  </div>
  
  <!-- Symbol Ontology Panel -->
  <div class="panel-backdrop" id="ontology-backdrop"></div>
  <div class="panel ontology-panel" id="ontology-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸŒ³ Symbol Ontology</span>
      <button class="panel-close" id="ontology-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="ontology-container" id="ontology-container"></div>
    </div>
  </div>
  
  <!-- Symbolic Query Language Panel -->
  <div class="panel-backdrop" id="sql-backdrop"></div>
  <div class="panel sql-panel" id="sql-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ”Ž Symbolic Query</span>
      <button class="panel-close" id="sql-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="sql-container">
        <div class="sql-input-wrap">
          <input type="text" class="sql-input" id="sql-input" placeholder="find frames where entropy high">
          <button class="sql-run-btn" id="sql-run">Run</button>
        </div>
        <div class="sql-examples">
          <span class="sql-example" onclick="setSqlExample('find frames where motion')">find motion</span>
          <span class="sql-example" onclick="setSqlExample('what caused blur')">what caused</span>
          <span class="sql-example" onclick="setSqlExample('how many frames')">count frames</span>
          <span class="sql-example" onclick="setSqlExample('compare frame 0 and 10')">compare</span>
          <span class="sql-example" onclick="setSqlExample('show bright frames')">show bright</span>
        </div>
        <div class="sql-result" id="sql-result">Enter a query to search your recording symbolically.</div>
      </div>
    </div>
  </div>
  
  <!-- Audio Waveform Panel -->
  <div class="panel-backdrop" id="audio-backdrop"></div>
  <div class="panel audio-panel" id="audio-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ”Š Audio Waveform</span>
      <button class="panel-close" id="audio-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="audio-container" id="audio-container">
        <div class="audio-empty">No audio data available.</div>
      </div>
    </div>
  </div>
  
  <!-- Motion Trajectory Panel -->
  <div class="panel-backdrop" id="motion-backdrop"></div>
  <div class="panel motion-panel" id="motion-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ’¨ Motion Trajectory</span>
      <button class="panel-close" id="motion-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="motion-container" id="motion-container">
        <div class="motion-empty">No motion data available.</div>
      </div>
    </div>
  </div>
  
  <!-- Mullu Export Panel -->
  <div class="panel-backdrop" id="mullu-backdrop"></div>
  <div class="panel mullu-panel" id="mullu-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“¦ Mullu Export</span>
      <button class="panel-close" id="mullu-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="mullu-container">
        <div class="mullu-header">
          <span class="mullu-logo">ðŸ”®</span>
          <div>
            <div class="mullu-title">MULLU Symbolic Format</div>
            <div class="mullu-version">v1.0 â€¢ Compatible with Mullu Inspect, MulluSI</div>
          </div>
        </div>
        
        <div class="analytics-section-title">Preview</div>
        <div class="mullu-preview" id="mullu-preview">
          { "mullu": { "version": "1.0", ... } }
        </div>
        
        <div class="analytics-section-title">Export Stats</div>
        <div class="mullu-stats" id="mullu-stats">
          <div class="mullu-stat"><span class="mullu-stat-label">Frames</span><span class="mullu-stat-value">â€”</span></div>
          <div class="mullu-stat"><span class="mullu-stat-label">Symbols</span><span class="mullu-stat-value">â€”</span></div>
          <div class="mullu-stat"><span class="mullu-stat-label">Chains</span><span class="mullu-stat-value">â€”</span></div>
          <div class="mullu-stat"><span class="mullu-stat-label">Size</span><span class="mullu-stat-value">â€”</span></div>
        </div>
        
        <div class="mullu-actions">
          <button class="mullu-btn mullu-btn-primary" id="mullu-download">â¬‡ï¸ Download .mullu</button>
          <button class="mullu-btn mullu-btn-secondary" id="mullu-copy">ðŸ“‹ Copy JSON</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Pattern Detector Panel -->
  <div class="panel-backdrop" id="pattern-backdrop"></div>
  <div class="panel pattern-panel" id="pattern-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸŽ¯ AI Pattern Detection</span>
      <button class="panel-close" id="pattern-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="pattern-container" id="pattern-container">
        <div class="pattern-empty">Analyzing patterns...</div>
      </div>
    </div>
  </div>
  
  <!-- Help Overlay Panel -->
  <div class="panel-backdrop" id="help-backdrop"></div>
  <div class="panel help-panel" id="help-panel">
    <div class="panel-header">
      <span class="panel-title">âŒ¨ï¸ Keyboard Shortcuts</span>
      <button class="panel-close" id="help-close">âœ•</button>
    </div>
    <div class="panel-content" id="help-content"></div>
  </div>
  
  <!-- V2.16 Data Management Panel -->
  <div class="panel-backdrop" id="data-backdrop"></div>
  <div class="panel data-panel" id="data-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ’¾ Data Manager</span>
      <button class="panel-close" id="data-close">âœ•</button>
    </div>
    <div class="panel-content" id="data-container"></div>
  </div>
  
  <!-- V2.17 Camera Controls Panel -->
  <div class="panel-backdrop" id="camera-backdrop"></div>
  <div class="panel camera-panel" id="camera-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“· Camera Settings</span>
      <button class="panel-close" id="camera-close">âœ•</button>
    </div>
    <div class="panel-content" id="camera-container"></div>
  </div>
  
  <!-- V2.18 Clip Editor Panel -->
  <div class="panel-backdrop" id="clip-editor-backdrop"></div>
  <div class="panel clip-editor-panel" id="clip-editor-panel">
    <div class="panel-header">
      <span class="panel-title">âœ‚ï¸ Clip Editor</span>
      <button class="panel-close" id="clip-editor-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="clip-timeline-container" id="clip-timeline-container">
        <div class="clip-timeline-track" id="clip-timeline-track"></div>
        <div class="clip-timeline-selection" id="clip-timeline-selection"></div>
        <div class="clip-timeline-playhead" id="clip-timeline-playhead" style="left: 0;"></div>
      </div>
      
      <div class="clip-controls">
        <button class="clip-control-btn" onclick="clipEditor.setSelection(0, Math.floor((orch?.getContainer()?.frames?.length || 0) / 2))">Select First Half</button>
        <button class="clip-control-btn" onclick="clipEditor.clearSelection()">Clear Selection</button>
        <button class="clip-control-btn primary" onclick="clipEditor.createFromSelection()">Create Clip</button>
      </div>
      
      <div class="clip-controls">
        <button class="clip-control-btn" onclick="clipEditor.autoDetectClips()">ðŸ” Auto-Detect Scenes</button>
        <button class="clip-control-btn" onclick="openExportPanel()">ðŸ“¦ Export</button>
      </div>
      
      <h4 style="margin: 16px 0 8px; font-size: 12px; color: var(--text-secondary);">Clips</h4>
      <div class="clip-list" id="clip-list"></div>
    </div>
  </div>
  
  <!-- V2.18 Export Panel -->
  <div class="panel-backdrop" id="export-panel-backdrop"></div>
  <div class="panel export-panel" id="export-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“¦ Export Recording</span>
      <button class="panel-close" id="export-panel-close">âœ•</button>
    </div>
    <div class="panel-content">
      <h4 style="margin: 0 0 12px; font-size: 12px; color: var(--text-secondary);">Select Format</h4>
      
      <div class="export-formats" id="export-formats">
        <button class="export-format-btn selected" data-format="mullu" onclick="selectExportFormat('mullu')">
          <span class="export-format-icon">ðŸ“¦</span>
          <span class="export-format-label">Mullu Package</span>
          <span class="export-format-ext">.mullu</span>
        </button>
        <button class="export-format-btn" data-format="json" onclick="selectExportFormat('json')">
          <span class="export-format-icon">ðŸ“„</span>
          <span class="export-format-label">JSON Data</span>
          <span class="export-format-ext">.json</span>
        </button>
        <button class="export-format-btn" data-format="csv" onclick="selectExportFormat('csv')">
          <span class="export-format-icon">ðŸ“Š</span>
          <span class="export-format-label">CSV Metadata</span>
          <span class="export-format-ext">.csv</span>
        </button>
        <button class="export-format-btn" data-format="report" onclick="selectExportFormat('report')">
          <span class="export-format-icon">ðŸ“</span>
          <span class="export-format-label">Analysis Report</span>
          <span class="export-format-ext">.md</span>
        </button>
      </div>
      
      <div class="export-progress" style="display: none;" id="export-progress">
        <div class="export-progress-bar-container">
          <div class="export-progress-bar" id="export-progress-bar"></div>
        </div>
        <div class="export-progress-text" id="export-progress-text">0%</div>
      </div>
      
      <div class="export-actions">
        <button class="export-action-btn secondary" onclick="closeExportPanel()">Cancel</button>
        <button class="export-action-btn primary" onclick="doExport()">Export</button>
      </div>
    </div>
  </div>
  
  <!-- V2.19 Annotation Timeline Panel -->
  <div class="panel-backdrop" id="annotation-backdrop"></div>
  <div class="panel annotation-panel" id="annotation-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“ Annotation Timeline</span>
      <button class="panel-close" id="annotation-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="timeline-container" id="annotation-timeline-container"></div>
      
      <div class="timeline-controls">
        <button class="timeline-zoom-btn" onclick="zoomTimeline(-0.5)">âˆ’</button>
        <button class="timeline-zoom-btn" onclick="zoomTimeline(0.5)">+</button>
        <button class="timeline-zoom-btn" onclick="resetTimelineZoom()">Reset</button>
        <span style="flex:1"></span>
        <button class="timeline-zoom-btn" onclick="importScenesAsRegions()">Import Scenes</button>
        <button class="timeline-zoom-btn" onclick="exportAnnotations()">Export</button>
      </div>
      
      <div id="marker-editor-container"></div>
    </div>
  </div>
  
  <!-- V2.19 Notes Panel -->
  <div class="panel-backdrop" id="notes-backdrop"></div>
  <div class="panel notes-panel" id="notes-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“ Frame Notes</span>
      <button class="panel-close" id="notes-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="notes-frame-indicator">
        Frame: <span id="notes-current-frame">0</span>
      </div>
      
      <textarea class="notes-textarea" id="notes-textarea" placeholder="Add a note for this frame..."></textarea>
      
      <div class="notes-actions">
        <button class="notes-action-btn clear" onclick="clearCurrentNote()">Clear</button>
        <button class="notes-action-btn save" onclick="saveCurrentNote()">Save Note</button>
      </div>
      
      <div class="notes-list">
        <div class="notes-list-header">All Notes</div>
        <div id="notes-list-container"></div>
      </div>
    </div>
  </div>
  
  <!-- V2.20 Keyboard Cheatsheet Panel -->
  <div class="panel-backdrop" id="cheatsheet-backdrop"></div>
  <div class="panel cheatsheet-panel" id="cheatsheet-panel">
    <div class="panel-header">
      <span class="panel-title">âŒ¨ï¸ Keyboard Shortcuts</span>
      <button class="panel-close" id="cheatsheet-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="cheatsheet-content" id="cheatsheet-content"></div>
    </div>
  </div>
  
  <!-- V2.20 History Panel -->
  <div class="panel-backdrop" id="history-backdrop"></div>
  <div class="panel history-panel" id="history-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“œ Edit History</span>
      <button class="panel-close" id="history-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="history-header-controls">
        <button class="history-clear-btn" onclick="clearHistory()">Clear History</button>
      </div>
      <div class="history-list" id="history-list"></div>
    </div>
  </div>
  
  <!-- V2.21 Project Browser Panel -->
  <div class="panel-backdrop" id="project-backdrop"></div>
  <div class="panel project-panel" id="project-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ“ Project Browser</span>
      <button class="panel-close" id="project-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="project-browser-container"></div>
    </div>
  </div>
  
  <!-- V2.21 New Project Dialog -->
  <div class="panel-backdrop" id="new-project-backdrop"></div>
  <div class="panel" id="new-project-panel" style="max-width: 400px;">
    <div class="panel-header">
      <span class="panel-title">âœ¨ New Project</span>
      <button class="panel-close" id="new-project-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="new-project-form">
        <div class="new-project-field">
          <label>Project Name</label>
          <input type="text" id="new-project-name" placeholder="My VIRECAI Project">
        </div>
        <div class="new-project-field">
          <label>Description (optional)</label>
          <textarea id="new-project-desc" placeholder="What is this project about?"></textarea>
        </div>
        <div class="new-project-field">
          <label>Start from Template</label>
          <select id="new-project-template" style="padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary);">
            <option value="">â€” None â€”</option>
          </select>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 8px;">
          <button onclick="closeNewProjectDialog()" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); cursor: pointer;">Cancel</button>
          <button onclick="confirmNewProject()" style="flex: 1; padding: 12px; border: none; border-radius: 8px; background: var(--accent-cyan); color: #000; font-weight: 600; cursor: pointer;">Create Project</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- V2.21 Save Template Dialog -->
  <div class="panel-backdrop" id="save-template-backdrop"></div>
  <div class="panel" id="save-template-panel" style="max-width: 400px;">
    <div class="panel-header">
      <span class="panel-title">ðŸ“‹ Save as Template</span>
      <button class="panel-close" id="save-template-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="new-project-form">
        <div class="new-project-field">
          <label>Template Name</label>
          <input type="text" id="new-template-name" placeholder="My Template">
        </div>
        <div class="new-project-field">
          <label>Description</label>
          <textarea id="new-template-desc" placeholder="What is this template for?"></textarea>
        </div>
        <div class="new-project-field">
          <label>Icon</label>
          <input type="text" id="new-template-icon" placeholder="ðŸ“" maxlength="2" style="width: 60px;">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 8px;">
          <button onclick="closeSaveTemplateDialog()" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); cursor: pointer;">Cancel</button>
          <button onclick="confirmSaveTemplate()" style="flex: 1; padding: 12px; border: none; border-radius: 8px; background: var(--accent-cyan); color: #000; font-weight: 600; cursor: pointer;">Save Template</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- V2.21 File inputs for project/template import -->
  <input type="file" id="project-import-input" accept=".virecai,.json" style="display:none;">
  <input type="file" id="template-import-input" accept=".virecai-template,.json" style="display:none;">
  
  <!-- V2.22 Share & Collaboration Panel -->
  <div class="panel-backdrop" id="share-backdrop"></div>
  <div class="panel share-panel" id="share-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ”— Share & Collaborate</span>
      <button class="panel-close" id="share-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="share-container"></div>
    </div>
  </div>
  
  <!-- V2.22 Create Share Link Dialog -->
  <div class="panel-backdrop" id="create-share-backdrop"></div>
  <div class="panel" id="create-share-panel" style="max-width: 400px;">
    <div class="panel-header">
      <span class="panel-title">ðŸ”— Create Share Link</span>
      <button class="panel-close" id="create-share-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="create-share-form">
        <div class="share-option">
          <div>
            <div class="share-option-label">Allow Download</div>
            <div class="share-option-desc">Recipients can download the project</div>
          </div>
          <label class="share-toggle">
            <input type="checkbox" id="share-allow-download" checked>
            <span class="share-toggle-slider"></span>
          </label>
        </div>
        <div class="share-option">
          <div>
            <div class="share-option-label">Allow Comments</div>
            <div class="share-option-desc">Recipients can add comments</div>
          </div>
          <label class="share-toggle">
            <input type="checkbox" id="share-allow-comments" checked>
            <span class="share-toggle-slider"></span>
          </label>
        </div>
        <div class="share-option">
          <div>
            <div class="share-option-label">Password Protection</div>
            <div class="share-option-desc">Require password to access</div>
          </div>
          <label class="share-toggle">
            <input type="checkbox" id="share-use-password">
            <span class="share-toggle-slider"></span>
          </label>
        </div>
        <div id="share-password-field" style="display: none;">
          <input type="password" id="share-password" placeholder="Enter password" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary);">
        </div>
        <div class="add-collab-field">
          <label>Expires In</label>
          <select id="share-expires" style="padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary);">
            <option value="86400000">1 day</option>
            <option value="604800000" selected>7 days</option>
            <option value="2592000000">30 days</option>
            <option value="">Never</option>
          </select>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 8px;">
          <button onclick="closeCreateShareDialog()" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); cursor: pointer;">Cancel</button>
          <button onclick="confirmCreateShare()" style="flex: 1; padding: 12px; border: none; border-radius: 8px; background: var(--accent-cyan); color: #000; font-weight: 600; cursor: pointer;">Create Link</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- V2.22 Add Collaborator Dialog -->
  <div class="panel-backdrop" id="add-collab-backdrop"></div>
  <div class="panel" id="add-collab-panel" style="max-width: 400px;">
    <div class="panel-header">
      <span class="panel-title">ðŸ‘¥ Add Collaborator</span>
      <button class="panel-close" id="add-collab-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="add-collab-form">
        <div class="add-collab-field">
          <label>Name</label>
          <input type="text" id="collab-name" placeholder="Collaborator name">
        </div>
        <div class="add-collab-field">
          <label>Email (optional)</label>
          <input type="email" id="collab-email" placeholder="email@example.com">
        </div>
        <div class="add-collab-field">
          <label>Permission Level</label>
          <select id="collab-permission">
            <option value="view">ðŸ‘ï¸ View only</option>
            <option value="comment">ðŸ’¬ Can comment</option>
            <option value="edit">âœï¸ Can edit</option>
            <option value="admin">ðŸ‘‘ Admin</option>
          </select>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 8px;">
          <button onclick="closeAddCollaboratorDialog()" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); cursor: pointer;">Cancel</button>
          <button onclick="confirmAddCollaborator()" style="flex: 1; padding: 12px; border: none; border-radius: 8px; background: var(--accent-cyan); color: #000; font-weight: 600; cursor: pointer;">Add</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- V2.22 Comments Panel -->
  <div class="panel-backdrop" id="comments-backdrop"></div>
  <div class="panel" id="comments-panel" style="max-width: 450px; max-height: 80vh;">
    <div class="panel-header">
      <span class="panel-title">ðŸ’¬ Comments</span>
      <button class="panel-close" id="comments-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div style="margin-bottom: 12px;">
        <input type="text" id="comment-author-input" placeholder="Your name" style="width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary); font-size: 11px; margin-bottom: 8px;">
        <textarea id="comment-text-input" placeholder="Add a comment at the current frame..." style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary); font-size: 12px; resize: vertical; min-height: 60px;"></textarea>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
          <span style="font-size: 10px; color: var(--text-muted);">Frame: <span id="comment-frame-display">0</span></span>
          <button onclick="submitComment()" style="padding: 8px 16px; border: none; border-radius: 6px; background: var(--accent-cyan); color: #000; font-size: 11px; font-weight: 600; cursor: pointer;">Post Comment</button>
        </div>
      </div>
      <div class="comments-list" id="comments-list" style="max-height: 350px; overflow-y: auto;">
        Loading comments...
      </div>
    </div>
  </div>
  
  <!-- V2.23 Global Search Panel -->
  <div class="panel-backdrop" id="search-backdrop"></div>
  <div class="panel search-panel" id="search-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ” Global Search</span>
      <button class="panel-close" id="search-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="search-container"></div>
    </div>
  </div>
  
  <!-- V2.25 Info Panel -->
  <div class="panel-backdrop" id="info-backdrop"></div>
  <div class="panel info-panel" id="info-panel">
    <div class="panel-header">
      <span class="panel-title">â„¹ï¸ System Information</span>
      <button class="panel-close" id="info-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="info-container"></div>
    </div>
  </div>
  
  <!-- V2.25 Dashboard Panel -->
  <div class="panel-backdrop" id="dashboard-backdrop"></div>
  <div class="panel dashboard-panel" id="dashboard-panel">
    <div class="panel-header">
      <span class="panel-title">ðŸ  Dashboard</span>
      <button class="panel-close" id="dashboard-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="dashboard-container"></div>
    </div>
  </div>
  
  <!-- V2.25 About Dialog -->
  <div class="panel-backdrop" id="about-backdrop"></div>
  <div class="panel about-panel" id="about-panel">
    <div class="panel-header">
      <span class="panel-title">About VIRECAI</span>
      <button class="panel-close" id="about-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div id="about-container"></div>
    </div>
  </div>
  
  <!-- V2.26 Status Bar -->
  <div class="status-bar" id="status-bar"></div>
  
  <!-- V2.27 Capture Flash Effect -->
  <div class="capture-flash" id="capture-flash"></div>
  
  <!-- V2.26 Breadcrumbs -->
  <div class="breadcrumbs" id="breadcrumbs" style="display: none;"></div>
  
  <!-- V2.26 Notification Panel -->
  <div class="notification-panel" id="notification-panel">
    <div class="notification-header">
      <span class="notification-title">ðŸ”” Notifications</span>
      <button class="notification-clear" onclick="notificationCenter.clear()">Clear all</button>
    </div>
    <div class="notification-list" id="notification-list"></div>
  </div>
  
  <!-- V2.26 Floating Actions Bar -->
  <div id="floating-actions"></div>
  
  <!-- V2.26 Timeline Minimap Container (used in various places) -->
  <div id="timeline-minimap-container" style="display: none;"></div>
  
  <!-- V2.23 Save Search Dialog -->
  <div class="panel-backdrop" id="save-search-backdrop"></div>
  <div class="panel" id="save-search-panel" style="max-width: 350px;">
    <div class="panel-header">
      <span class="panel-title">â­ Save Search</span>
      <button class="panel-close" id="save-search-close">âœ•</button>
    </div>
    <div class="panel-content">
      <div class="add-collab-form">
        <div class="add-collab-field">
          <label>Search Name</label>
          <input type="text" id="save-search-name" placeholder="My saved search">
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin: 10px 0;">
          Query: <strong id="save-search-query-display"></strong>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 8px;">
          <button onclick="closeSaveSearchDialog()" style="flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); cursor: pointer;">Cancel</button>
          <button onclick="confirmSaveSearch()" style="flex: 1; padding: 12px; border: none; border-radius: 8px; background: var(--accent-cyan); color: #000; font-weight: 600; cursor: pointer;">Save</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- V2.20 Undo/Redo Floating Buttons -->
  <div class="undo-redo-indicator" id="undo-redo-indicator">
    <button class="undo-btn" id="undo-btn" onclick="doUndo()" title="Undo (Ctrl+Z)">â†©</button>
    <button class="redo-btn" id="redo-btn" onclick="doRedo()" title="Redo (Ctrl+Y)">â†ª</button>
  </div>
  
  <!-- V2.20 Batch Actions Bar -->
  <div class="batch-actions-bar" id="batch-actions-bar">
    <span id="batch-count">0 selected</span>
    <button class="batch-action-btn delete" onclick="batchDelete()">ðŸ—‘ï¸ Delete</button>
    <button class="batch-action-btn export" onclick="batchExport()">ðŸ“¦ Export</button>
    <button class="batch-action-btn cancel" onclick="clearBatchSelection()">Cancel</button>
  </div>
  
  <!-- V2.17 Performance Badge -->
  <div id="perf-badge" class="perf-badge" style="display:none;">FPS: --</div>
  
  <!-- Hidden file input for imports -->
  <input type="file" id="import-file-input" accept=".json,.mullu,.vrc" style="display:none;">
  
  <!-- Smart Timeline Container (injected into main UI) -->
  <div id="smart-timeline-wrapper" style="display:none;">
    <div class="smart-timeline-container" id="smart-timeline-container"></div>
  </div>
  
  <!-- Performance Monitor (floating) -->
  <div id="perf-monitor-float" style="position:fixed;bottom:60px;right:10px;z-index:100;display:none;"></div>
  
  <!-- Command Palette -->
  <div class="command-backdrop" id="command-backdrop"></div>
  <div class="command-panel" id="command-panel">
    <input type="text" class="command-input" id="command-input" placeholder="Type a command...">
    <div class="command-list" id="command-list"></div>
  </div>
  
  <!-- Bookmarks Section (added to Analytics panel via JS) -->

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIRECAI v2.27 â€” Complete Symbolic Reality Capture Engine
// 7-Stage Pipeline: SENSE â†’ SYNC â†’ SYMBOL â†’ REASON â†’ VALIDATE â†’ CHAIN â†’ STORE
// 11-Theory Mathematical Framework
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Debug Mode (set to false for production)
const DEBUG = { 
  enabled: false, 
  theory: false, 
  pipeline: false,
  log: (...args) => DEBUG.enabled && console.log('[DEBUG]', ...args),
  theory_log: (...args) => DEBUG.theory && console.log('[THEORY]', ...args),
  pipeline_log: (...args) => DEBUG.pipeline && console.log('[PIPE]', ...args)
};

// Expose debug toggle globally
window.VIRECAI_DEBUG = (mode = true) => { DEBUG.enabled = mode; DEBUG.theory = mode; DEBUG.pipeline = mode; console.log('Debug mode:', mode); };

const U = {
  _uid: 0,
  uid: () => `${Date.now().toString(36)}_${(U._uid++).toString(36)}`,
  clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
  now: () => performance.now(),
  timestamp: () => Date.now(),
  formatTime: ms => { const s = Math.floor(ms/1000); return `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`; },
  formatSize: b => b < 1024 ? b + ' B' : b < 1024*1024 ? (b/1024).toFixed(1) + ' KB' : (b/(1024*1024)).toFixed(2) + ' MB',
  hash: s => { let h = 0x811c9dc5; for(let i=0;i<s.length;i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 0x01000193); } return (h >>> 0).toString(36); },
  mean: arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0,
  stdDev: arr => { if(arr.length<2)return 0; const m=U.mean(arr); return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-m,2),0)/arr.length); },
  runningAvg: (prev, val, n) => n > 0 ? (prev * (n-1) + val) / n : val,
  safeNum: (v, fallback = 0) => (typeof v === 'number' && isFinite(v)) ? v : fallback,
  safePct: v => U.clamp(U.safeNum(v) * 100, 0, 100).toFixed(1),
  // New helpers for v2.26
  formatNum: (v, decimals = 2) => U.safeNum(v).toFixed(decimals),
  formatMetric: (v, unit = '', decimals = 2) => {
    const n = U.safeNum(v);
    if (n === 0) return 'â€”';
    return n.toFixed(decimals) + (unit ? ' ' + unit : '');
  },
  classify: (v, thresholds) => {
    // thresholds = { high: 0.7, mid: 0.4 }
    const n = U.safeNum(v);
    if (n >= thresholds.high) return 'high';
    if (n >= thresholds.mid) return 'mid';
    return 'low';
  },
  lerp: (a, b, t) => a + (b - a) * U.clamp(t, 0, 1),
  mapRange: (v, inMin, inMax, outMin, outMax) => outMin + (outMax - outMin) * ((v - inMin) / (inMax - inMin)),
  debounce: (fn, ms) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; },
  throttle: (fn, ms) => { let last = 0; return (...args) => { const now = Date.now(); if (now - last >= ms) { last = now; fn(...args); } }; },
};

// EventBus
class EventBus {
  constructor() { this.listeners = new Map(); this.history = []; }
  on(e, cb) { if(!this.listeners.has(e)) this.listeners.set(e, []); this.listeners.get(e).push(cb); }
  emit(e, data = {}) {
    this.history.push({ event: e, data, timestamp: U.timestamp() });
    if (this.history.length > 100) this.history.shift();
    (this.listeners.get(e) || []).forEach(cb => { try { cb(data); } catch(err) { console.error(err); } });
    (this.listeners.get('*') || []).forEach(cb => { try { cb(data, e); } catch(err) {} });
  }
}
const bus = new EventBus();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCHITECTURAL ENHANCEMENTS â€” v2.26 Core Systems
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HIERARCHICAL CAPSULE SYSTEM â€” Scene â†’ Moment â†’ Frame â†’ Layer
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SceneCapsule {
  constructor(id, startFrame) {
    this.id = id;
    this.startFrame = startFrame;
    this.endFrame = null;
    this.moments = [];
    this.signature = null;
    this.keyframes = [];  // Most representative frames
    this.transitions = []; // Scene boundaries detected
    this.metadata = {
      dominantType: null,
      avgEntropy: 0,
      avgMotion: 0,
      avgLuminance: 0,
      eventCount: 0,
      duration: 0,
      frameCount: 0,
      colorPalette: [],    // Dominant colors
      complexity: 0,       // Overall scene complexity
      stability: 0,        // How stable the scene is
      tags: []             // Auto-generated tags
    };
  }
  
  addMoment(moment) {
    this.moments.push(moment);
    this.endFrame = moment.endFrame;
    
    // Track keyframe from moment
    if (moment.keyframe) {
      this.keyframes.push({
        frameIndex: moment.keyframe.index,
        entropy: moment.keyframe.getLayer('visual')?.entropy?.total || 0,
        momentId: moment.id
      });
    }
    
    this._updateMetadata();
  }
  
  _updateMetadata() {
    if (this.moments.length === 0) return;
    const allFrames = this.moments.flatMap(m => m.frames);
    if (allFrames.length === 0) return;
    
    const entropies = allFrames.map(f => f.getLayer('visual')?.entropy?.total || 0);
    const motions = allFrames.map(f => f.getLayer('visual')?.motionDelta || 0);
    const luminances = allFrames.map(f => f.getLayer('visual')?.stats?.luminance || 0);
    
    this.metadata.avgEntropy = U.mean(entropies);
    this.metadata.avgMotion = U.mean(motions);
    this.metadata.avgLuminance = U.mean(luminances);
    this.metadata.eventCount = allFrames.reduce((sum, f) => sum + f.causalInferences.length, 0);
    this.metadata.duration = this.endFrame - this.startFrame;
    this.metadata.frameCount = allFrames.length;
    
    // Scene stability (inverse of motion variance)
    const motionVariance = U.stdDev(motions);
    this.metadata.stability = Math.max(0, 1 - motionVariance * 2);
    
    // Complexity score (entropy + edge density)
    const avgEdge = U.mean(allFrames.map(f => f.getLayer('visual')?.edgeDensity || 0));
    this.metadata.complexity = (this.metadata.avgEntropy + avgEdge) / 2;
    
    // Determine dominant scene type
    const types = allFrames.map(f => f.getLayer('visual')?.sceneType).filter(Boolean);
    const typeCounts = types.reduce((acc, t) => { acc[t] = (acc[t] || 0) + 1; return acc; }, {});
    this.metadata.dominantType = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'unknown';
    
    // Extract color palette from keyframe
    this._extractColorPalette(allFrames);
    
    // Auto-generate tags
    this._generateTags();
  }
  
  _extractColorPalette(frames) {
    if (frames.length === 0) return;
    const keyframe = frames[Math.floor(frames.length / 2)];
    const grid = keyframe?.getLayer('visual')?.grid;
    if (!grid) return;
    
    // Simple dominant color extraction
    const colors = {};
    grid.flat().forEach(cell => {
      const key = `${Math.round(cell.r/32)*32},${Math.round(cell.g/32)*32},${Math.round(cell.b/32)*32}`;
      colors[key] = (colors[key] || 0) + 1;
    });
    
    this.metadata.colorPalette = Object.entries(colors)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([rgb]) => {
        const [r, g, b] = rgb.split(',').map(Number);
        return { r, g, b, hex: `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}` };
      });
  }
  
  _generateTags() {
    const tags = [];
    
    // Luminance-based tags
    if (this.metadata.avgLuminance < 0.2) tags.push('dark');
    else if (this.metadata.avgLuminance > 0.7) tags.push('bright');
    
    // Motion-based tags
    if (this.metadata.avgMotion > 0.3) tags.push('dynamic');
    else if (this.metadata.avgMotion < 0.05) tags.push('static');
    
    // Complexity-based tags
    if (this.metadata.complexity > 0.6) tags.push('complex');
    else if (this.metadata.complexity < 0.3) tags.push('simple');
    
    // Stability-based tags
    if (this.metadata.stability > 0.8) tags.push('stable');
    else if (this.metadata.stability < 0.4) tags.push('turbulent');
    
    // Duration-based tags
    if (this.metadata.frameCount > 60) tags.push('long');
    else if (this.metadata.frameCount < 15) tags.push('brief');
    
    // Event-based tags
    if (this.metadata.eventCount > 10) tags.push('eventful');
    
    this.metadata.tags = tags;
  }
  
  close() {
    // Sort keyframes by entropy and keep top 3
    this.keyframes.sort((a, b) => b.entropy - a.entropy);
    this.keyframes = this.keyframes.slice(0, 3);
    
    this.signature = U.hash(`scene_${this.id}_${this.startFrame}_${this.endFrame}_${this.moments.length}`);
    return this;
  }
  
  getSummary() {
    return {
      id: this.id,
      frames: `${this.startFrame}-${this.endFrame}`,
      moments: this.moments.length,
      keyframes: this.keyframes.map(k => k.frameIndex),
      tags: this.metadata.tags,
      ...this.metadata
    };
  }
  
  // Check if frame belongs to this scene
  contains(frameIndex) {
    return frameIndex >= this.startFrame && (this.endFrame === null || frameIndex <= this.endFrame);
  }
}

class MomentCapsule {
  constructor(id, startFrame) {
    this.id = id;
    this.startFrame = startFrame;
    this.endFrame = null;
    this.frames = [];
    this.keyframe = null;
    this.events = [];
    this.attention = null;
    this.summary = {
      avgEntropy: 0,
      avgMotion: 0,
      peakMotion: 0,
      dominantInference: null,
      significantChanges: 0
    };
  }
  
  addFrame(frame) {
    this.frames.push(frame);
    this.endFrame = frame.index;
    
    // Select keyframe by multiple criteria (not just entropy)
    const currentScore = this._scoreFrame(frame);
    const keyframeScore = this.keyframe ? this._scoreFrame(this.keyframe) : -1;
    
    if (currentScore > keyframeScore) {
      this.keyframe = frame;
    }
    
    // Track events
    frame.causalInferences.forEach(inf => {
      if (inf.type !== 'continuous_capture') {
        this.events.push({ type: inf.type, frameIndex: frame.index, confidence: inf.confidence });
      }
    });
    
    // Update running summary
    this._updateSummary();
  }
  
  _scoreFrame(frame) {
    const visual = frame.getLayer('visual');
    if (!visual) return 0;
    
    const entropy = visual.entropy?.total || 0;
    const edge = visual.edgeDensity || 0;
    const contrast = visual.contrast || 0;
    
    // Composite score: entropy (40%) + edge (30%) + contrast (30%)
    return entropy * 0.4 + edge * 0.3 + contrast * 0.3;
  }
  
  _updateSummary() {
    if (this.frames.length === 0) return;
    
    const entropies = this.frames.map(f => f.getLayer('visual')?.entropy?.total || 0);
    const motions = this.frames.map(f => f.getLayer('visual')?.motionDelta || 0);
    
    this.summary.avgEntropy = U.mean(entropies);
    this.summary.avgMotion = U.mean(motions);
    this.summary.peakMotion = Math.max(...motions);
    
    // Find dominant inference type
    const infTypes = this.events.map(e => e.type);
    if (infTypes.length > 0) {
      const counts = infTypes.reduce((acc, t) => { acc[t] = (acc[t] || 0) + 1; return acc; }, {});
      this.summary.dominantInference = Object.entries(counts).sort((a, b) => b[1] - a[1])[0]?.[0];
    }
    
    // Count significant changes (motion > 0.2 between consecutive frames)
    let changes = 0;
    for (let i = 1; i < this.frames.length; i++) {
      const motion = this.frames[i].getLayer('visual')?.motionDelta || 0;
      if (motion > 0.2) changes++;
    }
    this.summary.significantChanges = changes;
  }
  
  addEvent(event) {
    this.events.push({ ...event, momentId: this.id, timestamp: U.timestamp() });
  }
  
  computeAttention() {
    if (this.frames.length === 0) return null;
    const visual = this.keyframe?.getLayer('visual');
    if (!visual?.grid) return null;
    
    // Enhanced attention computation
    const grid = visual.grid;
    const avgLum = visual.stats?.luminance || 0.5;
    
    this.attention = grid.map((row, y) => 
      row.map((cell, x) => {
        // Edge strength at this cell
        let edge = 0;
        if (y > 0) edge += Math.abs(cell.lum - grid[y-1][x].lum);
        if (x > 0) edge += Math.abs(cell.lum - grid[y][x-1].lum);
        if (y < grid.length - 1) edge += Math.abs(cell.lum - grid[y+1][x].lum);
        if (x < grid[0].length - 1) edge += Math.abs(cell.lum - grid[y][x+1].lum);
        edge /= 4;
        
        // Color saturation
        const max = Math.max(cell.r, cell.g, cell.b);
        const min = Math.min(cell.r, cell.g, cell.b);
        const sat = max > 0 ? (max - min) / max / 255 : 0;
        
        // Luminance variance from mean
        const lumVar = Math.abs(cell.lum - avgLum);
        
        // Center bias (gaussian)
        const cx = (x - grid[0].length/2) / (grid[0].length/2);
        const cy = (y - grid.length/2) / (grid.length/2);
        const centerBias = Math.exp(-(cx*cx + cy*cy) * 0.5) * 0.3;
        
        return U.clamp(edge * 0.35 + sat * 0.2 + lumVar * 0.15 + centerBias, 0, 1);
      })
    );
    
    return this.attention;
  }
  
  getDuration() { return this.endFrame - this.startFrame; }
  
  getFrameCount() { return this.frames.length; }
  
  getSummary() {
    return {
      id: this.id,
      frames: `${this.startFrame}-${this.endFrame}`,
      frameCount: this.frames.length,
      keyframe: this.keyframe?.index,
      events: this.events.length,
      ...this.summary
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SYMBOLIC INDEX â€” Fast O(1) Lookup
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SymbolicIndex {
  constructor() {
    this.byEntropy = { high: [], mid: [], low: [] };    // Entropy buckets
    this.byMotion = { high: [], mid: [], low: [] };      // Motion buckets
    this.byLuminance = { bright: [], normal: [], dark: [] }; // Luminance buckets
    this.bySceneType = {};                               // Scene type â†’ frames
    this.byCausalEvent = {};                             // Event type â†’ frames
    this.byPhase = {};                                   // Thermodynamic phase â†’ frames
    this.byTimeRange = new Map();                        // Time bucket â†’ frames
    this.byHash = new Map();                             // Hash â†’ frame
    this.bySignature = new Map();                        // Signature â†’ frame
    this.byTag = {};                                     // Custom tags â†’ frames
    this.temporal = [];                                  // Ordered frame list
    this.frameData = new Map();                          // Frame index â†’ quick lookup data
    this.invertedIndex = new Map();                      // Word â†’ frame indices (for text search)
  }
  
  index(frame) {
    const idx = frame.index;
    const visual = frame.getLayer('visual');
    const theoretical = frame.theoretical;
    
    // Store quick lookup data
    this.frameData.set(idx, {
      entropy: visual?.entropy?.total || 0,
      motion: visual?.motionDelta || 0,
      luminance: visual?.stats?.luminance || 0,
      sceneType: visual?.sceneType || 'unknown',
      phase: theoretical?.thermodynamics?.phase || 'unknown',
      score: theoretical?.theoreticalScore || 0,
      inferences: frame.causalInferences.map(i => i.type)
    });
    
    // Entropy index
    const entropy = visual?.entropy?.total || 0;
    if (entropy > 0.7) this.byEntropy.high.push(idx);
    else if (entropy > 0.4) this.byEntropy.mid.push(idx);
    else this.byEntropy.low.push(idx);
    
    // Motion index
    const motion = visual?.motionDelta || 0;
    if (motion > 0.3) this.byMotion.high.push(idx);
    else if (motion > 0.1) this.byMotion.mid.push(idx);
    else this.byMotion.low.push(idx);
    
    // Luminance index
    const luminance = visual?.stats?.luminance || 0;
    if (luminance > 0.65) this.byLuminance.bright.push(idx);
    else if (luminance > 0.25) this.byLuminance.normal.push(idx);
    else this.byLuminance.dark.push(idx);
    
    // Scene type index
    const sceneType = visual?.sceneType || 'unknown';
    if (!this.bySceneType[sceneType]) this.bySceneType[sceneType] = [];
    this.bySceneType[sceneType].push(idx);
    
    // Causal event index
    frame.causalInferences.forEach(inf => {
      if (!this.byCausalEvent[inf.type]) this.byCausalEvent[inf.type] = [];
      this.byCausalEvent[inf.type].push(idx);
      
      // Build inverted index for text search
      const words = inf.type.split('_');
      words.forEach(word => {
        if (!this.invertedIndex.has(word)) this.invertedIndex.set(word, new Set());
        this.invertedIndex.get(word).add(idx);
      });
    });
    
    // Phase index
    const phase = theoretical?.thermodynamics?.phase;
    if (phase) {
      if (!this.byPhase[phase]) this.byPhase[phase] = [];
      this.byPhase[phase].push(idx);
    }
    
    // Time bucket (1-second buckets)
    const timeBucket = Math.floor(frame.timestamp / 1000);
    if (!this.byTimeRange.has(timeBucket)) this.byTimeRange.set(timeBucket, []);
    this.byTimeRange.get(timeBucket).push(idx);
    
    // Hash/signature index
    if (visual?.dHash) this.byHash.set(visual.dHash, idx);
    if (frame.signature) this.bySignature.set(frame.signature, idx);
    
    // Temporal
    this.temporal.push(idx);
  }
  
  // Add custom tag to frames
  tag(frameIndices, tagName) {
    if (!this.byTag[tagName]) this.byTag[tagName] = [];
    frameIndices.forEach(idx => {
      if (!this.byTag[tagName].includes(idx)) {
        this.byTag[tagName].push(idx);
      }
    });
  }
  
  // Remove tag from frames
  untag(frameIndices, tagName) {
    if (!this.byTag[tagName]) return;
    this.byTag[tagName] = this.byTag[tagName].filter(idx => !frameIndices.includes(idx));
  }
  
  query(criteria) {
    let results = new Set(this.temporal);
    
    if (criteria.entropy) {
      const bucket = this.byEntropy[criteria.entropy] || [];
      results = new Set(bucket.filter(i => results.has(i)));
    }
    if (criteria.motion) {
      const bucket = this.byMotion[criteria.motion] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.luminance) {
      const bucket = this.byLuminance[criteria.luminance] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.sceneType) {
      const bucket = this.bySceneType[criteria.sceneType] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.event) {
      const bucket = this.byCausalEvent[criteria.event] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.phase) {
      const bucket = this.byPhase[criteria.phase] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.tag) {
      const bucket = this.byTag[criteria.tag] || [];
      results = new Set([...bucket].filter(i => results.has(i)));
    }
    if (criteria.timeRange) {
      const [start, end] = criteria.timeRange;
      const inRange = [];
      for (let t = start; t <= end; t++) {
        if (this.byTimeRange.has(t)) inRange.push(...this.byTimeRange.get(t));
      }
      results = new Set([...inRange].filter(i => results.has(i)));
    }
    if (criteria.text) {
      // Text search across inverted index
      const words = criteria.text.toLowerCase().split(/\s+/);
      const matching = new Set();
      words.forEach(word => {
        if (this.invertedIndex.has(word)) {
          this.invertedIndex.get(word).forEach(idx => matching.add(idx));
        }
      });
      results = new Set([...matching].filter(i => results.has(i)));
    }
    
    return Array.from(results).sort((a, b) => a - b);
  }
  
  // Find frames in temporal neighborhood
  findNear(frameIndex, radius = 5) {
    const start = Math.max(0, frameIndex - radius);
    const end = Math.min(this.temporal.length - 1, frameIndex + radius);
    return this.temporal.slice(start, end + 1);
  }
  
  findSimilar(hash, threshold = 3) {
    // Find frames with similar hash (hamming distance)
    const similar = [];
    this.byHash.forEach((frameIdx, frameHash) => {
      const distance = this._hammingDistance(hash, frameHash);
      if (distance <= threshold) similar.push({ index: frameIdx, distance });
    });
    return similar.sort((a, b) => a.distance - b.distance);
  }
  
  // Find outliers (frames that differ significantly from neighbors)
  findOutliers(threshold = 0.3) {
    const outliers = [];
    for (let i = 1; i < this.temporal.length - 1; i++) {
      const prev = this.frameData.get(i - 1);
      const curr = this.frameData.get(i);
      const next = this.frameData.get(i + 1);
      
      if (!prev || !curr || !next) continue;
      
      const avgNeighborEntropy = (prev.entropy + next.entropy) / 2;
      const avgNeighborMotion = (prev.motion + next.motion) / 2;
      
      const entropyDiff = Math.abs(curr.entropy - avgNeighborEntropy);
      const motionDiff = Math.abs(curr.motion - avgNeighborMotion);
      
      if (entropyDiff > threshold || motionDiff > threshold) {
        outliers.push({ index: i, entropyDiff, motionDiff });
      }
    }
    return outliers;
  }
  
  // Get frame transitions (where significant changes happen)
  findTransitions(motionThreshold = 0.25) {
    const transitions = [];
    for (let i = 1; i < this.temporal.length; i++) {
      const curr = this.frameData.get(i);
      if (curr && curr.motion > motionThreshold) {
        transitions.push(i);
      }
    }
    return transitions;
  }
  
  _hammingDistance(a, b) {
    if (a.length !== b.length) return Infinity;
    let dist = 0;
    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) dist++;
    return dist;
  }
  
  getStats() {
    return {
      totalFrames: this.temporal.length,
      entropyDistribution: { high: this.byEntropy.high.length, mid: this.byEntropy.mid.length, low: this.byEntropy.low.length },
      motionDistribution: { high: this.byMotion.high.length, mid: this.byMotion.mid.length, low: this.byMotion.low.length },
      luminanceDistribution: { bright: this.byLuminance.bright.length, normal: this.byLuminance.normal.length, dark: this.byLuminance.dark.length },
      sceneTypes: Object.keys(this.bySceneType).length,
      sceneTypeBreakdown: Object.fromEntries(Object.entries(this.bySceneType).map(([k, v]) => [k, v.length])),
      eventTypes: Object.keys(this.byCausalEvent).length,
      phases: Object.keys(this.byPhase).length,
      phaseBreakdown: Object.fromEntries(Object.entries(this.byPhase).map(([k, v]) => [k, v.length])),
      customTags: Object.keys(this.byTag).length,
      uniqueHashes: this.byHash.size,
      indexedWords: this.invertedIndex.size
    };
  }
  
  // Reset for new recording
  reset() {
    this.byEntropy = { high: [], mid: [], low: [] };
    this.byMotion = { high: [], mid: [], low: [] };
    this.byLuminance = { bright: [], normal: [], dark: [] };
    this.bySceneType = {};
    this.byCausalEvent = {};
    this.byPhase = {};
    this.byTimeRange.clear();
    this.byHash.clear();
    this.bySignature.clear();
    this.byTag = {};
    this.temporal = [];
    this.frameData.clear();
    this.invertedIndex.clear();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DELTA COMPRESSION â€” Store only changes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class DeltaCompressor {
  constructor(keyframeInterval = 30) {
    this.keyframeInterval = keyframeInterval;
    this.lastKeyframe = null;
    this.keyframeIndex = 0;
  }
  
  compress(frame, prevFrame) {
    const isKeyframe = frame.index % this.keyframeInterval === 0 || !prevFrame;
    
    if (isKeyframe) {
      this.lastKeyframe = frame;
      this.keyframeIndex = frame.index;
      return {
        type: 'keyframe',
        index: frame.index,
        full: this._serializeFull(frame)
      };
    }
    
    // Compute delta from previous frame
    const delta = this._computeDelta(frame, prevFrame);
    return {
      type: 'delta',
      index: frame.index,
      keyframeRef: this.keyframeIndex,
      delta: delta
    };
  }
  
  _serializeFull(frame) {
    return {
      timestamp: frame.timestamp,
      visual: frame.getLayer('visual')?.data,
      audio: frame.getLayer('audio')?.data,
      motion: frame.getLayer('motion')?.data,
      gps: frame.getLayer('gps')?.data,
      wh: frame.wh,
      theoretical: frame.theoretical,
      causalInferences: frame.causalInferences
    };
  }
  
  _computeDelta(frame, prevFrame) {
    const delta = { index: frame.index, timestamp: frame.timestamp, changes: {} };
    
    // Visual delta
    const visual = frame.getLayer('visual');
    const prevVisual = prevFrame?.getLayer('visual');
    if (visual && prevVisual) {
      delta.changes.visual = {
        motionDelta: visual.motionDelta,
        sceneChange: visual.sceneChange,
        entropyDelta: (visual.entropy?.total || 0) - (prevVisual.entropy?.total || 0),
        lumDelta: (visual.stats?.luminance || 0) - (prevVisual.stats?.luminance || 0)
      };
      // Only store grid if significant change
      if (visual.motionDelta > 0.2) {
        delta.changes.visual.grid = visual.grid;
      }
    }
    
    // Motion delta (always small, store if changed)
    const motion = frame.getLayer('motion')?.data;
    const prevMotion = prevFrame?.getLayer('motion')?.data;
    if (motion && JSON.stringify(motion) !== JSON.stringify(prevMotion)) {
      delta.changes.motion = motion;
    }
    
    // WH changes
    if (frame.wh.why !== prevFrame?.wh.why) delta.changes.why = frame.wh.why;
    if (frame.wh.because !== prevFrame?.wh.because) delta.changes.because = frame.wh.because;
    
    // Causal inferences (always new)
    if (frame.causalInferences.length > 0) {
      delta.changes.causalInferences = frame.causalInferences;
    }
    
    // Theoretical (store diff)
    if (frame.theoretical) {
      delta.changes.theoreticalScore = frame.theoretical.theoreticalScore;
      delta.changes.phase = frame.theoretical.thermodynamics?.phase;
    }
    
    return delta;
  }
  
  decompress(compressed, keyframeData, prevFrameData) {
    if (compressed.type === 'keyframe') {
      return compressed.full;
    }
    
    // Reconstruct from keyframe + deltas
    const reconstructed = JSON.parse(JSON.stringify(keyframeData));
    const delta = compressed.delta;
    
    reconstructed.timestamp = delta.timestamp;
    
    if (delta.changes.visual) {
      reconstructed.visual = { ...reconstructed.visual, ...delta.changes.visual };
    }
    if (delta.changes.motion) reconstructed.motion = delta.changes.motion;
    if (delta.changes.why) reconstructed.wh.why = delta.changes.why;
    if (delta.changes.because) reconstructed.wh.because = delta.changes.because;
    if (delta.changes.causalInferences) reconstructed.causalInferences = delta.changes.causalInferences;
    if (delta.changes.theoreticalScore !== undefined) {
      reconstructed.theoretical = reconstructed.theoretical || {};
      reconstructed.theoretical.theoreticalScore = delta.changes.theoreticalScore;
    }
    
    return reconstructed;
  }
  
  getCompressionRatio(frames) {
    if (frames.length === 0) return 1;
    const keyframes = Math.ceil(frames.length / this.keyframeInterval);
    const deltas = frames.length - keyframes;
    // Estimate: keyframes are 100%, deltas are ~15% of keyframe size
    const compressedSize = keyframes * 1.0 + deltas * 0.15;
    return frames.length / compressedSize;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVENT SOURCING â€” Store events, reconstruct state
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class EventStore {
  constructor() {
    this.events = [];
    this.snapshots = new Map();  // frameIndex â†’ snapshot
    this.snapshotInterval = 50;
  }
  
  append(event) {
    const enriched = {
      ...event,
      id: U.uid(),
      timestamp: U.timestamp(),
      sequence: this.events.length
    };
    this.events.push(enriched);
    bus.emit('event:stored', enriched);
    return enriched;
  }
  
  // Core event types
  recordStart(mode) { return this.append({ type: 'RECORD_START', mode }); }
  recordStop(frameCount) { return this.append({ type: 'RECORD_STOP', frameCount }); }
  frameCapture(index, signature) { return this.append({ type: 'FRAME_CAPTURE', index, signature }); }
  sceneChange(fromType, toType, frameIndex) { return this.append({ type: 'SCENE_CHANGE', fromType, toType, frameIndex }); }
  causalInference(inference) { return this.append({ type: 'CAUSAL_INFERENCE', ...inference }); }
  patternDetected(pattern) { return this.append({ type: 'PATTERN_DETECTED', ...pattern }); }
  anomalyDetected(anomaly) { return this.append({ type: 'ANOMALY_DETECTED', ...anomaly }); }
  phaseTransition(from, to, frameIndex) { return this.append({ type: 'PHASE_TRANSITION', from, to, frameIndex }); }
  
  // Query events
  getByType(type) { return this.events.filter(e => e.type === type); }
  getInRange(start, end) { return this.events.filter(e => e.timestamp >= start && e.timestamp <= end); }
  getAfter(sequence) { return this.events.filter(e => e.sequence > sequence); }
  
  // Replay to reconstruct state
  replay(toSequence = this.events.length) {
    const state = { frames: 0, scenes: 0, inferences: [], patterns: [], anomalies: [] };
    
    for (let i = 0; i < toSequence && i < this.events.length; i++) {
      const event = this.events[i];
      switch (event.type) {
        case 'FRAME_CAPTURE': state.frames++; break;
        case 'SCENE_CHANGE': state.scenes++; break;
        case 'CAUSAL_INFERENCE': state.inferences.push(event); break;
        case 'PATTERN_DETECTED': state.patterns.push(event); break;
        case 'ANOMALY_DETECTED': state.anomalies.push(event); break;
      }
    }
    
    return state;
  }
  
  // Snapshot for faster replay
  saveSnapshot(frameIndex, state) {
    this.snapshots.set(frameIndex, { state: JSON.parse(JSON.stringify(state)), eventSequence: this.events.length });
  }
  
  getTimeline() {
    return this.events.map(e => ({
      time: e.timestamp,
      type: e.type,
      frame: e.frameIndex || e.index
    }));
  }
  
  export() {
    return {
      version: '2.4',
      events: this.events,
      snapshots: Array.from(this.snapshots.entries())
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MULTI-RESOLUTION PYRAMID â€” Coarse to fine search
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ResolutionPyramid {
  constructor() {
    this.levels = new Map();  // level â†’ data
  }
  
  build(grid) {
    // Level 0: Full 8x8 (original)
    this.levels.set(0, grid);
    
    // Level 1: 4x4 (downsampled)
    this.levels.set(1, this._downsample(grid, 4));
    
    // Level 2: 2x2 (abstract)
    this.levels.set(2, this._downsample(grid, 2));
    
    // Level 3: 1x1 (signature)
    this.levels.set(3, this._downsample(grid, 1));
    
    return this;
  }
  
  _downsample(grid, targetSize) {
    const srcSize = grid.length;
    const factor = srcSize / targetSize;
    const result = [];
    
    for (let y = 0; y < targetSize; y++) {
      const row = [];
      for (let x = 0; x < targetSize; x++) {
        let r = 0, g = 0, b = 0, lum = 0, count = 0;
        for (let dy = 0; dy < factor; dy++) {
          for (let dx = 0; dx < factor; dx++) {
            const sy = Math.min(Math.floor(y * factor + dy), srcSize - 1);
            const sx = Math.min(Math.floor(x * factor + dx), srcSize - 1);
            const cell = grid[sy][sx];
            r += cell.r; g += cell.g; b += cell.b; lum += cell.lum;
            count++;
          }
        }
        row.push({ r: Math.round(r/count), g: Math.round(g/count), b: Math.round(b/count), lum: lum/count });
      }
      result.push(row);
    }
    
    return result;
  }
  
  getLevel(level) { return this.levels.get(level); }
  
  getSignature() {
    const l3 = this.levels.get(3);
    if (!l3 || !l3[0]) return null;
    const cell = l3[0][0];
    return { avgLum: cell.lum, avgR: cell.r, avgG: cell.g, avgB: cell.b };
  }
  
  compare(other, level = 2) {
    const a = this.levels.get(level);
    const b = other.levels.get(level);
    if (!a || !b) return 1;
    
    let diff = 0, count = 0;
    for (let y = 0; y < a.length; y++) {
      for (let x = 0; x < a[0].length; x++) {
        diff += Math.abs(a[y][x].lum - b[y][x].lum);
        count++;
      }
    }
    return diff / count;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ATTENTION MECHANISM â€” Focus computation
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AttentionMap {
  constructor(grid) {
    this.weights = this._compute(grid);
    this.focusPoint = this._findFocus();
  }
  
  _compute(grid) {
    if (!grid || grid.length === 0) return [];
    
    const size = grid.length;
    const weights = [];
    
    // Compute attention based on:
    // 1. Edge strength (high contrast = interesting)
    // 2. Color saturation (colorful = interesting)
    // 3. Center bias (slight preference for center)
    // 4. Motion (if available)
    
    for (let y = 0; y < size; y++) {
      const row = [];
      for (let x = 0; x < size; x++) {
        const cell = grid[y][x];
        
        // Edge strength
        let edge = 0;
        if (y > 0) edge += Math.abs(cell.lum - grid[y-1][x].lum);
        if (x > 0) edge += Math.abs(cell.lum - grid[y][x-1].lum);
        if (y < size-1) edge += Math.abs(cell.lum - grid[y+1][x].lum);
        if (x < size-1) edge += Math.abs(cell.lum - grid[y][x+1].lum);
        edge /= 4;
        
        // Color saturation
        const max = Math.max(cell.r, cell.g, cell.b);
        const min = Math.min(cell.r, cell.g, cell.b);
        const sat = max > 0 ? (max - min) / max : 0;
        
        // Center bias (gaussian-like)
        const cx = (x - size/2) / (size/2);
        const cy = (y - size/2) / (size/2);
        const centerBias = Math.exp(-(cx*cx + cy*cy) * 0.5);
        
        // Combine
        const attention = edge * 0.4 + (sat/255) * 0.3 + centerBias * 0.3;
        row.push(U.clamp(attention, 0, 1));
      }
      weights.push(row);
    }
    
    return weights;
  }
  
  _findFocus() {
    if (this.weights.length === 0) return { x: 0.5, y: 0.5 };
    
    let maxWeight = 0;
    let focusX = 0, focusY = 0;
    
    for (let y = 0; y < this.weights.length; y++) {
      for (let x = 0; x < this.weights[0].length; x++) {
        if (this.weights[y][x] > maxWeight) {
          maxWeight = this.weights[y][x];
          focusX = x;
          focusY = y;
        }
      }
    }
    
    return { 
      x: focusX / this.weights[0].length, 
      y: focusY / this.weights.length,
      weight: maxWeight 
    };
  }
  
  getWeightedMean(values) {
    // Compute weighted average using attention
    if (!values || values.length !== this.weights.length) return 0;
    
    let sum = 0, weightSum = 0;
    for (let y = 0; y < values.length; y++) {
      for (let x = 0; x < values[0].length; x++) {
        const w = this.weights[y][x];
        sum += values[y][x] * w;
        weightSum += w;
      }
    }
    return weightSum > 0 ? sum / weightSum : 0;
  }
  
  getRegions(threshold = 0.5) {
    // Find high-attention regions
    const regions = [];
    const visited = new Set();
    
    for (let y = 0; y < this.weights.length; y++) {
      for (let x = 0; x < this.weights[0].length; x++) {
        if (this.weights[y][x] >= threshold && !visited.has(`${x},${y}`)) {
          const region = this._floodFill(x, y, threshold, visited);
          if (region.length > 0) regions.push(region);
        }
      }
    }
    
    return regions;
  }
  
  _floodFill(startX, startY, threshold, visited) {
    const region = [];
    const queue = [[startX, startY]];
    
    while (queue.length > 0) {
      const [x, y] = queue.shift();
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      if (x < 0 || x >= this.weights[0].length || y < 0 || y >= this.weights.length) continue;
      if (this.weights[y][x] < threshold) continue;
      
      visited.add(key);
      region.push({ x, y, weight: this.weights[y][x] });
      
      queue.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
    }
    
    return region;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SYMBOLIC DIFF â€” Semantic difference between frames
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SymbolicDiff {
  static compute(frameA, frameB) {
    const diff = {
      frameA: frameA.index,
      frameB: frameB.index,
      timeDelta: frameB.timestamp - frameA.timestamp,
      changes: [],
      additions: [],
      removals: [],
      metrics: {}
    };
    
    const vA = frameA.getLayer('visual');
    const vB = frameB.getLayer('visual');
    
    // Visual changes
    if (vA && vB) {
      diff.metrics.motionDelta = vB.motionDelta;
      diff.metrics.entropyDelta = (vB.entropy?.total || 0) - (vA.entropy?.total || 0);
      diff.metrics.luminanceDelta = (vB.stats?.luminance || 0) - (vA.stats?.luminance || 0);
      diff.metrics.contrastDelta = (vB.contrast || 0) - (vA.contrast || 0);
      
      if (vA.sceneType !== vB.sceneType) {
        diff.changes.push({ type: 'scene_type', from: vA.sceneType, to: vB.sceneType });
      }
      if (Math.abs(diff.metrics.entropyDelta) > 0.1) {
        diff.changes.push({ type: 'entropy', direction: diff.metrics.entropyDelta > 0 ? 'increased' : 'decreased', delta: diff.metrics.entropyDelta });
      }
      if (Math.abs(diff.metrics.luminanceDelta) > 0.15) {
        diff.changes.push({ type: 'lighting', direction: diff.metrics.luminanceDelta > 0 ? 'brighter' : 'darker', delta: diff.metrics.luminanceDelta });
      }
    }
    
    // WH changes
    ['what', 'where', 'when', 'why', 'how', 'because'].forEach(wh => {
      if (frameA.wh[wh] !== frameB.wh[wh]) {
        diff.changes.push({ type: `wh_${wh}`, from: frameA.wh[wh], to: frameB.wh[wh] });
      }
    });
    
    // Causal inference differences
    const infA = new Set(frameA.causalInferences.map(i => i.type));
    const infB = new Set(frameB.causalInferences.map(i => i.type));
    
    infB.forEach(type => { if (!infA.has(type)) diff.additions.push({ type: 'inference', value: type }); });
    infA.forEach(type => { if (!infB.has(type)) diff.removals.push({ type: 'inference', value: type }); });
    
    // Theoretical changes
    const tA = frameA.theoretical;
    const tB = frameB.theoretical;
    if (tA && tB) {
      diff.metrics.scoreDelta = (tB.theoreticalScore || 0) - (tA.theoreticalScore || 0);
      if (tA.thermodynamics?.phase !== tB.thermodynamics?.phase) {
        diff.changes.push({ type: 'phase', from: tA.thermodynamics?.phase, to: tB.thermodynamics?.phase });
      }
    }
    
    // Compute significance score
    diff.significance = diff.changes.length * 0.3 + 
                        diff.additions.length * 0.2 + 
                        diff.removals.length * 0.2 +
                        Math.abs(diff.metrics.motionDelta || 0) * 0.3;
    
    return diff;
  }
  
  static summarize(diffs) {
    return {
      totalChanges: diffs.reduce((sum, d) => sum + d.changes.length, 0),
      avgSignificance: U.mean(diffs.map(d => d.significance)),
      mostCommonChange: this._mostCommon(diffs.flatMap(d => d.changes.map(c => c.type))),
      phaseTransitions: diffs.filter(d => d.changes.some(c => c.type === 'phase')).length,
      sceneChanges: diffs.filter(d => d.changes.some(c => c.type === 'scene_type')).length
    };
  }
  
  static _mostCommon(arr) {
    if (arr.length === 0) return null;
    const counts = arr.reduce((acc, v) => { acc[v] = (acc[v] || 0) + 1; return acc; }, {});
    return Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LAZY COMPUTATION â€” Compute on demand
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class LazyCompute {
  constructor() {
    this.cache = new Map();
    this.pending = new Map();
  }
  
  get(key, computeFn) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const result = computeFn();
    this.cache.set(key, result);
    return result;
  }
  
  async getAsync(key, computeFn) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    
    const promise = computeFn().then(result => {
      this.cache.set(key, result);
      this.pending.delete(key);
      return result;
    });
    
    this.pending.set(key, promise);
    return promise;
  }
  
  invalidate(key) {
    this.cache.delete(key);
  }
  
  invalidatePrefix(prefix) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) this.cache.delete(key);
    }
  }
  
  clear() {
    this.cache.clear();
    this.pending.clear();
  }
  
  getStats() {
    return { cached: this.cache.size, pending: this.pending.size };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSISTENCE LAYER â€” IndexedDB Storage for Production Readiness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PersistenceManager {
  constructor() {
    this.dbName = 'virecai_db';
    this.dbVersion = 1;
    this.db = null;
    this.isReady = false;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => {
        console.error('IndexedDB error:', request.error);
        reject(request.error);
      };
      
      request.onsuccess = () => {
        this.db = request.result;
        this.isReady = true;
        console.log('VIRECAI DB initialized');
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Recordings store
        if (!db.objectStoreNames.contains('recordings')) {
          const recordingsStore = db.createObjectStore('recordings', { keyPath: 'id' });
          recordingsStore.createIndex('created', 'created', { unique: false });
          recordingsStore.createIndex('name', 'name', { unique: false });
        }
        
        // Frames store (separate for large data)
        if (!db.objectStoreNames.contains('frames')) {
          const framesStore = db.createObjectStore('frames', { keyPath: 'id' });
          framesStore.createIndex('recordingId', 'recordingId', { unique: false });
          framesStore.createIndex('frameIndex', 'frameIndex', { unique: false });
        }
        
        // Thumbnails store
        if (!db.objectStoreNames.contains('thumbnails')) {
          const thumbStore = db.createObjectStore('thumbnails', { keyPath: 'id' });
          thumbStore.createIndex('recordingId', 'recordingId', { unique: false });
        }
        
        // Settings store
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
      };
    });
  }
  
  async saveRecording(recording) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['recordings'], 'readwrite');
      const store = tx.objectStore('recordings');
      
      const record = {
        id: recording.id || U.uid(),
        name: recording.name || `Recording ${new Date().toLocaleString()}`,
        created: recording.created || U.timestamp(),
        updated: U.timestamp(),
        mode: recording.mode,
        frameCount: recording.frameCount,
        symbolCount: recording.symbolCount,
        duration: recording.duration,
        size: recording.size,
        theoreticalScore: recording.theoreticalScore,
        metadata: recording.metadata || {},
        vrcData: recording.vrcData  // Compressed VRC string
      };
      
      const request = store.put(record);
      request.onsuccess = () => resolve(record.id);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getRecording(id) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['recordings'], 'readonly');
      const store = tx.objectStore('recordings');
      const request = store.get(id);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getAllRecordings() {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['recordings'], 'readonly');
      const store = tx.objectStore('recordings');
      const index = store.index('created');
      const request = index.getAll();
      
      request.onsuccess = () => {
        // Sort by created descending (newest first)
        const recordings = request.result.sort((a, b) => b.created - a.created);
        resolve(recordings);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async deleteRecording(id) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['recordings', 'frames', 'thumbnails'], 'readwrite');
      
      // Delete recording
      tx.objectStore('recordings').delete(id);
      
      // Delete associated frames
      const framesStore = tx.objectStore('frames');
      const framesIndex = framesStore.index('recordingId');
      framesIndex.openCursor(IDBKeyRange.only(id)).onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        }
      };
      
      // Delete associated thumbnails
      const thumbStore = tx.objectStore('thumbnails');
      const thumbIndex = thumbStore.index('recordingId');
      thumbIndex.openCursor(IDBKeyRange.only(id)).onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        }
      };
      
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
  
  async saveThumbnail(recordingId, frameIndex, dataUrl) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['thumbnails'], 'readwrite');
      const store = tx.objectStore('thumbnails');
      
      const thumb = {
        id: `${recordingId}_${frameIndex}`,
        recordingId,
        frameIndex,
        dataUrl,
        created: U.timestamp()
      };
      
      const request = store.put(thumb);
      request.onsuccess = () => resolve(thumb.id);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getThumbnails(recordingId) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['thumbnails'], 'readonly');
      const store = tx.objectStore('thumbnails');
      const index = store.index('recordingId');
      const request = index.getAll(recordingId);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async saveSetting(key, value) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['settings'], 'readwrite');
      const store = tx.objectStore('settings');
      const request = store.put({ key, value, updated: U.timestamp() });
      
      request.onsuccess = () => resolve(true);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getSetting(key, defaultValue = null) {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['settings'], 'readonly');
      const store = tx.objectStore('settings');
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result?.value ?? defaultValue);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getStorageStats() {
    if (!this.isReady) await this.init();
    
    const recordings = await this.getAllRecordings();
    const totalSize = recordings.reduce((sum, r) => sum + (r.size || 0), 0);
    
    return {
      recordingCount: recordings.length,
      totalSize,
      totalSizeFormatted: U.formatSize(totalSize)
    };
  }
  
  async clearAll() {
    if (!this.isReady) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(['recordings', 'frames', 'thumbnails'], 'readwrite');
      tx.objectStore('recordings').clear();
      tx.objectStore('frames').clear();
      tx.objectStore('thumbnails').clear();
      
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// THUMBNAIL GENERATOR â€” Visual Frame Previews
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ThumbnailGenerator {
  constructor(width = 80, height = 60) {
    this.width = width;
    this.height = height;
    this.canvas = null;
    this.ctx = null;
  }
  
  init() {
    this.canvas = document.createElement('canvas');
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.ctx = this.canvas.getContext('2d');
  }
  
  generate(videoElement) {
    if (!this.canvas) this.init();
    
    this.ctx.drawImage(videoElement, 0, 0, this.width, this.height);
    return this.canvas.toDataURL('image/jpeg', 0.6);
  }
  
  generateFromGrid(grid) {
    if (!this.canvas) this.init();
    if (!grid || grid.length === 0) return null;
    
    const cellW = this.width / grid[0].length;
    const cellH = this.height / grid.length;
    
    for (let y = 0; y < grid.length; y++) {
      for (let x = 0; x < grid[0].length; x++) {
        const cell = grid[y][x];
        this.ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
        this.ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }
    
    return this.canvas.toDataURL('image/jpeg', 0.7);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TIMELINE MANAGER â€” Visual Navigation
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TimelineManager {
  constructor() {
    this.segments = [];
    this.markers = [];
    this.currentPosition = 0;
    this.totalDuration = 0;
    this.thumbnailCache = new Map();
  }
  
  update(container) {
    if (!container || container.frames.length === 0) return;
    
    this.totalDuration = container.frames[container.frames.length - 1].timestamp;
    this.segments = [];
    this.markers = [];
    
    // Create segments from scenes
    const scenes = container.getSceneSummary();
    scenes.forEach((scene, i) => {
      const [start, end] = scene.frames.split('-').map(Number);
      const startTime = container.frames[start]?.timestamp || 0;
      const endTime = container.frames[Math.min(end, container.frames.length - 1)]?.timestamp || startTime;
      
      this.segments.push({
        id: scene.id,
        startFrame: start,
        endFrame: end,
        startTime,
        endTime,
        type: scene.dominantType,
        tags: scene.tags,
        color: this._getSceneColor(scene.dominantType)
      });
    });
    
    // Create markers from significant events
    eventStore.events.forEach(event => {
      if (['SCENE_CHANGE', 'PHASE_TRANSITION', 'CAUSAL_INFERENCE'].includes(event.type)) {
        const frame = container.frames[event.frameIndex || event.index];
        if (frame) {
          this.markers.push({
            type: event.type,
            time: frame.timestamp,
            frame: event.frameIndex || event.index,
            label: event.type.replace('_', ' ').toLowerCase()
          });
        }
      }
    });
  }
  
  _getSceneColor(type) {
    const colors = {
      'dark_scene': '#334455',
      'bright_scene': '#ffdd88',
      'colorful_scene': '#ff88aa',
      'flat_scene': '#666688',
      'detailed_scene': '#88ddff',
      'normal_scene': '#5588aa',
      'unknown': '#444466'
    };
    return colors[type] || colors.unknown;
  }
  
  getSegmentAt(time) {
    return this.segments.find(s => time >= s.startTime && time <= s.endTime);
  }
  
  getMarkersInRange(startTime, endTime) {
    return this.markers.filter(m => m.time >= startTime && m.time <= endTime);
  }
  
  timeToPosition(time, width) {
    return (time / this.totalDuration) * width;
  }
  
  positionToTime(position, width) {
    return (position / width) * this.totalDuration;
  }
  
  positionToFrame(position, width, frameCount) {
    const time = this.positionToTime(position, width);
    return Math.floor((time / this.totalDuration) * frameCount);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE MONITOR â€” Real-time Stats
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PerfMonLegacy {
  constructor() {
    this.fps = 0;
    this.frameTime = 0;
    this.memoryUsage = 0;
    this.lastFrameTime = 0;
    this.frameTimes = [];
    this.maxSamples = 60;
  }
  
  tick() {
    const now = performance.now();
    if (this.lastFrameTime > 0) {
      const delta = now - this.lastFrameTime;
      this.frameTimes.push(delta);
      
      if (this.frameTimes.length > this.maxSamples) {
        this.frameTimes.shift();
      }
      
      const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
      this.fps = Math.round(1000 / avgFrameTime);
      this.frameTime = avgFrameTime.toFixed(1);
    }
    this.lastFrameTime = now;
    
    // Memory usage (if available)
    if (performance.memory) {
      this.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
    }
  }
  
  getStats() {
    return {
      fps: this.fps,
      frameTime: this.frameTime,
      memory: this.memoryUsage,
      samples: this.frameTimes.length
    };
  }
  
  reset() {
    this.fps = 0;
    this.frameTime = 0;
    this.lastFrameTime = 0;
    this.frameTimes = [];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EXPORT/IMPORT MANAGER â€” File Handling (Legacy)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class LegacyExporter {
  static async exportToFile(container, filename = 'recording.vrc') {
    const vrcData = container.toVRC();
    const blob = new Blob([vrcData], { type: 'application/octet-stream' });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    return { success: true, size: blob.size, filename };
  }
  
  static async exportToJSON(container, filename = 'recording.json') {
    const data = {
      version: container.version,
      exported: new Date().toISOString(),
      mode: container.mode,
      frameCount: container.frames.length,
      symbolCount: container.symbols.size,
      theoreticalSummary: container.getTheoreticalSummary(),
      causalSummary: container.getCausalSummary(),
      sceneSummary: container.getSceneSummary(),
      indexStats: container.getIndexStats(),
      compressionStats: container.getCompressionStats(),
      frames: container.frames.map(f => ({
        index: f.index,
        timestamp: f.timestamp,
        wh: f.wh,
        theoretical: f.theoretical,
        causalInferences: f.causalInferences,
        visual: {
          entropy: f.getLayer('visual')?.entropy,
          motionDelta: f.getLayer('visual')?.motionDelta,
          sceneType: f.getLayer('visual')?.sceneType,
          stats: f.getLayer('visual')?.stats
        }
      }))
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    return { success: true, size: blob.size, filename };
  }
  
  static async importFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const content = e.target.result;
          
          // Check if VRC format
          if (content.startsWith('MLVF2.5') || content.startsWith('MLVF2.4')) {
            const mode = content[7] === 'F' ? 'full' : 'lite';
            const jsonStr = decodeURIComponent(escape(atob(content.slice(8))));
            const data = JSON.parse(jsonStr);
            resolve({ type: 'vrc', mode, data });
          } 
          // Check if JSON
          else if (content.startsWith('{')) {
            const data = JSON.parse(content);
            resolve({ type: 'json', data });
          }
          else {
            reject(new Error('Unknown file format'));
          }
        } catch (err) {
          reject(err);
        }
      };
      
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RECORDING SESSION â€” Manages Current Recording State
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class RecordingSession {
  constructor() {
    this.id = null;
    this.name = null;
    this.startTime = null;
    this.thumbnails = [];
    this.thumbnailInterval = 30; // Every 30 frames
    this.autoSaveInterval = 60000; // Auto-save every minute
    this.autoSaveTimer = null;
    this.isDirty = false;
  }
  
  start(mode) {
    this.id = U.uid();
    this.name = `Recording ${new Date().toLocaleString()}`;
    this.startTime = U.timestamp();
    this.thumbnails = [];
    this.isDirty = false;
    
    // Start auto-save timer
    this.autoSaveTimer = setInterval(() => this.autoSave(), this.autoSaveInterval);
  }
  
  stop() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }
  
  addThumbnail(frameIndex, dataUrl) {
    if (frameIndex % this.thumbnailInterval === 0) {
      this.thumbnails.push({ frameIndex, dataUrl, time: U.timestamp() });
      this.isDirty = true;
    }
  }
  
  async autoSave() {
    if (!this.isDirty || !this.id) return;
    
    try {
      const container = orch?.getContainer();
      if (!container || container.frames.length === 0) return;
      
      await persistence.saveRecording({
        id: this.id,
        name: this.name,
        created: this.startTime,
        mode: container.mode,
        frameCount: container.frames.length,
        symbolCount: container.symbols.size,
        duration: container.frames[container.frames.length - 1]?.timestamp || 0,
        size: container.totalSize,
        theoreticalScore: container.getTheoreticalSummary()?.avgScore,
        vrcData: container.toVRC()
      });
      
      this.isDirty = false;
      console.log('Auto-saved recording:', this.id);
    } catch (err) {
      console.error('Auto-save failed:', err);
    }
  }
  
  markDirty() {
    this.isDirty = true;
  }
  
  rename(newName) {
    this.name = newName;
    this.isDirty = true;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.17 â€” PROFESSIONAL RECORDING CONTROLLER
// Handles Record, Pause, Resume, Stop with proper state management
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class RecordingController {
  constructor() {
    // States: 'idle' | 'recording' | 'paused' | 'stopped'
    this.state = 'idle';
    this.pausedAt = null;
    this.pauseDuration = 0;
    this.frameCountAtPause = 0;
    this.hasUnsavedData = false;
    this.onStateChange = null;
    
    // v2.27: Enhanced tracking
    this.retryCount = 0;
    this.maxRetries = 3;
    this.lastStateChange = 0;
    this.stateHistory = [];
    this.healthCheckInterval = null;
    this.frameRateHistory = [];
    this.lastFrameCount = 0;
    this.lastFrameCheck = 0;
  }
  
  getState() {
    return this.state;
  }
  
  // v2.27: Get detailed status
  getDetailedStatus() {
    const container = orch?.getContainer();
    const frameCount = container?.frames?.length || 0;
    const orchState = orch?.getState?.() || 'unknown';
    const avgFrameRate = this._calculateFrameRate();
    
    return {
      controllerState: this.state,
      orchestratorState: orchState,
      statesSynced: this._areStatesSynced(),
      frameCount,
      avgFrameRate,
      pauseDuration: this.pauseDuration,
      hasUnsavedData: this.hasUnsavedData,
      retryCount: this.retryCount,
      health: this._assessHealth()
    };
  }
  
  // v2.27: Check if states are synchronized
  _areStatesSynced() {
    const orchState = orch?.getState?.() || 'unknown';
    if (this.state === 'recording' && orchState !== 'recording') return false;
    if (this.state === 'paused' && orchState !== 'paused') return false;
    if ((this.state === 'idle' || this.state === 'stopped') && orchState === 'recording') return false;
    return true;
  }
  
  // v2.27: Assess recording health
  _assessHealth() {
    if (this.state !== 'recording') return 'n/a';
    
    const frameRate = this._calculateFrameRate();
    const targetFPS = orch?.config?.targetFPS || 10;
    
    if (frameRate < targetFPS * 0.3) return 'critical';
    if (frameRate < targetFPS * 0.6) return 'degraded';
    if (frameRate < targetFPS * 0.85) return 'fair';
    return 'good';
  }
  
  // v2.27: Calculate current frame rate
  _calculateFrameRate() {
    const now = performance.now();
    const container = orch?.getContainer();
    const currentFrameCount = container?.frames?.length || 0;
    
    if (this.lastFrameCheck > 0 && now - this.lastFrameCheck >= 1000) {
      const framesDelta = currentFrameCount - this.lastFrameCount;
      const timeDelta = (now - this.lastFrameCheck) / 1000;
      const rate = framesDelta / timeDelta;
      
      this.frameRateHistory.push(rate);
      if (this.frameRateHistory.length > 10) this.frameRateHistory.shift();
      
      this.lastFrameCount = currentFrameCount;
      this.lastFrameCheck = now;
    } else if (this.lastFrameCheck === 0) {
      this.lastFrameCount = currentFrameCount;
      this.lastFrameCheck = now;
    }
    
    if (this.frameRateHistory.length === 0) return 0;
    return this.frameRateHistory.reduce((a, b) => a + b, 0) / this.frameRateHistory.length;
  }
  
  // v2.27: Start health monitoring
  _startHealthMonitoring() {
    this._stopHealthMonitoring();
    this.healthCheckInterval = setInterval(() => {
      if (this.state === 'recording') {
        const synced = this._areStatesSynced();
        const health = this._assessHealth();
        
        if (!synced) {
          console.warn('[RecCtrl] State desync detected, attempting recovery...');
          this._attemptRecovery();
        } else if (health === 'critical') {
          console.warn('[RecCtrl] Critical health detected');
          notificationCenter?.warning?.('Recording performance is critical');
        }
      }
    }, 2000);
  }
  
  _stopHealthMonitoring() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }
  
  // v2.27: Attempt automatic recovery
  _attemptRecovery() {
    const orchState = orch?.getState?.() || 'unknown';
    
    if (this.state === 'recording' && orchState === 'ready') {
      // Orchestrator fell back to ready - try restarting
      console.log('[RecCtrl] Recovery: Restarting orchestrator recording');
      const restarted = orch?.startRecording?.();
      if (restarted) {
        Log.ok('recording', 'Auto-recovery successful');
        notificationCenter?.success?.('Recording recovered');
      } else {
        Log.error('recording', 'Auto-recovery failed');
        this.state = 'stopped';
        this._updateUI();
        toast?.error?.('Recording interrupted. Please try again.');
      }
    } else if (this.state === 'recording' && orchState === 'paused') {
      // Orchestrator got paused unexpectedly
      console.log('[RecCtrl] Recovery: Resuming orchestrator');
      orch?.resumeCapture?.();
    }
  }
  
  canRecord() {
    return this.state === 'idle' || this.state === 'stopped';
  }
  
  canPause() {
    return this.state === 'recording';
  }
  
  canResume() {
    return this.state === 'paused';
  }
  
  canStop() {
    return this.state === 'recording' || this.state === 'paused';
  }
  
  // Start new recording (with confirmation if unsaved data exists)
  async startNew() {
    if (this.hasUnsavedData) {
      const action = await this._showConfirmDialog();
      if (action === 'cancel') return false;
      if (action === 'save') {
        await this._saveCurrentRecording();
      }
      // action === 'discard' â†’ continue
    }
    
    this._resetState();
    const success = this._doStart();
    
    // v2.27: Start health monitoring on successful start
    if (success) {
      this._startHealthMonitoring();
    }
    
    return success;
  }
  
  // Pause recording (keeps frames, stops capture)
  pause() {
    if (!this.canPause()) return false;
    
    this.pausedAt = performance.now();
    this.frameCountAtPause = orch?.getContainer()?.frames?.length || 0;
    this.state = 'paused';
    
    // Stop the capture loop but keep data
    orch.pauseCapture?.();
    
    // v2.27: Record state change
    this._recordStateChange('paused');
    
    this._updateUI();
    this._announce('Recording paused');
    Log.info('recording', `Paused at frame ${this.frameCountAtPause}`);
    
    return true;
  }
  
  // Resume recording (continues from where paused)
  resume() {
    if (!this.canResume()) return false;
    
    const pauseTime = performance.now() - this.pausedAt;
    this.pauseDuration += pauseTime;
    this.pausedAt = null;
    this.state = 'recording';
    
    // Resume capture
    orch.resumeCapture?.();
    
    // v2.27: Record state change
    this._recordStateChange('recording');
    
    this._updateUI();
    this._announce('Recording resumed');
    Log.info('recording', `Resumed after ${(pauseTime/1000).toFixed(1)}s pause`);
    
    return true;
  }
  
  // Stop recording completely (finalizes the recording)
  stop() {
    if (!this.canStop()) return false;
    
    const container = orch?.getContainer();
    const frameCount = container?.frames?.length || 0;
    
    if (this.state === 'paused') {
      // If paused, add pause time
      this.pauseDuration += performance.now() - this.pausedAt;
    }
    
    // v2.27: Stop health monitoring
    this._stopHealthMonitoring();
    
    // Finalize recording
    this._doStop();
    
    this.state = 'stopped';
    this.hasUnsavedData = frameCount > 0;
    
    // v2.27: Record state change
    this._recordStateChange('stopped');
    
    this._updateUI();
    this._announce(`Recording stopped. ${frameCount} frames captured.`);
    
    return true;
  }
  
  // Toggle between states (Space key behavior)
  toggle() {
    switch (this.state) {
      case 'idle':
        return this.startNew();
      case 'recording':
        return this.pause();
      case 'paused':
        return this.resume();
      case 'stopped':
        return this.startNew();
      default:
        return false;
    }
  }
  
  // Double-tap or long-press to stop completely
  forceStop() {
    if (this.state === 'recording' || this.state === 'paused') {
      return this.stop();
    }
    return false;
  }
  
  // Mark as saved
  markSaved() {
    this.hasUnsavedData = false;
    this._updateUI();
  }
  
  // Get recording stats
  getStats() {
    const container = orch?.getContainer();
    return {
      state: this.state,
      frameCount: container?.frames?.length || 0,
      duration: this._getEffectiveDuration(),
      pauseDuration: this.pauseDuration,
      hasUnsavedData: this.hasUnsavedData,
      // v2.27: Additional stats
      frameRate: this._calculateFrameRate(),
      health: this._assessHealth()
    };
  }
  
  // v2.27: Record state change for history
  _recordStateChange(newState) {
    this.stateHistory.push({
      from: this.state,
      to: newState,
      timestamp: performance.now(),
      frameCount: orch?.getContainer()?.frames?.length || 0
    });
    
    // Keep last 20 state changes
    if (this.stateHistory.length > 20) {
      this.stateHistory.shift();
    }
    
    this.lastStateChange = performance.now();
  }
  
  _resetState() {
    this.pausedAt = null;
    this.pauseDuration = 0;
    this.frameCountAtPause = 0;
    this.retryCount = 0;
    this.frameRateHistory = [];
    this.lastFrameCount = 0;
    this.lastFrameCheck = 0;
    
    // Reset architecture state
    symbolicIndex?.reset?.();
    lazyCompute?.clear?.();
    perfMonLegacy?.reset?.();
    annotationManager?.clear?.();
  }
  
  _doStart() {
    this.state = 'recording';
    
    recordingSession?.start?.(orch?.mode);
    eventStore?.recordStart?.(orch?.mode);
    
    hideTimeline?.();
    
    // CRITICAL: Check if orchestrator starts recording successfully
    const orchStarted = orch?.startRecording?.();
    if (!orchStarted) {
      Log.error('recording', 'Failed to start orchestrator recording. State was: ' + orch?.getState());
      
      // v2.27: Retry logic
      if (this.retryCount < this.maxRetries) {
        this.retryCount++;
        Log.info('recording', `Retry attempt ${this.retryCount}/${this.maxRetries}`);
        
        // Small delay before retry
        setTimeout(() => {
          if (orch?.getState() === 'ready') {
            this._doStart();
          }
        }, 500);
        return false;
      }
      
      // Reset state and notify user
      this.state = 'idle';
      toast?.error?.('Recording failed to start after multiple attempts. Please refresh and try again.');
      return false;
    }
    
    // v2.27: Record state change
    this._recordStateChange('recording');
    
    document.getElementById('btn-record')?.classList.add('recording');
    document.getElementById('btn-record').innerHTML = 'â¸';
    document.getElementById('rec-badge')?.classList.add('visible');
    
    // v2.27: Show capture flash effect
    this._showCaptureFlash();
    
    // Update floating actions to show stop button
    floatingActions?.render?.();
    
    this._updateUI();
    this._announce('Recording started');
    Log.ok('recording', `Started (${orch?.mode} mode)`);
    return true;
  }
  
  // v2.27: Visual capture flash
  _showCaptureFlash() {
    const flash = document.getElementById('capture-flash');
    if (flash) {
      flash.classList.add('active');
      setTimeout(() => flash.classList.remove('active'), 150);
    }
  }
  
  _doStop() {
    const container = orch?.getContainer();
    const frameCount = container?.frames?.length || 0;
    
    recordingSession?.stop?.();
    eventStore?.recordStop?.(frameCount);
    
    // Close scenes/moments
    if (container?.currentMoment) {
      container.currentMoment.computeAttention?.();
      container.moments?.push(container.currentMoment);
    }
    if (container?.currentScene) {
      container.currentScene.close?.();
      container.scenes?.push(container.currentScene);
    }
    
    orch?.stopRecording?.();
    
    document.getElementById('btn-record')?.classList.remove('recording');
    document.getElementById('btn-record').innerHTML = 'âº';
    document.getElementById('rec-badge')?.classList.remove('visible');
    
    queryEngine = new QueryEngine(orch);
    updateTimeline?.();
    perfMonLegacy?.reset?.();
    
    if (container && frameCount > 0) {
      updateAnalytics?.(container);
      playbackEngine?.loadFromContainer?.(container);
      
      const compression = container.getCompressionStats?.();
      const scenes = container.getSceneSummary?.();
      Log.ok('recording', `Captured ${frameCount} frames, ${container.symbols?.size || 0} symbols, ${scenes?.length || 0} scenes`);
    }
  }
  
  _getEffectiveDuration() {
    const container = orch?.getContainer();
    if (!container || !container.frames || container.frames.length === 0) return 0;
    
    const totalTime = container.frames[container.frames.length - 1]?.timestamp || 0;
    return totalTime - this.pauseDuration;
  }
  
  async _showConfirmDialog() {
    return new Promise((resolve) => {
      const frameCount = orch?.getContainer()?.frames?.length || 0;
      
      const dialog = document.createElement('div');
      dialog.className = 'recording-confirm-dialog';
      dialog.innerHTML = `
        <div class="confirm-backdrop"></div>
        <div class="confirm-modal">
          <div class="confirm-icon">âš ï¸</div>
          <div class="confirm-title">Unsaved Recording</div>
          <div class="confirm-message">You have ${frameCount} unsaved frames. What would you like to do?</div>
          <div class="confirm-actions">
            <button class="confirm-btn save" data-action="save">ðŸ’¾ Save First</button>
            <button class="confirm-btn discard" data-action="discard">ðŸ—‘ï¸ Discard</button>
            <button class="confirm-btn cancel" data-action="cancel">Cancel</button>
          </div>
        </div>
      `;
      
      dialog.querySelectorAll('.confirm-btn').forEach(btn => {
        btn.onclick = () => {
          const action = btn.dataset.action;
          dialog.remove();
          resolve(action);
        };
      });
      
      dialog.querySelector('.confirm-backdrop').onclick = () => {
        dialog.remove();
        resolve('cancel');
      };
      
      document.body.appendChild(dialog);
    });
  }
  
  async _saveCurrentRecording() {
    try {
      await saveCurrentRecording?.();
      this.hasUnsavedData = false;
    } catch (err) {
      toast?.error?.('Save failed: ' + err.message);
    }
  }
  
  _updateUI() {
    // Update status dashboard
    const stateLabels = {
      'idle': { icon: 'â¸ï¸', label: 'Ready', color: '#666', hint: 'Press SPACE to record' },
      'recording': { icon: 'ðŸ”´', label: 'Recording', color: '#ff4444', hint: 'SPACE to pause, ESC to stop' },
      'paused': { icon: 'â¸ï¸', label: 'Paused', color: '#ffaa44', hint: 'SPACE to resume, ESC to stop' },
      'stopped': { icon: 'â¹ï¸', label: 'Stopped', color: '#22ddee', hint: 'P to playback, SPACE for new' }
    };
    
    const config = stateLabels[this.state];
    statusDashboard?.update?.(this.state, this.getStats().frameCount, this._getEffectiveDuration());
    
    // Update record button appearance
    const btn = document.getElementById('btn-record');
    if (btn) {
      btn.classList.toggle('recording', this.state === 'recording');
      btn.classList.toggle('paused', this.state === 'paused');
      
      if (this.state === 'recording') btn.innerHTML = 'â¸';
      else if (this.state === 'paused') btn.innerHTML = 'â–¶';
      else btn.innerHTML = 'âº';
    }
    
    // v2.26: Keep floating actions in sync with recording state
    floatingActions?.render?.();
    statusBar?.render?.();
    
    // Call external state change handler
    this.onStateChange?.(this.state, this.getStats());
  }
  
  _announce(message) {
    a11y?.announce?.(message);
    toast?.info?.(message);
  }
}

// Global recording controller instance
const recordingController = new RecordingController();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.18 â€” CLIP EDITOR
// Select, trim, split, and manage recording segments
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ClipEditor {
  constructor() {
    this.clips = [];
    this.selectedClip = null;
    this.selectionStart = null;
    this.selectionEnd = null;
    this.isSelecting = false;
    this.markers = [];
  }
  
  // Create clip from frame range
  createClip(startFrame, endFrame, name = null) {
    const container = orch?.getContainer();
    if (!container || startFrame >= endFrame) return null;
    
    const clip = {
      id: `clip_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      name: name || `Clip ${this.clips.length + 1}`,
      startFrame,
      endFrame,
      frameCount: endFrame - startFrame,
      duration: this._calculateDuration(startFrame, endFrame),
      created: Date.now(),
      tags: [],
      color: this._getClipColor(this.clips.length)
    };
    
    this.clips.push(clip);
    this._updateUI();
    toast?.success?.(`Created: ${clip.name} (${clip.frameCount} frames)`);
    
    return clip;
  }
  
  // Create clip from current selection
  createFromSelection() {
    if (this.selectionStart === null || this.selectionEnd === null) {
      toast?.warning?.('No selection. Drag on timeline to select.');
      return null;
    }
    
    const start = Math.min(this.selectionStart, this.selectionEnd);
    const end = Math.max(this.selectionStart, this.selectionEnd);
    
    return this.createClip(start, end);
  }
  
  // Set selection range
  setSelection(startFrame, endFrame) {
    this.selectionStart = startFrame;
    this.selectionEnd = endFrame;
    this._updateSelectionUI();
  }
  
  clearSelection() {
    this.selectionStart = null;
    this.selectionEnd = null;
    this.isSelecting = false;
    this._updateSelectionUI();
  }
  
  // Get frames for a clip
  getClipFrames(clipId) {
    const clip = this.clips.find(c => c.id === clipId);
    if (!clip) return [];
    
    const container = orch?.getContainer();
    if (!container) return [];
    
    return container.frames.slice(clip.startFrame, clip.endFrame);
  }
  
  // Delete clip
  deleteClip(clipId) {
    const idx = this.clips.findIndex(c => c.id === clipId);
    if (idx === -1) return false;
    
    const clip = this.clips[idx];
    this.clips.splice(idx, 1);
    
    if (this.selectedClip?.id === clipId) {
      this.selectedClip = null;
    }
    
    this._updateUI();
    toast?.info?.(`Deleted: ${clip.name}`);
    return true;
  }
  
  // Rename clip
  renameClip(clipId, newName) {
    const clip = this.clips.find(c => c.id === clipId);
    if (!clip) return false;
    
    clip.name = newName;
    this._updateUI();
    return true;
  }
  
  // Add tag to clip
  tagClip(clipId, tag) {
    const clip = this.clips.find(c => c.id === clipId);
    if (!clip) return false;
    
    if (!clip.tags.includes(tag)) {
      clip.tags.push(tag);
    }
    return true;
  }
  
  // Split clip at frame
  splitClip(clipId, atFrame) {
    const clip = this.clips.find(c => c.id === clipId);
    if (!clip || atFrame <= clip.startFrame || atFrame >= clip.endFrame) {
      return null;
    }
    
    // Create second clip
    const clip2 = this.createClip(atFrame, clip.endFrame, `${clip.name} (part 2)`);
    
    // Modify original
    clip.endFrame = atFrame;
    clip.frameCount = clip.endFrame - clip.startFrame;
    clip.duration = this._calculateDuration(clip.startFrame, clip.endFrame);
    clip.name = `${clip.name} (part 1)`;
    
    this._updateUI();
    return [clip, clip2];
  }
  
  // Merge clips
  mergeClips(clipIds) {
    const clips = clipIds.map(id => this.clips.find(c => c.id === id)).filter(Boolean);
    if (clips.length < 2) return null;
    
    // Sort by start frame
    clips.sort((a, b) => a.startFrame - b.startFrame);
    
    // Check if contiguous
    for (let i = 1; i < clips.length; i++) {
      if (clips[i].startFrame !== clips[i-1].endFrame) {
        toast?.warning?.('Clips must be contiguous to merge');
        return null;
      }
    }
    
    const merged = this.createClip(
      clips[0].startFrame,
      clips[clips.length - 1].endFrame,
      `Merged (${clips.length} clips)`
    );
    
    // Delete original clips
    clipIds.forEach(id => this.deleteClip(id));
    
    return merged;
  }
  
  // Get all clips
  getClips() {
    return [...this.clips];
  }
  
  // Select clip
  selectClip(clipId) {
    this.selectedClip = this.clips.find(c => c.id === clipId) || null;
    this._updateUI();
    return this.selectedClip;
  }
  
  // Add marker at frame
  addMarker(frame, label = '') {
    const marker = {
      id: `marker_${Date.now()}`,
      frame,
      label: label || `Marker ${this.markers.length + 1}`,
      color: '#ff8844'
    };
    this.markers.push(marker);
    return marker;
  }
  
  // Auto-detect clip boundaries (scene changes)
  autoDetectClips() {
    const container = orch?.getContainer();
    if (!container || container.scenes.length === 0) {
      toast?.info?.('No scene boundaries detected');
      return [];
    }
    
    const newClips = [];
    container.scenes.forEach((scene, i) => {
      const clip = this.createClip(
        scene.startFrame || 0,
        scene.endFrame || container.frames.length,
        `Scene ${i + 1}`
      );
      if (clip) newClips.push(clip);
    });
    
    toast?.success?.(`Created ${newClips.length} clips from scenes`);
    return newClips;
  }
  
  _calculateDuration(startFrame, endFrame) {
    const container = orch?.getContainer();
    if (!container || !container.frames[startFrame] || !container.frames[endFrame - 1]) {
      return 0;
    }
    return container.frames[endFrame - 1].timestamp - container.frames[startFrame].timestamp;
  }
  
  _getClipColor(index) {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#a29bfe', '#fd79a8'];
    return colors[index % colors.length];
  }
  
  _updateUI() {
    this.render();
  }
  
  _updateSelectionUI() {
    const timeline = document.getElementById('clip-timeline-selection');
    if (!timeline) return;
    
    if (this.selectionStart !== null && this.selectionEnd !== null) {
      const container = orch?.getContainer();
      const total = container?.frames?.length || 1;
      const start = Math.min(this.selectionStart, this.selectionEnd) / total * 100;
      const width = Math.abs(this.selectionEnd - this.selectionStart) / total * 100;
      
      timeline.style.left = `${start}%`;
      timeline.style.width = `${width}%`;
      timeline.style.display = 'block';
    } else {
      timeline.style.display = 'none';
    }
  }
  
  render() {
    const container = document.getElementById('clip-list');
    if (!container) return;
    
    if (this.clips.length === 0) {
      container.innerHTML = `
        <div class="clip-empty">
          <span>No clips created</span>
          <span class="clip-hint">Select a range on timeline and click "Create Clip"</span>
        </div>
      `;
      return;
    }
    
    container.innerHTML = this.clips.map(clip => `
      <div class="clip-item ${this.selectedClip?.id === clip.id ? 'selected' : ''}" 
           data-id="${clip.id}"
           style="--clip-color: ${clip.color}">
        <div class="clip-color-bar"></div>
        <div class="clip-info">
          <span class="clip-name">${clip.name}</span>
          <span class="clip-meta">${clip.frameCount} frames â€¢ ${(clip.duration/1000).toFixed(1)}s</span>
          ${clip.tags.length > 0 ? `<span class="clip-tags">${clip.tags.join(', ')}</span>` : ''}
        </div>
        <div class="clip-actions">
          <button class="clip-btn" onclick="clipEditor.selectClip('${clip.id}'); playbackEngine.seek(${clip.startFrame});" title="Preview">â–¶ï¸</button>
          <button class="clip-btn" onclick="exportManager.exportClip('${clip.id}')" title="Export">ðŸ“¦</button>
          <button class="clip-btn delete" onclick="clipEditor.deleteClip('${clip.id}')" title="Delete">ðŸ—‘ï¸</button>
        </div>
      </div>
    `).join('');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.18 â€” EXPORT MANAGER
// Multiple export formats: Mullu, JSON, WebM, GIF, Frames
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ExportManager {
  constructor() {
    this.formats = {
      mullu: { ext: '.mullu', mime: 'application/json', label: 'Mullu Package', icon: 'ðŸ“¦' },
      json: { ext: '.json', mime: 'application/json', label: 'JSON Data', icon: 'ðŸ“„' },
      vrc: { ext: '.vrc', mime: 'application/octet-stream', label: 'VRC Binary', icon: 'ðŸ’¾' },
      csv: { ext: '.csv', mime: 'text/csv', label: 'CSV Metadata', icon: 'ðŸ“Š' },
      report: { ext: '.md', mime: 'text/markdown', label: 'Analysis Report', icon: 'ðŸ“' }
    };
    this.isExporting = false;
    this.progress = 0;
  }
  
  // Export full recording
  async exportRecording(format = 'mullu') {
    const container = orch?.getContainer();
    if (!container || container.frames.length === 0) {
      toast?.error?.('No recording to export');
      return null;
    }
    
    this.isExporting = true;
    this.progress = 0;
    this._updateProgress();
    
    try {
      let data, filename;
      
      switch (format) {
        case 'mullu':
          data = await this._exportMullu(container);
          filename = `virecai_${Date.now()}.mullu`;
          break;
        case 'json':
          data = await this._exportJSON(container);
          filename = `virecai_${Date.now()}.json`;
          break;
        case 'vrc':
          data = await this._exportVRC(container);
          filename = `virecai_${Date.now()}.vrc`;
          break;
        case 'csv':
          data = await this._exportCSV(container);
          filename = `virecai_${Date.now()}.csv`;
          break;
        case 'report':
          data = await this._exportReport(container);
          filename = `virecai_report_${Date.now()}.md`;
          break;
        default:
          throw new Error(`Unknown format: ${format}`);
      }
      
      this._download(data, filename, this.formats[format].mime);
      toast?.success?.(`Exported: ${filename}`);
      
      return filename;
    } catch (err) {
      toast?.error?.('Export failed: ' + err.message);
      return null;
    } finally {
      this.isExporting = false;
      this.progress = 100;
      this._updateProgress();
    }
  }
  
  // Export specific clip
  async exportClip(clipId, format = 'mullu') {
    const clip = clipEditor.clips.find(c => c.id === clipId);
    if (!clip) {
      toast?.error?.('Clip not found');
      return null;
    }
    
    const frames = clipEditor.getClipFrames(clipId);
    if (frames.length === 0) {
      toast?.error?.('No frames in clip');
      return null;
    }
    
    // Create mini container for clip
    const clipContainer = {
      frames,
      symbols: new Map(),
      scenes: [],
      meta: { clipName: clip.name, originalClipId: clipId }
    };
    
    // Extract symbols used in these frames
    const container = orch?.getContainer();
    frames.forEach(f => {
      f.layers?.symbols?.forEach(s => {
        if (container.symbols.has(s.id)) {
          clipContainer.symbols.set(s.id, container.symbols.get(s.id));
        }
      });
    });
    
    return this.exportRecording(format);
  }
  
  // Export selected frames only
  async exportSelection(startFrame, endFrame, format = 'mullu') {
    const container = orch?.getContainer();
    if (!container) return null;
    
    const frames = container.frames.slice(startFrame, endFrame);
    const tempClip = { frames, symbols: new Map() };
    
    // This would use a temp container
    toast?.info?.(`Exporting frames ${startFrame}-${endFrame}...`);
    return this.exportRecording(format);
  }
  
  async _exportMullu(container) {
    this.progress = 20;
    this._updateProgress();
    
    const mulluData = {
      version: '2.18',
      type: 'virecai-recording',
      created: new Date().toISOString(),
      meta: {
        frameCount: container.frames.length,
        symbolCount: container.symbols.size,
        sceneCount: container.scenes.length,
        duration: container.frames[container.frames.length - 1]?.timestamp || 0,
        mode: container.mode
      },
      theoretical: container.getTheoreticalSummary?.() || {},
      frames: container.frames.map((f, i) => {
        if (i % 10 === 0) {
          this.progress = 20 + (i / container.frames.length) * 60;
          this._updateProgress();
        }
        return {
          id: f.id,
          timestamp: f.timestamp,
          layers: f.layers,
          causalInferences: f.causalInferences,
          theoretical: f.theoretical,
          mfidel: f.mfidel
        };
      }),
      symbols: Array.from(container.symbols.entries()).map(([id, sym]) => ({
        id,
        type: sym.type,
        occurrences: sym.occurrences,
        properties: sym.properties
      })),
      scenes: container.scenes.map(s => ({
        id: s.id,
        startFrame: s.startFrame,
        endFrame: s.endFrame,
        type: s.type,
        summary: s.summary
      })),
      clips: clipEditor.getClips()
    };
    
    this.progress = 90;
    this._updateProgress();
    
    return JSON.stringify(mulluData, null, 2);
  }
  
  async _exportJSON(container) {
    this.progress = 50;
    this._updateProgress();
    
    return JSON.stringify({
      frames: container.frames,
      symbols: Array.from(container.symbols.entries()),
      scenes: container.scenes,
      meta: container.meta
    }, null, 2);
  }
  
  async _exportVRC(container) {
    // Binary format (simplified - just JSON for now)
    return container.toVRC?.() || JSON.stringify(container.frames);
  }
  
  async _exportCSV(container) {
    this.progress = 30;
    this._updateProgress();
    
    const headers = ['frame', 'timestamp', 'symbols', 'causalInferences', 'entropy', 'score'];
    const rows = container.frames.map((f, i) => [
      i,
      f.timestamp,
      f.layers?.symbols?.length || 0,
      f.causalInferences?.length || 0,
      f.theoretical?.information?.entropy?.total?.toFixed(4) || '',
      f.theoretical?.theoreticalScore?.toFixed(2) || ''
    ]);
    
    this.progress = 80;
    this._updateProgress();
    
    return [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
  }
  
  async _exportReport(container) {
    const stats = container.getTheoreticalSummary?.() || {};
    const scenes = container.getSceneSummary?.() || [];
    
    return `# VIRECAI Recording Analysis Report

Generated: ${new Date().toLocaleString()}

## Summary

- **Frames:** ${container.frames.length}
- **Duration:** ${((container.frames[container.frames.length-1]?.timestamp || 0) / 1000).toFixed(1)}s
- **Symbols:** ${container.symbols.size}
- **Scenes:** ${scenes.length}
- **Mode:** ${container.mode}

## Theoretical Analysis

- **Average Score:** ${stats.avgScore?.toFixed(2) || 'N/A'}
- **Peak Score:** ${stats.peakScore?.toFixed(2) || 'N/A'}
- **Entropy Range:** ${stats.entropyRange?.min?.toFixed(3) || 'N/A'} - ${stats.entropyRange?.max?.toFixed(3) || 'N/A'}

## Scene Breakdown

${scenes.map((s, i) => `### Scene ${i + 1}
- Type: ${s.type || 'Unknown'}
- Frames: ${s.frameCount || 'N/A'}
- Duration: ${((s.duration || 0) / 1000).toFixed(1)}s
`).join('\n')}

## Clips

${clipEditor.getClips().map(c => `- **${c.name}:** ${c.frameCount} frames (${(c.duration/1000).toFixed(1)}s)`).join('\n') || 'No clips created'}

---
*Generated by VIRECAI v2.27*
`;
  }
  
  _download(data, filename, mimeType) {
    const blob = new Blob([data], { type: mimeType });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    
    URL.revokeObjectURL(url);
  }
  
  _updateProgress() {
    const bar = document.getElementById('export-progress-bar');
    const text = document.getElementById('export-progress-text');
    
    if (bar) bar.style.width = `${this.progress}%`;
    if (text) text.textContent = `${Math.round(this.progress)}%`;
  }
  
  getFormats() {
    return Object.entries(this.formats).map(([key, val]) => ({
      id: key,
      ...val
    }));
  }
}

// Global instances
const clipEditor = new ClipEditor();
const exportManager = new ExportManager();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.19 â€” ANNOTATION TIMELINE
// Professional timeline with markers, regions, and notes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AnnotationTimeline {
  constructor() {
    this.markers = [];
    this.regions = [];
    this.notes = new Map(); // frameIndex -> note
    this.selectedMarker = null;
    this.selectedRegion = null;
    this.isEditing = false;
    this.zoom = 1;
    this.offset = 0;
    this.onUpdate = null;
  }
  
  // Marker operations
  addMarker(frame, label = '', color = '#ff8844', type = 'point') {
    const marker = {
      id: `marker_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      frame,
      label: label || `Marker ${this.markers.length + 1}`,
      color,
      type, // 'point', 'chapter', 'important', 'todo'
      created: Date.now()
    };
    this.markers.push(marker);
    this.markers.sort((a, b) => a.frame - b.frame);
    this._triggerUpdate();
    return marker;
  }
  
  updateMarker(markerId, updates) {
    const marker = this.markers.find(m => m.id === markerId);
    if (!marker) return null;
    Object.assign(marker, updates);
    this._triggerUpdate();
    return marker;
  }
  
  deleteMarker(markerId) {
    const idx = this.markers.findIndex(m => m.id === markerId);
    if (idx === -1) return false;
    this.markers.splice(idx, 1);
    if (this.selectedMarker?.id === markerId) this.selectedMarker = null;
    this._triggerUpdate();
    return true;
  }
  
  getMarkerAt(frame, tolerance = 2) {
    return this.markers.find(m => Math.abs(m.frame - frame) <= tolerance);
  }
  
  getMarkersInRange(startFrame, endFrame) {
    return this.markers.filter(m => m.frame >= startFrame && m.frame <= endFrame);
  }
  
  // Region operations (ranges with labels)
  addRegion(startFrame, endFrame, label = '', color = '#4a90ff') {
    const region = {
      id: `region_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      startFrame,
      endFrame,
      label: label || `Region ${this.regions.length + 1}`,
      color,
      type: 'custom', // 'custom', 'scene', 'chapter', 'highlight'
      created: Date.now()
    };
    this.regions.push(region);
    this.regions.sort((a, b) => a.startFrame - b.startFrame);
    this._triggerUpdate();
    return region;
  }
  
  updateRegion(regionId, updates) {
    const region = this.regions.find(r => r.id === regionId);
    if (!region) return null;
    Object.assign(region, updates);
    this._triggerUpdate();
    return region;
  }
  
  deleteRegion(regionId) {
    const idx = this.regions.findIndex(r => r.id === regionId);
    if (idx === -1) return false;
    this.regions.splice(idx, 1);
    if (this.selectedRegion?.id === regionId) this.selectedRegion = null;
    this._triggerUpdate();
    return true;
  }
  
  getRegionAt(frame) {
    return this.regions.find(r => frame >= r.startFrame && frame <= r.endFrame);
  }
  
  // Note operations (frame-specific notes)
  addNote(frame, text) {
    const note = {
      id: `note_${Date.now()}`,
      frame,
      text,
      created: Date.now(),
      updated: Date.now()
    };
    this.notes.set(frame, note);
    this._triggerUpdate();
    return note;
  }
  
  updateNote(frame, text) {
    const note = this.notes.get(frame);
    if (!note) return this.addNote(frame, text);
    note.text = text;
    note.updated = Date.now();
    this._triggerUpdate();
    return note;
  }
  
  deleteNote(frame) {
    const deleted = this.notes.delete(frame);
    if (deleted) this._triggerUpdate();
    return deleted;
  }
  
  getNoteAt(frame) {
    return this.notes.get(frame);
  }
  
  getAllNotes() {
    return Array.from(this.notes.values()).sort((a, b) => a.frame - b.frame);
  }
  
  // Bulk operations
  clearAll() {
    this.markers = [];
    this.regions = [];
    this.notes.clear();
    this.selectedMarker = null;
    this.selectedRegion = null;
    this._triggerUpdate();
  }
  
  // Import from scenes (auto-generate regions)
  importFromScenes(scenes) {
    scenes.forEach((scene, i) => {
      this.addRegion(
        scene.startFrame || 0,
        scene.endFrame || 0,
        scene.type || `Scene ${i + 1}`,
        this._getSceneColor(scene.type)
      );
    });
    return this.regions.length;
  }
  
  // Import from clips
  importFromClips(clips) {
    clips.forEach(clip => {
      this.addRegion(
        clip.startFrame,
        clip.endFrame,
        clip.name,
        clip.color
      );
    });
    return this.regions.length;
  }
  
  // Export annotations
  exportAnnotations() {
    return {
      version: '2.19',
      exported: new Date().toISOString(),
      markers: this.markers,
      regions: this.regions,
      notes: Array.from(this.notes.entries())
    };
  }
  
  // Import annotations
  importAnnotations(data) {
    if (data.markers) this.markers = data.markers;
    if (data.regions) this.regions = data.regions;
    if (data.notes) {
      this.notes.clear();
      data.notes.forEach(([frame, note]) => this.notes.set(frame, note));
    }
    this._triggerUpdate();
  }
  
  // Timeline zoom/pan
  setZoom(level) {
    this.zoom = Math.max(0.5, Math.min(10, level));
    this._triggerUpdate();
  }
  
  setOffset(offset) {
    this.offset = Math.max(0, offset);
    this._triggerUpdate();
  }
  
  // Get statistics
  getStats() {
    return {
      markerCount: this.markers.length,
      regionCount: this.regions.length,
      noteCount: this.notes.size,
      markerTypes: this._countByType(this.markers, 'type'),
      regionTypes: this._countByType(this.regions, 'type')
    };
  }
  
  _countByType(items, field) {
    return items.reduce((acc, item) => {
      acc[item[field]] = (acc[item[field]] || 0) + 1;
      return acc;
    }, {});
  }
  
  _getSceneColor(type) {
    const colors = {
      'establishing': '#4ecdc4',
      'action': '#ff6b6b',
      'dialogue': '#45b7d1',
      'transition': '#96ceb4',
      'default': '#4a90ff'
    };
    return colors[type] || colors.default;
  }
  
  _triggerUpdate() {
    this.onUpdate?.();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.19 â€” TIMELINE RENDERER
// Renders the annotation timeline UI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TimelineRenderer {
  constructor(timeline, containerId) {
    this.timeline = timeline;
    this.containerId = containerId;
    this.canvas = null;
    this.ctx = null;
    this.width = 0;
    this.height = 0;
    this.playheadPosition = 0;
    this.isDragging = false;
    this.dragType = null; // 'playhead', 'marker', 'region-start', 'region-end'
    this.dragTarget = null;
    
    this.timeline.onUpdate = () => this.render();
  }
  
  init() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    // Create canvas
    this.canvas = document.createElement('canvas');
    this.canvas.className = 'timeline-canvas';
    this.canvas.width = container.clientWidth;
    this.canvas.height = 120;
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.ctx = this.canvas.getContext('2d');
    
    container.innerHTML = '';
    container.appendChild(this.canvas);
    
    this._setupEvents();
    this.render();
  }
  
  setPlayhead(frame) {
    this.playheadPosition = frame;
    this.render();
  }
  
  render() {
    if (!this.ctx) return;
    
    const container = orch?.getContainer();
    const totalFrames = container?.frames?.length || 100;
    
    // Clear
    this.ctx.fillStyle = '#0a0a10';
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Draw grid
    this._drawGrid(totalFrames);
    
    // Draw regions (background layer)
    this._drawRegions(totalFrames);
    
    // Draw waveform/activity (if available)
    this._drawActivity(container);
    
    // Draw markers
    this._drawMarkers(totalFrames);
    
    // Draw note indicators
    this._drawNoteIndicators(totalFrames);
    
    // Draw playhead
    this._drawPlayhead(totalFrames);
    
    // Draw time labels
    this._drawTimeLabels(totalFrames, container);
  }
  
  _drawGrid(totalFrames) {
    this.ctx.strokeStyle = '#1a1a24';
    this.ctx.lineWidth = 1;
    
    // Vertical grid lines
    const step = Math.max(1, Math.floor(totalFrames / 20));
    for (let i = 0; i <= totalFrames; i += step) {
      const x = (i / totalFrames) * this.width;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height);
      this.ctx.stroke();
    }
    
    // Horizontal lines
    [30, 60, 90].forEach(y => {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.width, y);
      this.ctx.stroke();
    });
  }
  
  _drawRegions(totalFrames) {
    this.timeline.regions.forEach(region => {
      const startX = (region.startFrame / totalFrames) * this.width;
      const endX = (region.endFrame / totalFrames) * this.width;
      const width = endX - startX;
      
      // Region background
      this.ctx.fillStyle = region.color + '30';
      this.ctx.fillRect(startX, 20, width, 70);
      
      // Region border
      this.ctx.strokeStyle = region.color;
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(startX, 20, width, 70);
      
      // Region label
      if (width > 40) {
        this.ctx.fillStyle = region.color;
        this.ctx.font = '10px monospace';
        this.ctx.fillText(region.label, startX + 4, 34, width - 8);
      }
      
      // Highlight if selected
      if (this.timeline.selectedRegion?.id === region.id) {
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(startX - 1, 19, width + 2, 72);
      }
    });
  }
  
  _drawMarkers(totalFrames) {
    const markerHeight = 15;
    
    this.timeline.markers.forEach(marker => {
      const x = (marker.frame / totalFrames) * this.width;
      
      // Marker line
      this.ctx.strokeStyle = marker.color;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.height - 20);
      this.ctx.stroke();
      
      // Marker head
      this.ctx.fillStyle = marker.color;
      this.ctx.beginPath();
      this.ctx.moveTo(x - 6, 0);
      this.ctx.lineTo(x + 6, 0);
      this.ctx.lineTo(x, markerHeight);
      this.ctx.closePath();
      this.ctx.fill();
      
      // Icon based on type
      const icons = { 'chapter': 'ðŸ“–', 'important': 'â­', 'todo': 'ðŸ“Œ', 'point': 'ðŸ“' };
      this.ctx.font = '10px sans-serif';
      this.ctx.fillText(icons[marker.type] || 'ðŸ“', x - 5, markerHeight + 12);
      
      // Highlight if selected
      if (this.timeline.selectedMarker?.id === marker.id) {
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(x, markerHeight + 8, 8, 0, Math.PI * 2);
        this.ctx.stroke();
      }
    });
  }
  
  _drawNoteIndicators(totalFrames) {
    this.ctx.fillStyle = '#ffd700';
    
    this.timeline.notes.forEach((note, frame) => {
      const x = (frame / totalFrames) * this.width;
      
      // Small note indicator at bottom
      this.ctx.beginPath();
      this.ctx.arc(x, this.height - 10, 4, 0, Math.PI * 2);
      this.ctx.fill();
    });
  }
  
  _drawPlayhead(totalFrames) {
    const x = (this.playheadPosition / totalFrames) * this.width;
    
    // Playhead line
    this.ctx.strokeStyle = '#22ddee';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(x, 0);
    this.ctx.lineTo(x, this.height);
    this.ctx.stroke();
    
    // Playhead handle
    this.ctx.fillStyle = '#22ddee';
    this.ctx.beginPath();
    this.ctx.moveTo(x - 8, this.height);
    this.ctx.lineTo(x + 8, this.height);
    this.ctx.lineTo(x, this.height - 12);
    this.ctx.closePath();
    this.ctx.fill();
  }
  
  _drawActivity(container) {
    if (!container || !container.frames.length) return;
    
    const barWidth = this.width / container.frames.length;
    
    container.frames.forEach((frame, i) => {
      const score = frame.theoretical?.theoreticalScore || 50;
      const height = (score / 100) * 40;
      const x = (i / container.frames.length) * this.width;
      
      // Activity bar
      this.ctx.fillStyle = `hsl(${180 + score * 0.6}, 70%, 50%)`;
      this.ctx.fillRect(x, 60 - height/2, Math.max(1, barWidth), height);
    });
  }
  
  _drawTimeLabels(totalFrames, container) {
    this.ctx.fillStyle = '#666';
    this.ctx.font = '9px monospace';
    
    const fps = 10;
    const duration = container?.frames?.[container.frames.length - 1]?.timestamp || totalFrames * 100;
    
    // Time labels every 20% of timeline
    for (let i = 0; i <= 5; i++) {
      const frame = Math.floor((i / 5) * totalFrames);
      const time = (frame / totalFrames) * (duration / 1000);
      const x = (i / 5) * this.width;
      
      this.ctx.fillText(`${time.toFixed(1)}s`, x + 2, this.height - 2);
    }
  }
  
  _setupEvents() {
    if (!this.canvas) return;
    
    this.canvas.addEventListener('click', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const container = orch?.getContainer();
      const totalFrames = container?.frames?.length || 100;
      const frame = Math.floor((x / this.width) * totalFrames);
      
      // Check for marker click
      const marker = this.timeline.getMarkerAt(frame, 3);
      if (marker) {
        this.timeline.selectedMarker = marker;
        this.timeline.selectedRegion = null;
        this._triggerSelect('marker', marker);
        this.render();
        return;
      }
      
      // Check for region click
      const region = this.timeline.getRegionAt(frame);
      if (region) {
        this.timeline.selectedRegion = region;
        this.timeline.selectedMarker = null;
        this._triggerSelect('region', region);
        this.render();
        return;
      }
      
      // Otherwise, move playhead
      this.playheadPosition = frame;
      playbackEngine?.seek?.(frame);
      this.render();
    });
    
    this.canvas.addEventListener('dblclick', (e) => {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const container = orch?.getContainer();
      const totalFrames = container?.frames?.length || 100;
      const frame = Math.floor((x / this.width) * totalFrames);
      
      // Double-click to add marker
      const marker = this.timeline.addMarker(frame);
      toast?.info?.(`Marker added at frame ${frame}`);
      this.render();
    });
  }
  
  _triggerSelect(type, item) {
    // Dispatch custom event
    document.dispatchEvent(new CustomEvent('timeline:select', { 
      detail: { type, item } 
    }));
  }
  
  resize() {
    const container = document.getElementById(this.containerId);
    if (!container || !this.canvas) return;
    
    this.canvas.width = container.clientWidth;
    this.width = this.canvas.width;
    this.render();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.19 â€” MARKER EDITOR PANEL
// UI for editing markers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class MarkerEditorUI {
  constructor(timeline) {
    this.timeline = timeline;
    this.markerTypes = [
      { id: 'point', label: 'Point', icon: 'ðŸ“', color: '#ff8844' },
      { id: 'chapter', label: 'Chapter', icon: 'ðŸ“–', color: '#4ecdc4' },
      { id: 'important', label: 'Important', icon: 'â­', color: '#ffd700' },
      { id: 'todo', label: 'To-Do', icon: 'ðŸ“Œ', color: '#ff6b6b' }
    ];
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const markers = this.timeline.markers;
    const selected = this.timeline.selectedMarker;
    
    container.innerHTML = `
      <div class="marker-editor">
        <div class="marker-toolbar">
          <button class="marker-add-btn" onclick="addMarkerAtCurrent()">+ Add Marker</button>
          <div class="marker-type-selector">
            ${this.markerTypes.map(t => `
              <button class="marker-type-btn ${selected?.type === t.id ? 'active' : ''}" 
                      data-type="${t.id}"
                      style="--type-color: ${t.color}"
                      onclick="setMarkerType('${t.id}')"
                      title="${t.label}">
                ${t.icon}
              </button>
            `).join('')}
          </div>
        </div>
        
        ${selected ? `
          <div class="marker-edit-form">
            <div class="marker-edit-row">
              <label>Label</label>
              <input type="text" id="marker-label-input" value="${selected.label}" 
                     onchange="updateMarkerLabel(this.value)">
            </div>
            <div class="marker-edit-row">
              <label>Frame</label>
              <input type="number" id="marker-frame-input" value="${selected.frame}"
                     onchange="updateMarkerFrame(parseInt(this.value))">
            </div>
            <div class="marker-edit-row">
              <label>Color</label>
              <input type="color" id="marker-color-input" value="${selected.color}"
                     onchange="updateMarkerColor(this.value)">
            </div>
            <div class="marker-edit-actions">
              <button class="marker-goto-btn" onclick="gotoMarker('${selected.id}')">Go To</button>
              <button class="marker-delete-btn" onclick="deleteSelectedMarker()">Delete</button>
            </div>
          </div>
        ` : `
          <div class="marker-no-selection">
            <p>No marker selected</p>
            <p class="hint">Click a marker on the timeline or double-click to create one</p>
          </div>
        `}
        
        <div class="marker-list-header">
          <span>All Markers (${markers.length})</span>
          ${markers.length > 0 ? `<button class="marker-clear-btn" onclick="clearAllMarkers()">Clear All</button>` : ''}
        </div>
        
        <div class="marker-list">
          ${markers.length === 0 ? `
            <div class="marker-empty">No markers yet</div>
          ` : markers.map(m => `
            <div class="marker-list-item ${selected?.id === m.id ? 'selected' : ''}"
                 onclick="selectMarker('${m.id}')"
                 style="--marker-color: ${m.color}">
              <span class="marker-icon">${this.markerTypes.find(t => t.id === m.type)?.icon || 'ðŸ“'}</span>
              <span class="marker-label">${m.label}</span>
              <span class="marker-frame">F${m.frame}</span>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }
}

// Global instances
const annotationTimeline = new AnnotationTimeline();
let timelineRenderer = null;
const markerEditorUI = new MarkerEditorUI(annotationTimeline);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.20 â€” UNDO/REDO MANAGER
// Complete history management with action stack
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class UndoRedoManager {
  constructor(maxHistory = 50) {
    this.undoStack = [];
    this.redoStack = [];
    this.maxHistory = maxHistory;
    this.isPerformingAction = false;
    this.onUpdate = null;
  }
  
  // Execute an action and record it
  execute(action) {
    if (this.isPerformingAction) return;
    
    try {
      this.isPerformingAction = true;
      
      // Execute the action
      const result = action.execute();
      
      // Record for undo
      this.undoStack.push(action);
      
      // Clear redo stack (new action branch)
      this.redoStack = [];
      
      // Limit history size
      if (this.undoStack.length > this.maxHistory) {
        this.undoStack.shift();
      }
      
      this._triggerUpdate();
      return result;
    } finally {
      this.isPerformingAction = false;
    }
  }
  
  // Undo last action
  undo() {
    if (!this.canUndo()) return false;
    
    try {
      this.isPerformingAction = true;
      
      const action = this.undoStack.pop();
      action.undo();
      this.redoStack.push(action);
      
      this._triggerUpdate();
      toast?.info?.(`Undo: ${action.description}`);
      return true;
    } finally {
      this.isPerformingAction = false;
    }
  }
  
  // Redo last undone action
  redo() {
    if (!this.canRedo()) return false;
    
    try {
      this.isPerformingAction = true;
      
      const action = this.redoStack.pop();
      action.execute();
      this.undoStack.push(action);
      
      this._triggerUpdate();
      toast?.info?.(`Redo: ${action.description}`);
      return true;
    } finally {
      this.isPerformingAction = false;
    }
  }
  
  canUndo() {
    return this.undoStack.length > 0;
  }
  
  canRedo() {
    return this.redoStack.length > 0;
  }
  
  // Get history for display
  getHistory() {
    return {
      undo: this.undoStack.map(a => a.description),
      redo: this.redoStack.map(a => a.description)
    };
  }
  
  // Clear all history
  clear() {
    this.undoStack = [];
    this.redoStack = [];
    this._triggerUpdate();
  }
  
  _triggerUpdate() {
    this.onUpdate?.();
  }
}

// Action factory for common operations
const Actions = {
  // Marker actions
  addMarker(timeline, frame, label, color, type) {
    let markerId = null;
    return {
      description: `Add marker "${label}"`,
      execute() {
        const marker = timeline.addMarker(frame, label, color, type);
        markerId = marker.id;
        return marker;
      },
      undo() {
        if (markerId) timeline.deleteMarker(markerId);
      }
    };
  },
  
  deleteMarker(timeline, markerId) {
    let savedMarker = null;
    return {
      description: `Delete marker`,
      execute() {
        savedMarker = timeline.markers.find(m => m.id === markerId);
        timeline.deleteMarker(markerId);
      },
      undo() {
        if (savedMarker) {
          timeline.markers.push(savedMarker);
          timeline.markers.sort((a, b) => a.frame - b.frame);
        }
      }
    };
  },
  
  updateMarker(timeline, markerId, oldValues, newValues) {
    return {
      description: `Update marker`,
      execute() {
        timeline.updateMarker(markerId, newValues);
      },
      undo() {
        timeline.updateMarker(markerId, oldValues);
      }
    };
  },
  
  // Region actions
  addRegion(timeline, startFrame, endFrame, label, color) {
    let regionId = null;
    return {
      description: `Add region "${label}"`,
      execute() {
        const region = timeline.addRegion(startFrame, endFrame, label, color);
        regionId = region.id;
        return region;
      },
      undo() {
        if (regionId) timeline.deleteRegion(regionId);
      }
    };
  },
  
  deleteRegion(timeline, regionId) {
    let savedRegion = null;
    return {
      description: `Delete region`,
      execute() {
        savedRegion = timeline.regions.find(r => r.id === regionId);
        timeline.deleteRegion(regionId);
      },
      undo() {
        if (savedRegion) {
          timeline.regions.push(savedRegion);
          timeline.regions.sort((a, b) => a.startFrame - b.startFrame);
        }
      }
    };
  },
  
  // Clip actions
  createClip(editor, startFrame, endFrame, name) {
    let clipId = null;
    return {
      description: `Create clip "${name}"`,
      execute() {
        const clip = editor.createClip(startFrame, endFrame, name);
        clipId = clip?.id;
        return clip;
      },
      undo() {
        if (clipId) editor.deleteClip(clipId);
      }
    };
  },
  
  deleteClip(editor, clipId) {
    let savedClip = null;
    return {
      description: `Delete clip`,
      execute() {
        savedClip = editor.clips.find(c => c.id === clipId);
        editor.deleteClip(clipId);
      },
      undo() {
        if (savedClip) {
          editor.clips.push(savedClip);
          editor.clips.sort((a, b) => a.startFrame - b.startFrame);
        }
      }
    };
  },
  
  // Note actions
  addNote(timeline, frame, text) {
    return {
      description: `Add note at frame ${frame}`,
      execute() {
        timeline.addNote(frame, text);
      },
      undo() {
        timeline.deleteNote(frame);
      }
    };
  },
  
  deleteNote(timeline, frame) {
    let savedNote = null;
    return {
      description: `Delete note`,
      execute() {
        savedNote = timeline.getNoteAt(frame);
        timeline.deleteNote(frame);
      },
      undo() {
        if (savedNote) timeline.addNote(frame, savedNote.text);
      }
    };
  },
  
  // Batch action (groups multiple actions)
  batch(actions, description) {
    return {
      description,
      execute() {
        actions.forEach(a => a.execute());
      },
      undo() {
        // Undo in reverse order
        [...actions].reverse().forEach(a => a.undo());
      }
    };
  }
};

// Global undo/redo manager
const undoRedo = new UndoRedoManager();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.20 â€” BATCH OPERATIONS
// Perform operations on multiple items at once
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BatchOperations {
  constructor() {
    this.selectedClips = new Set();
    this.selectedMarkers = new Set();
    this.selectedRegions = new Set();
  }
  
  // Selection management
  selectClip(clipId) { this.selectedClips.add(clipId); }
  deselectClip(clipId) { this.selectedClips.delete(clipId); }
  toggleClipSelection(clipId) {
    if (this.selectedClips.has(clipId)) this.selectedClips.delete(clipId);
    else this.selectedClips.add(clipId);
  }
  clearClipSelection() { this.selectedClips.clear(); }
  
  selectMarker(markerId) { this.selectedMarkers.add(markerId); }
  deselectMarker(markerId) { this.selectedMarkers.delete(markerId); }
  toggleMarkerSelection(markerId) {
    if (this.selectedMarkers.has(markerId)) this.selectedMarkers.delete(markerId);
    else this.selectedMarkers.add(markerId);
  }
  clearMarkerSelection() { this.selectedMarkers.clear(); }
  
  selectAll(type) {
    switch (type) {
      case 'clips':
        clipEditor.getClips().forEach(c => this.selectedClips.add(c.id));
        break;
      case 'markers':
        annotationTimeline.markers.forEach(m => this.selectedMarkers.add(m.id));
        break;
      case 'regions':
        annotationTimeline.regions.forEach(r => this.selectedRegions.add(r.id));
        break;
    }
  }
  
  // Batch delete
  deleteSelectedClips() {
    if (this.selectedClips.size === 0) {
      toast?.warning?.('No clips selected');
      return 0;
    }
    
    const actions = [...this.selectedClips].map(id => 
      Actions.deleteClip(clipEditor, id)
    );
    
    undoRedo.execute(Actions.batch(actions, `Delete ${actions.length} clips`));
    const count = this.selectedClips.size;
    this.selectedClips.clear();
    toast?.success?.(`Deleted ${count} clips`);
    return count;
  }
  
  deleteSelectedMarkers() {
    if (this.selectedMarkers.size === 0) {
      toast?.warning?.('No markers selected');
      return 0;
    }
    
    const actions = [...this.selectedMarkers].map(id => 
      Actions.deleteMarker(annotationTimeline, id)
    );
    
    undoRedo.execute(Actions.batch(actions, `Delete ${actions.length} markers`));
    const count = this.selectedMarkers.size;
    this.selectedMarkers.clear();
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    toast?.success?.(`Deleted ${count} markers`);
    return count;
  }
  
  // Batch update
  updateSelectedMarkersColor(color) {
    if (this.selectedMarkers.size === 0) return 0;
    
    const actions = [...this.selectedMarkers].map(id => {
      const marker = annotationTimeline.markers.find(m => m.id === id);
      if (!marker) return null;
      return Actions.updateMarker(annotationTimeline, id, { color: marker.color }, { color });
    }).filter(Boolean);
    
    undoRedo.execute(Actions.batch(actions, `Update ${actions.length} marker colors`));
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    return actions.length;
  }
  
  updateSelectedMarkersType(type) {
    if (this.selectedMarkers.size === 0) return 0;
    
    const actions = [...this.selectedMarkers].map(id => {
      const marker = annotationTimeline.markers.find(m => m.id === id);
      if (!marker) return null;
      return Actions.updateMarker(annotationTimeline, id, { type: marker.type }, { type });
    }).filter(Boolean);
    
    undoRedo.execute(Actions.batch(actions, `Update ${actions.length} marker types`));
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    return actions.length;
  }
  
  // Batch export
  exportSelectedClips(format = 'mullu') {
    if (this.selectedClips.size === 0) {
      toast?.warning?.('No clips selected');
      return;
    }
    
    // Export each clip
    [...this.selectedClips].forEach(async (id, i) => {
      setTimeout(() => {
        exportManager.exportClip(id, format);
      }, i * 500); // Stagger exports
    });
    
    toast?.info?.(`Exporting ${this.selectedClips.size} clips...`);
  }
  
  // Auto-generate markers at intervals
  generateMarkersAtInterval(interval, type = 'point') {
    const container = orch?.getContainer();
    if (!container || !container.frames.length) return 0;
    
    const totalFrames = container.frames.length;
    const actions = [];
    
    for (let frame = 0; frame < totalFrames; frame += interval) {
      actions.push(Actions.addMarker(
        annotationTimeline, 
        frame, 
        `Auto ${Math.floor(frame / interval) + 1}`,
        '#888888',
        type
      ));
    }
    
    undoRedo.execute(Actions.batch(actions, `Generate ${actions.length} markers`));
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    toast?.success?.(`Generated ${actions.length} markers`);
    return actions.length;
  }
  
  // Generate chapters at scene boundaries
  generateChaptersFromScenes() {
    const container = orch?.getContainer();
    if (!container || !container.scenes.length) {
      toast?.warning?.('No scenes detected');
      return 0;
    }
    
    const actions = container.scenes.map((scene, i) => 
      Actions.addMarker(
        annotationTimeline,
        scene.startFrame || 0,
        `Chapter ${i + 1}`,
        '#4ecdc4',
        'chapter'
      )
    );
    
    undoRedo.execute(Actions.batch(actions, `Generate ${actions.length} chapters`));
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    toast?.success?.(`Generated ${actions.length} chapter markers`);
    return actions.length;
  }
  
  // Get selection stats
  getSelectionStats() {
    return {
      clips: this.selectedClips.size,
      markers: this.selectedMarkers.size,
      regions: this.selectedRegions.size
    };
  }
}

// Global batch operations instance
const batchOps = new BatchOperations();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.20 â€” KEYBOARD CHEATSHEET
// Comprehensive keyboard shortcuts overlay
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class KeyboardCheatsheet {
  constructor() {
    this.isOpen = false;
    this.categories = [
      {
        name: 'Recording',
        icon: 'ðŸŽ¬',
        shortcuts: [
          { keys: ['Space'], action: 'Record / Pause / Resume' },
          { keys: ['Escape'], action: 'Stop recording' },
          { keys: ['Ctrl', 'S'], action: 'Save recording' }
        ]
      },
      {
        name: 'Playback',
        icon: 'â–¶ï¸',
        shortcuts: [
          { keys: ['P'], action: 'Open playback panel' },
          { keys: ['Space'], action: 'Play / Pause' },
          { keys: ['â†'], action: 'Previous frame' },
          { keys: ['â†’'], action: 'Next frame' },
          { keys: ['Home'], action: 'Go to start' },
          { keys: ['End'], action: 'Go to end' }
        ]
      },
      {
        name: 'Editing',
        icon: 'âœ‚ï¸',
        shortcuts: [
          { keys: ['X'], action: 'Clip editor' },
          { keys: ['Z'], action: 'Annotation timeline' },
          { keys: ['M'], action: 'Add marker' },
          { keys: ['Shift', 'N'], action: 'Frame notes' },
          { keys: ['Ctrl', 'Z'], action: 'Undo' },
          { keys: ['Ctrl', 'Y'], action: 'Redo' }
        ]
      },
      {
        name: 'Export',
        icon: 'ðŸ“¦',
        shortcuts: [
          { keys: ['Ctrl', 'E'], action: 'Export panel' },
          { keys: ['E'], action: 'Mullu exporter' }
        ]
      },
      {
        name: 'Panels',
        icon: 'ðŸ“Š',
        shortcuts: [
          { keys: ['R'], action: 'Analysis panel' },
          { keys: ['T'], action: 'Theory panel' },
          { keys: ['A'], action: 'Analytics' },
          { keys: ['C'], action: 'Compare' },
          { keys: ['S'], action: 'Symbol mesh' },
          { keys: ['D'], action: 'Causal chains' },
          { keys: ['N'], action: 'Narrative' },
          { keys: ['I'], action: 'InceptaDive' },
          { keys: ['O'], action: 'Ontology' },
          { keys: ['Q'], action: 'SQL query' },
          { keys: ['U'], action: 'Audio waveform' },
          { keys: ['J'], action: 'Motion trails' },
          { keys: ['Y'], action: 'Pattern detection' },
          { keys: ['V'], action: 'Camera settings' },
          { keys: ['G'], action: 'Data manager' }
        ]
      },
      {
        name: 'Navigation',
        icon: 'ðŸ§­',
        shortcuts: [
          { keys: ['['], action: 'Previous bookmark' },
          { keys: [']'], action: 'Next bookmark' },
          { keys: ['B'], action: 'Add bookmark' },
          { keys: ['/'], action: 'Focus query input' },
          { keys: ['Ctrl', 'K'], action: 'Command palette' }
        ]
      },
      {
        name: 'System',
        icon: 'âš™ï¸',
        shortcuts: [
          { keys: ['W'], action: 'Toggle WH mode' },
          { keys: ['L'], action: 'Cycle theme' },
          { keys: ['F1'], action: 'Help' },
          { keys: ['?'], action: 'This cheatsheet' }
        ]
      }
    ];
  }
  
  open() {
    this.isOpen = true;
    this.render();
    document.getElementById('cheatsheet-backdrop').classList.add('open');
    document.getElementById('cheatsheet-panel').classList.add('open');
    a11y?.announce?.('Keyboard shortcuts opened');
  }
  
  close() {
    this.isOpen = false;
    document.getElementById('cheatsheet-backdrop').classList.remove('open');
    document.getElementById('cheatsheet-panel').classList.remove('open');
  }
  
  toggle() {
    if (this.isOpen) this.close();
    else this.open();
  }
  
  render() {
    const container = document.getElementById('cheatsheet-content');
    if (!container) return;
    
    container.innerHTML = this.categories.map(cat => `
      <div class="cheatsheet-category">
        <div class="cheatsheet-category-header">
          <span class="cheatsheet-category-icon">${cat.icon}</span>
          <span class="cheatsheet-category-name">${cat.name}</span>
        </div>
        <div class="cheatsheet-shortcuts">
          ${cat.shortcuts.map(s => `
            <div class="cheatsheet-shortcut">
              <div class="cheatsheet-keys">
                ${s.keys.map(k => `<kbd class="cheatsheet-key">${k}</kbd>`).join('<span class="key-plus">+</span>')}
              </div>
              <span class="cheatsheet-action">${s.action}</span>
            </div>
          `).join('')}
        </div>
      </div>
    `).join('');
  }
}

// Global keyboard cheatsheet instance
const keyboardCheatsheet = new KeyboardCheatsheet();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.20 â€” HISTORY PANEL
// Visual undo/redo history
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HistoryPanel {
  constructor(undoRedoManager) {
    this.undoRedo = undoRedoManager;
    this.isOpen = false;
    
    this.undoRedo.onUpdate = () => this.render();
  }
  
  open() {
    this.isOpen = true;
    this.render();
    document.getElementById('history-backdrop').classList.add('open');
    document.getElementById('history-panel').classList.add('open');
  }
  
  close() {
    this.isOpen = false;
    document.getElementById('history-backdrop').classList.remove('open');
    document.getElementById('history-panel').classList.remove('open');
  }
  
  toggle() {
    if (this.isOpen) this.close();
    else this.open();
  }
  
  render() {
    const container = document.getElementById('history-list');
    if (!container) return;
    
    const history = this.undoRedo.getHistory();
    
    if (history.undo.length === 0 && history.redo.length === 0) {
      container.innerHTML = '<div class="history-empty">No history yet</div>';
      return;
    }
    
    let html = '';
    
    // Redo items (top - future)
    if (history.redo.length > 0) {
      html += '<div class="history-section-label">â†‘ Redo</div>';
      html += [...history.redo].reverse().map((desc, i) => `
        <div class="history-item redo" onclick="redoToPoint(${history.redo.length - i})">
          <span class="history-icon">â†º</span>
          <span class="history-desc">${desc}</span>
        </div>
      `).join('');
    }
    
    // Current state marker
    html += '<div class="history-current">â— Current State</div>';
    
    // Undo items (bottom - past)
    if (history.undo.length > 0) {
      html += '<div class="history-section-label">â†“ Undo</div>';
      html += [...history.undo].reverse().map((desc, i) => `
        <div class="history-item undo" onclick="undoToPoint(${i + 1})">
          <span class="history-icon">â†»</span>
          <span class="history-desc">${desc}</span>
        </div>
      `).join('');
    }
    
    container.innerHTML = html;
  }
}

// Global history panel instance
const historyPanel = new HistoryPanel(undoRedo);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.21 â€” PROJECT MANAGER
// Save and load complete VIRECAI projects
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ProjectManager {
  constructor() {
    this.currentProject = null;
    this.projectsKey = 'virecai_projects';
    this.autoSaveInterval = null;
    this.isDirty = false;
  }
  
  // Create new project
  createProject(name, description = '') {
    const project = {
      id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      name,
      description,
      version: '2.21',
      created: Date.now(),
      modified: Date.now(),
      settings: this._captureSettings(),
      recording: null,
      clips: [],
      markers: [],
      regions: [],
      notes: [],
      bookmarks: [],
      thumbnails: [],
      metadata: {}
    };
    
    this.currentProject = project;
    this.isDirty = false;
    return project;
  }
  
  // Save current state to project
  saveState() {
    if (!this.currentProject) {
      this.currentProject = this.createProject('Untitled Project');
    }
    
    const container = orch?.getContainer();
    
    this.currentProject.modified = Date.now();
    this.currentProject.settings = this._captureSettings();
    
    // Save recording data
    if (container && container.frames.length > 0) {
      this.currentProject.recording = {
        frameCount: container.frames.length,
        duration: container.frames[container.frames.length - 1]?.timestamp || 0,
        mode: container.mode,
        symbols: container.symbols.size,
        scenes: container.scenes.length,
        frames: container.frames.map(f => ({
          id: f.id,
          timestamp: f.timestamp,
          layers: f.layers,
          causalInferences: f.causalInferences,
          theoretical: f.theoretical,
          mfidel: f.mfidel
        }))
      };
    }
    
    // Save clips
    this.currentProject.clips = clipEditor.getClips();
    
    // Save annotations
    this.currentProject.markers = annotationTimeline.markers;
    this.currentProject.regions = annotationTimeline.regions;
    this.currentProject.notes = Array.from(annotationTimeline.notes.entries());
    
    this.isDirty = false;
    return this.currentProject;
  }
  
  // Load project state
  loadState(project) {
    this.currentProject = project;
    
    // Apply settings
    if (project.settings) {
      this._applySettings(project.settings);
    }
    
    // Load recording into container
    if (project.recording && project.recording.frames) {
      const container = orch?.getContainer();
      if (container) {
        container.frames = project.recording.frames;
        container.mode = project.recording.mode || 'standard';
      }
    }
    
    // Load clips
    if (project.clips) {
      clipEditor.clips = project.clips;
    }
    
    // Load annotations
    if (project.markers) {
      annotationTimeline.markers = project.markers;
    }
    if (project.regions) {
      annotationTimeline.regions = project.regions;
    }
    if (project.notes) {
      annotationTimeline.notes.clear();
      project.notes.forEach(([frame, note]) => {
        annotationTimeline.notes.set(frame, note);
      });
    }
    
    this.isDirty = false;
    toast?.success?.(`Loaded project: ${project.name}`);
    return project;
  }
  
  // Save project to IndexedDB
  async saveProject(project = null) {
    const proj = project || this.saveState();
    
    try {
      const projects = await this.getProjects();
      const existingIdx = projects.findIndex(p => p.id === proj.id);
      
      if (existingIdx >= 0) {
        projects[existingIdx] = proj;
      } else {
        projects.push(proj);
      }
      
      await this._saveProjects(projects);
      toast?.success?.(`Project saved: ${proj.name}`);
      return proj;
    } catch (err) {
      console.error('Failed to save project:', err);
      toast?.error?.('Failed to save project');
      return null;
    }
  }
  
  // Load project from IndexedDB
  async loadProject(projectId) {
    try {
      const projects = await this.getProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        toast?.error?.('Project not found');
        return null;
      }
      
      return this.loadState(project);
    } catch (err) {
      console.error('Failed to load project:', err);
      toast?.error?.('Failed to load project');
      return null;
    }
  }
  
  // Get all saved projects
  async getProjects() {
    try {
      const data = localStorage.getItem(this.projectsKey);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  async _saveProjects(projects) {
    localStorage.setItem(this.projectsKey, JSON.stringify(projects));
  }
  
  // Delete project
  async deleteProject(projectId) {
    try {
      const projects = await this.getProjects();
      const filtered = projects.filter(p => p.id !== projectId);
      await this._saveProjects(filtered);
      
      if (this.currentProject?.id === projectId) {
        this.currentProject = null;
      }
      
      toast?.info?.('Project deleted');
      return true;
    } catch (err) {
      console.error('Failed to delete project:', err);
      return false;
    }
  }
  
  // Export project to file
  exportProject(project = null) {
    const proj = project || this.saveState();
    const blob = new Blob([JSON.stringify(proj, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${proj.name.replace(/\s+/g, '_')}_${Date.now()}.virecai`;
    a.click();
    URL.revokeObjectURL(url);
    toast?.success?.(`Exported: ${proj.name}`);
  }
  
  // Import project from file
  async importProject(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const project = JSON.parse(e.target.result);
          project.id = `proj_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
          project.imported = Date.now();
          
          await this.saveProject(project);
          resolve(project);
        } catch (err) {
          reject(err);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
  
  // Duplicate project
  async duplicateProject(projectId) {
    const projects = await this.getProjects();
    const original = projects.find(p => p.id === projectId);
    
    if (!original) return null;
    
    const duplicate = {
      ...JSON.parse(JSON.stringify(original)),
      id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      name: `${original.name} (Copy)`,
      created: Date.now(),
      modified: Date.now()
    };
    
    await this.saveProject(duplicate);
    return duplicate;
  }
  
  // Capture current settings
  _captureSettings() {
    return {
      theme: settingsManager?.get?.('theme') || 'dark',
      mode: orch?.getContainer()?.mode || 'standard',
      whMode: orch?.getWhMode?.() || false,
      autoSave: settingsManager?.get?.('autoSave') ?? true,
      showPerf: document.getElementById('perf-badge')?.style.display !== 'none'
    };
  }
  
  // Apply settings
  _applySettings(settings) {
    if (settings.theme) {
      themeManager?.apply?.(settings.theme);
    }
    if (settings.whMode !== undefined) {
      orch?.setWhMode?.(settings.whMode);
    }
  }
  
  // Mark project as dirty (unsaved changes)
  markDirty() {
    this.isDirty = true;
  }
  
  // Check if there are unsaved changes
  hasUnsavedChanges() {
    return this.isDirty;
  }
  
  // Get project info
  getProjectInfo() {
    if (!this.currentProject) return null;
    
    return {
      id: this.currentProject.id,
      name: this.currentProject.name,
      description: this.currentProject.description,
      created: new Date(this.currentProject.created).toLocaleString(),
      modified: new Date(this.currentProject.modified).toLocaleString(),
      frameCount: this.currentProject.recording?.frameCount || 0,
      clipCount: this.currentProject.clips?.length || 0,
      markerCount: this.currentProject.markers?.length || 0,
      isDirty: this.isDirty
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.21 â€” TEMPLATE MANAGER
// Reusable project templates and presets
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TemplateManager {
  constructor() {
    this.templatesKey = 'virecai_templates';
    this.builtInTemplates = this._createBuiltInTemplates();
  }
  
  _createBuiltInTemplates() {
    return [
      {
        id: 'tpl_interview',
        name: 'Interview',
        description: 'Two-person interview with chapter markers',
        icon: 'ðŸŽ™ï¸',
        builtIn: true,
        settings: { mode: 'standard', whMode: false },
        markers: [
          { frame: 0, label: 'Introduction', type: 'chapter', color: '#4ecdc4' },
          { frame: 100, label: 'Question 1', type: 'chapter', color: '#4ecdc4' },
          { frame: 200, label: 'Question 2', type: 'chapter', color: '#4ecdc4' },
          { frame: 300, label: 'Closing', type: 'chapter', color: '#4ecdc4' }
        ],
        regions: [
          { startFrame: 0, endFrame: 100, label: 'Intro', color: '#45b7d1' }
        ]
      },
      {
        id: 'tpl_tutorial',
        name: 'Tutorial',
        description: 'Step-by-step tutorial with numbered chapters',
        icon: 'ðŸ“š',
        builtIn: true,
        settings: { mode: 'standard', whMode: true },
        markers: [
          { frame: 0, label: 'Step 1: Introduction', type: 'chapter', color: '#ff8844' },
          { frame: 50, label: 'Step 2: Setup', type: 'chapter', color: '#ff8844' },
          { frame: 100, label: 'Step 3: Main Content', type: 'chapter', color: '#ff8844' },
          { frame: 150, label: 'Step 4: Summary', type: 'chapter', color: '#ff8844' }
        ],
        regions: []
      },
      {
        id: 'tpl_presentation',
        name: 'Presentation',
        description: 'Slide-based presentation with sections',
        icon: 'ðŸ“Š',
        builtIn: true,
        settings: { mode: 'standard', whMode: false },
        markers: [
          { frame: 0, label: 'Title Slide', type: 'chapter', color: '#8855ff' },
          { frame: 30, label: 'Agenda', type: 'point', color: '#ff8844' },
          { frame: 60, label: 'Section 1', type: 'chapter', color: '#8855ff' },
          { frame: 120, label: 'Section 2', type: 'chapter', color: '#8855ff' },
          { frame: 180, label: 'Q&A', type: 'important', color: '#ffd700' }
        ],
        regions: []
      },
      {
        id: 'tpl_research',
        name: 'Research Session',
        description: 'Deep analysis with WH reasoning enabled',
        icon: 'ðŸ”¬',
        builtIn: true,
        settings: { mode: 'advanced', whMode: true },
        markers: [
          { frame: 0, label: 'Hypothesis', type: 'important', color: '#ffd700' },
          { frame: 50, label: 'Data Collection', type: 'chapter', color: '#4ecdc4' },
          { frame: 100, label: 'Analysis', type: 'chapter', color: '#4ecdc4' },
          { frame: 150, label: 'Findings', type: 'important', color: '#ffd700' }
        ],
        regions: []
      },
      {
        id: 'tpl_blank',
        name: 'Blank',
        description: 'Empty project with no presets',
        icon: 'ðŸ“„',
        builtIn: true,
        settings: { mode: 'standard', whMode: false },
        markers: [],
        regions: []
      }
    ];
  }
  
  // Get all templates (built-in + custom)
  async getTemplates() {
    const custom = await this.getCustomTemplates();
    return [...this.builtInTemplates, ...custom];
  }
  
  // Get custom templates only
  async getCustomTemplates() {
    try {
      const data = localStorage.getItem(this.templatesKey);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  async _saveCustomTemplates(templates) {
    localStorage.setItem(this.templatesKey, JSON.stringify(templates));
  }
  
  // Apply template to current project
  applyTemplate(template) {
    // Apply settings
    if (template.settings) {
      if (template.settings.mode) {
        const container = orch?.getContainer();
        if (container) container.mode = template.settings.mode;
      }
      if (template.settings.whMode !== undefined) {
        orch?.setWhMode?.(template.settings.whMode);
      }
    }
    
    // Apply markers
    if (template.markers) {
      template.markers.forEach(m => {
        annotationTimeline.addMarker(
          m.frame,
          m.label,
          m.color || '#ff8844',
          m.type || 'point'
        );
      });
    }
    
    // Apply regions
    if (template.regions) {
      template.regions.forEach(r => {
        annotationTimeline.addRegion(
          r.startFrame,
          r.endFrame,
          r.label,
          r.color || '#4a90ff'
        );
      });
    }
    
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    toast?.success?.(`Applied template: ${template.name}`);
  }
  
  // Create template from current state
  async createTemplate(name, description, icon = 'ðŸ“') {
    const template = {
      id: `tpl_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      name,
      description,
      icon,
      builtIn: false,
      created: Date.now(),
      settings: {
        mode: orch?.getContainer()?.mode || 'standard',
        whMode: orch?.getWhMode?.() || false
      },
      markers: annotationTimeline.markers.map(m => ({
        frame: m.frame,
        label: m.label,
        type: m.type,
        color: m.color
      })),
      regions: annotationTimeline.regions.map(r => ({
        startFrame: r.startFrame,
        endFrame: r.endFrame,
        label: r.label,
        color: r.color
      }))
    };
    
    const templates = await this.getCustomTemplates();
    templates.push(template);
    await this._saveCustomTemplates(templates);
    
    toast?.success?.(`Template created: ${name}`);
    return template;
  }
  
  // Delete custom template
  async deleteTemplate(templateId) {
    const templates = await this.getCustomTemplates();
    const filtered = templates.filter(t => t.id !== templateId);
    await this._saveCustomTemplates(filtered);
    toast?.info?.('Template deleted');
    return true;
  }
  
  // Export template
  exportTemplate(template) {
    const blob = new Blob([JSON.stringify(template, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${template.name.replace(/\s+/g, '_')}.virecai-template`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  // Import template
  async importTemplate(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const template = JSON.parse(e.target.result);
          template.id = `tpl_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
          template.builtIn = false;
          template.imported = Date.now();
          
          const templates = await this.getCustomTemplates();
          templates.push(template);
          await this._saveCustomTemplates(templates);
          
          toast?.success?.(`Template imported: ${template.name}`);
          resolve(template);
        } catch (err) {
          reject(err);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
}

// Global instances
const projectManager = new ProjectManager();
const templateManager = new TemplateManager();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.21 â€” PROJECT BROWSER UI
// Visual project and template browser
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ProjectBrowserUI {
  constructor() {
    this.currentTab = 'projects';
  }
  
  async render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const projects = await projectManager.getProjects();
    const templates = await templateManager.getTemplates();
    const info = projectManager.getProjectInfo();
    
    container.innerHTML = `
      <div class="project-browser">
        ${info ? `
          <div class="current-project-info">
            <div class="project-info-header">
              <span class="project-name">${info.name}</span>
              ${info.isDirty ? '<span class="unsaved-badge">â—</span>' : ''}
            </div>
            <div class="project-info-stats">
              ${info.frameCount} frames â€¢ ${info.clipCount} clips â€¢ ${info.markerCount} markers
            </div>
            <div class="project-info-actions">
              <button onclick="quickSaveProject()" class="project-action-btn primary">ðŸ’¾ Save</button>
              <button onclick="exportCurrentProject()" class="project-action-btn">ðŸ“¤ Export</button>
            </div>
          </div>
        ` : ''}
        
        <div class="project-tabs">
          <button class="project-tab ${this.currentTab === 'projects' ? 'active' : ''}" 
                  onclick="projectBrowserUI.switchTab('projects')">
            ðŸ“ Projects (${projects.length})
          </button>
          <button class="project-tab ${this.currentTab === 'templates' ? 'active' : ''}"
                  onclick="projectBrowserUI.switchTab('templates')">
            ðŸ“‹ Templates (${templates.length})
          </button>
        </div>
        
        <div class="project-content">
          ${this.currentTab === 'projects' ? this._renderProjects(projects) : this._renderTemplates(templates)}
        </div>
        
        <div class="project-footer">
          ${this.currentTab === 'projects' ? `
            <button onclick="createNewProject()" class="project-footer-btn">+ New Project</button>
            <button onclick="triggerProjectImport()" class="project-footer-btn">ðŸ“¥ Import</button>
          ` : `
            <button onclick="createTemplateFromCurrent()" class="project-footer-btn">+ Save as Template</button>
            <button onclick="triggerTemplateImport()" class="project-footer-btn">ðŸ“¥ Import</button>
          `}
        </div>
      </div>
    `;
  }
  
  _renderProjects(projects) {
    if (projects.length === 0) {
      return `
        <div class="project-empty">
          <div class="project-empty-icon">ðŸ“</div>
          <div class="project-empty-text">No saved projects</div>
          <button onclick="createNewProject()" class="project-empty-btn">Create your first project</button>
        </div>
      `;
    }
    
    return `
      <div class="project-list">
        ${projects.map(p => `
          <div class="project-card" onclick="loadProjectById('${p.id}')">
            <div class="project-card-header">
              <span class="project-card-name">${p.name}</span>
              <div class="project-card-actions">
                <button onclick="event.stopPropagation(); duplicateProject('${p.id}')" title="Duplicate">ðŸ“‹</button>
                <button onclick="event.stopPropagation(); exportProjectById('${p.id}')" title="Export">ðŸ“¤</button>
                <button onclick="event.stopPropagation(); deleteProjectById('${p.id}')" title="Delete" class="delete">ðŸ—‘ï¸</button>
              </div>
            </div>
            <div class="project-card-desc">${p.description || 'No description'}</div>
            <div class="project-card-meta">
              <span>ðŸ“… ${new Date(p.modified).toLocaleDateString()}</span>
              <span>ðŸŽžï¸ ${p.recording?.frameCount || 0} frames</span>
              <span>ðŸ“ ${p.markers?.length || 0} markers</span>
            </div>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  _renderTemplates(templates) {
    const builtIn = templates.filter(t => t.builtIn);
    const custom = templates.filter(t => !t.builtIn);
    
    return `
      <div class="template-section">
        <div class="template-section-header">Built-in Templates</div>
        <div class="template-grid">
          ${builtIn.map(t => this._renderTemplateCard(t)).join('')}
        </div>
      </div>
      
      ${custom.length > 0 ? `
        <div class="template-section">
          <div class="template-section-header">Custom Templates</div>
          <div class="template-grid">
            ${custom.map(t => this._renderTemplateCard(t, true)).join('')}
          </div>
        </div>
      ` : ''}
    `;
  }
  
  _renderTemplateCard(template, isCustom = false) {
    return `
      <div class="template-card" onclick="applyTemplateById('${template.id}')">
        <div class="template-icon">${template.icon || 'ðŸ“'}</div>
        <div class="template-name">${template.name}</div>
        <div class="template-desc">${template.description || ''}</div>
        ${isCustom ? `
          <div class="template-actions">
            <button onclick="event.stopPropagation(); deleteTemplateById('${template.id}')" title="Delete">ðŸ—‘ï¸</button>
          </div>
        ` : ''}
      </div>
    `;
  }
  
  switchTab(tab) {
    this.currentTab = tab;
    this.render('project-browser-container');
  }
}

// Global UI instance
const projectBrowserUI = new ProjectBrowserUI();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.22 â€” SHARE MANAGER
// Generate and manage share links for projects
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ShareManager {
  constructor() {
    this.sharesKey = 'virecai_shares';
    this.shareBaseUrl = 'https://virecai.mullusi.com/share/';
  }
  
  // Generate a share link for a project
  async createShare(projectId, options = {}) {
    const {
      expiresIn = 7 * 24 * 60 * 60 * 1000, // 7 days default
      allowDownload = true,
      allowComments = true,
      password = null,
      maxViews = null
    } = options;
    
    const share = {
      id: `share_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
      projectId,
      created: Date.now(),
      expires: expiresIn ? Date.now() + expiresIn : null,
      allowDownload,
      allowComments,
      password: password ? this._hashPassword(password) : null,
      maxViews,
      viewCount: 0,
      accessLog: []
    };
    
    const shares = await this.getShares();
    shares.push(share);
    await this._saveShares(shares);
    
    return {
      ...share,
      url: this.getShareUrl(share.id)
    };
  }
  
  // Get share URL
  getShareUrl(shareId) {
    return `${this.shareBaseUrl}${shareId}`;
  }
  
  // Get all shares
  async getShares() {
    try {
      const data = localStorage.getItem(this.sharesKey);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  async _saveShares(shares) {
    localStorage.setItem(this.sharesKey, JSON.stringify(shares));
  }
  
  // Get shares for a specific project
  async getSharesForProject(projectId) {
    const shares = await this.getShares();
    return shares.filter(s => s.projectId === projectId);
  }
  
  // Get a specific share
  async getShare(shareId) {
    const shares = await this.getShares();
    return shares.find(s => s.id === shareId);
  }
  
  // Update share settings
  async updateShare(shareId, updates) {
    const shares = await this.getShares();
    const idx = shares.findIndex(s => s.id === shareId);
    if (idx >= 0) {
      shares[idx] = { ...shares[idx], ...updates };
      await this._saveShares(shares);
      return shares[idx];
    }
    return null;
  }
  
  // Delete a share
  async deleteShare(shareId) {
    const shares = await this.getShares();
    const filtered = shares.filter(s => s.id !== shareId);
    await this._saveShares(filtered);
    return true;
  }
  
  // Record a view
  async recordView(shareId, viewerInfo = {}) {
    const shares = await this.getShares();
    const idx = shares.findIndex(s => s.id === shareId);
    if (idx >= 0) {
      shares[idx].viewCount++;
      shares[idx].accessLog.push({
        timestamp: Date.now(),
        ...viewerInfo
      });
      await this._saveShares(shares);
    }
  }
  
  // Check if share is valid
  async validateShare(shareId, password = null) {
    const share = await this.getShare(shareId);
    if (!share) return { valid: false, reason: 'Share not found' };
    
    if (share.expires && Date.now() > share.expires) {
      return { valid: false, reason: 'Share has expired' };
    }
    
    if (share.maxViews && share.viewCount >= share.maxViews) {
      return { valid: false, reason: 'Maximum views reached' };
    }
    
    if (share.password && this._hashPassword(password) !== share.password) {
      return { valid: false, reason: 'Invalid password' };
    }
    
    return { valid: true, share };
  }
  
  // Simple hash for password (not cryptographically secure, just for demo)
  _hashPassword(password) {
    if (!password) return null;
    let hash = 0;
    for (let i = 0; i < password.length; i++) {
      const char = password.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }
  
  // Export share as QR code data URL (simplified)
  getShareQRData(shareId) {
    const url = this.getShareUrl(shareId);
    // Return URL for QR code generation (would use a library in production)
    return url;
  }
  
  // Get share statistics
  async getShareStats(projectId) {
    const shares = await this.getSharesForProject(projectId);
    return {
      totalShares: shares.length,
      activeShares: shares.filter(s => !s.expires || Date.now() < s.expires).length,
      totalViews: shares.reduce((sum, s) => sum + s.viewCount, 0)
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.22 â€” COMMENT SYSTEM
// Frame-level comments and discussion threads
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class CommentSystem {
  constructor() {
    this.commentsKey = 'virecai_comments';
  }
  
  // Add a comment
  async addComment(projectId, comment) {
    const newComment = {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      projectId,
      frame: comment.frame || null,
      timecode: comment.timecode || null,
      text: comment.text,
      author: comment.author || 'Anonymous',
      authorColor: comment.authorColor || this._generateColor(comment.author || 'Anonymous'),
      created: Date.now(),
      edited: null,
      resolved: false,
      parentId: comment.parentId || null, // For threaded replies
      reactions: [],
      mentions: this._extractMentions(comment.text)
    };
    
    const comments = await this.getComments(projectId);
    comments.push(newComment);
    await this._saveComments(projectId, comments);
    
    return newComment;
  }
  
  // Get all comments for a project
  async getComments(projectId) {
    try {
      const data = localStorage.getItem(`${this.commentsKey}_${projectId}`);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  async _saveComments(projectId, comments) {
    localStorage.setItem(`${this.commentsKey}_${projectId}`, JSON.stringify(comments));
  }
  
  // Get comments for a specific frame
  async getCommentsAtFrame(projectId, frame) {
    const comments = await this.getComments(projectId);
    return comments.filter(c => c.frame === frame && !c.parentId);
  }
  
  // Get comment thread (comment + replies)
  async getThread(projectId, commentId) {
    const comments = await this.getComments(projectId);
    const parent = comments.find(c => c.id === commentId);
    const replies = comments.filter(c => c.parentId === commentId);
    return { parent, replies: replies.sort((a, b) => a.created - b.created) };
  }
  
  // Update a comment
  async updateComment(projectId, commentId, updates) {
    const comments = await this.getComments(projectId);
    const idx = comments.findIndex(c => c.id === commentId);
    if (idx >= 0) {
      comments[idx] = { 
        ...comments[idx], 
        ...updates,
        edited: Date.now(),
        mentions: updates.text ? this._extractMentions(updates.text) : comments[idx].mentions
      };
      await this._saveComments(projectId, comments);
      return comments[idx];
    }
    return null;
  }
  
  // Delete a comment
  async deleteComment(projectId, commentId) {
    const comments = await this.getComments(projectId);
    // Also delete replies
    const filtered = comments.filter(c => c.id !== commentId && c.parentId !== commentId);
    await this._saveComments(projectId, filtered);
    return true;
  }
  
  // Resolve/unresolve a comment
  async toggleResolved(projectId, commentId) {
    const comments = await this.getComments(projectId);
    const idx = comments.findIndex(c => c.id === commentId);
    if (idx >= 0) {
      comments[idx].resolved = !comments[idx].resolved;
      await this._saveComments(projectId, comments);
      return comments[idx];
    }
    return null;
  }
  
  // Add reaction to a comment
  async addReaction(projectId, commentId, emoji, author) {
    const comments = await this.getComments(projectId);
    const idx = comments.findIndex(c => c.id === commentId);
    if (idx >= 0) {
      const existingIdx = comments[idx].reactions.findIndex(r => r.emoji === emoji && r.author === author);
      if (existingIdx >= 0) {
        // Remove if already reacted
        comments[idx].reactions.splice(existingIdx, 1);
      } else {
        comments[idx].reactions.push({ emoji, author, timestamp: Date.now() });
      }
      await this._saveComments(projectId, comments);
      return comments[idx];
    }
    return null;
  }
  
  // Get comment statistics
  async getStats(projectId) {
    const comments = await this.getComments(projectId);
    const rootComments = comments.filter(c => !c.parentId);
    const replies = comments.filter(c => c.parentId);
    const resolved = rootComments.filter(c => c.resolved);
    
    return {
      total: comments.length,
      threads: rootComments.length,
      replies: replies.length,
      resolved: resolved.length,
      unresolved: rootComments.length - resolved.length,
      authors: [...new Set(comments.map(c => c.author))].length
    };
  }
  
  // Export comments
  exportComments(projectId) {
    return this.getComments(projectId);
  }
  
  // Import comments
  async importComments(projectId, comments) {
    const existing = await this.getComments(projectId);
    const merged = [...existing, ...comments.map(c => ({
      ...c,
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      imported: Date.now()
    }))];
    await this._saveComments(projectId, merged);
  }
  
  // Extract @mentions from text
  _extractMentions(text) {
    const matches = text.match(/@(\w+)/g);
    return matches ? matches.map(m => m.substring(1)) : [];
  }
  
  // Generate consistent color for author
  _generateColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash % 360);
    return `hsl(${hue}, 70%, 50%)`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.22 â€” COLLABORATOR MANAGER
// Manage project collaborators and permissions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class CollaboratorManager {
  constructor() {
    this.collaboratorsKey = 'virecai_collaborators';
    this.permissions = ['view', 'comment', 'edit', 'admin'];
  }
  
  // Add a collaborator
  async addCollaborator(projectId, collaborator) {
    const newCollab = {
      id: `collab_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      projectId,
      name: collaborator.name,
      email: collaborator.email || null,
      permission: collaborator.permission || 'view',
      color: collaborator.color || this._generateColor(collaborator.name),
      added: Date.now(),
      lastActive: null,
      inviteStatus: 'pending' // pending, accepted, declined
    };
    
    const collabs = await this.getCollaborators(projectId);
    collabs.push(newCollab);
    await this._saveCollaborators(projectId, collabs);
    
    return newCollab;
  }
  
  // Get all collaborators for a project
  async getCollaborators(projectId) {
    try {
      const data = localStorage.getItem(`${this.collaboratorsKey}_${projectId}`);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  async _saveCollaborators(projectId, collaborators) {
    localStorage.setItem(`${this.collaboratorsKey}_${projectId}`, JSON.stringify(collaborators));
  }
  
  // Update collaborator
  async updateCollaborator(projectId, collabId, updates) {
    const collabs = await this.getCollaborators(projectId);
    const idx = collabs.findIndex(c => c.id === collabId);
    if (idx >= 0) {
      collabs[idx] = { ...collabs[idx], ...updates };
      await this._saveCollaborators(projectId, collabs);
      return collabs[idx];
    }
    return null;
  }
  
  // Remove collaborator
  async removeCollaborator(projectId, collabId) {
    const collabs = await this.getCollaborators(projectId);
    const filtered = collabs.filter(c => c.id !== collabId);
    await this._saveCollaborators(projectId, filtered);
    return true;
  }
  
  // Change permission
  async setPermission(projectId, collabId, permission) {
    if (!this.permissions.includes(permission)) {
      return null;
    }
    return this.updateCollaborator(projectId, collabId, { permission });
  }
  
  // Check if user has permission
  async hasPermission(projectId, collabId, requiredPermission) {
    const collabs = await this.getCollaborators(projectId);
    const collab = collabs.find(c => c.id === collabId);
    if (!collab) return false;
    
    const permLevel = this.permissions.indexOf(collab.permission);
    const reqLevel = this.permissions.indexOf(requiredPermission);
    return permLevel >= reqLevel;
  }
  
  // Record activity
  async recordActivity(projectId, collabId) {
    return this.updateCollaborator(projectId, collabId, { lastActive: Date.now() });
  }
  
  // Get collaborator count
  async getCollaboratorCount(projectId) {
    const collabs = await this.getCollaborators(projectId);
    return collabs.length;
  }
  
  // Generate invite link
  generateInviteLink(projectId, permission = 'view') {
    const token = `invite_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
    return `https://virecai.mullusi.com/invite/${projectId}/${token}?p=${permission}`;
  }
  
  _generateColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash % 360);
    return `hsl(${hue}, 60%, 45%)`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.22 â€” SHARE UI
// Visual interface for sharing and collaboration
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ShareUI {
  constructor() {
    this.currentTab = 'share';
  }
  
  async render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const projectId = projectManager.currentProject?.id;
    if (!projectId) {
      container.innerHTML = '<div class="share-empty">No project loaded</div>';
      return;
    }
    
    const shares = await shareManager.getSharesForProject(projectId);
    const collabs = await collaboratorManager.getCollaborators(projectId);
    const commentStats = await commentSystem.getStats(projectId);
    
    container.innerHTML = `
      <div class="share-ui">
        <div class="share-tabs">
          <button class="share-tab ${this.currentTab === 'share' ? 'active' : ''}" 
                  onclick="shareUI.switchTab('share')">
            ðŸ”— Share Links (${shares.length})
          </button>
          <button class="share-tab ${this.currentTab === 'collaborators' ? 'active' : ''}"
                  onclick="shareUI.switchTab('collaborators')">
            ðŸ‘¥ Collaborators (${collabs.length})
          </button>
          <button class="share-tab ${this.currentTab === 'comments' ? 'active' : ''}"
                  onclick="shareUI.switchTab('comments')">
            ðŸ’¬ Comments (${commentStats.total})
          </button>
        </div>
        
        <div class="share-content">
          ${this.currentTab === 'share' ? this._renderShares(shares) : ''}
          ${this.currentTab === 'collaborators' ? this._renderCollaborators(collabs) : ''}
          ${this.currentTab === 'comments' ? this._renderComments(projectId, commentStats) : ''}
        </div>
      </div>
    `;
  }
  
  _renderShares(shares) {
    return `
      <div class="share-section">
        <div class="share-create">
          <button onclick="createNewShare()" class="share-create-btn">
            + Create Share Link
          </button>
        </div>
        
        ${shares.length === 0 ? `
          <div class="share-empty-state">
            <div class="share-empty-icon">ðŸ”—</div>
            <div class="share-empty-text">No share links yet</div>
            <div class="share-empty-hint">Create a link to share this project</div>
          </div>
        ` : `
          <div class="share-list">
            ${shares.map(s => this._renderShareCard(s)).join('')}
          </div>
        `}
      </div>
    `;
  }
  
  _renderShareCard(share) {
    const isExpired = share.expires && Date.now() > share.expires;
    const expiresText = share.expires 
      ? (isExpired ? 'Expired' : `Expires ${new Date(share.expires).toLocaleDateString()}`)
      : 'Never expires';
    
    return `
      <div class="share-card ${isExpired ? 'expired' : ''}">
        <div class="share-card-header">
          <span class="share-card-icon">${isExpired ? 'â°' : 'ðŸ”—'}</span>
          <span class="share-card-views">${share.viewCount} views</span>
        </div>
        <div class="share-card-url" onclick="copyShareUrl('${share.id}')" title="Click to copy">
          ${shareManager.getShareUrl(share.id).replace('https://', '')}
        </div>
        <div class="share-card-meta">
          <span>${expiresText}</span>
          <span>${share.allowDownload ? 'ðŸ“¥' : ''} ${share.allowComments ? 'ðŸ’¬' : ''} ${share.password ? 'ðŸ”’' : ''}</span>
        </div>
        <div class="share-card-actions">
          <button onclick="copyShareUrl('${share.id}')" class="share-action-btn">ðŸ“‹ Copy</button>
          <button onclick="deleteShareById('${share.id}')" class="share-action-btn delete">ðŸ—‘ï¸</button>
        </div>
      </div>
    `;
  }
  
  _renderCollaborators(collabs) {
    return `
      <div class="collaborator-section">
        <div class="collaborator-add">
          <button onclick="openAddCollaboratorDialog()" class="collaborator-add-btn">
            + Add Collaborator
          </button>
          <button onclick="copyInviteLink()" class="collaborator-invite-btn">
            ðŸ“¨ Copy Invite Link
          </button>
        </div>
        
        ${collabs.length === 0 ? `
          <div class="share-empty-state">
            <div class="share-empty-icon">ðŸ‘¥</div>
            <div class="share-empty-text">No collaborators yet</div>
            <div class="share-empty-hint">Invite others to view or edit this project</div>
          </div>
        ` : `
          <div class="collaborator-list">
            ${collabs.map(c => this._renderCollaboratorCard(c)).join('')}
          </div>
        `}
      </div>
    `;
  }
  
  _renderCollaboratorCard(collab) {
    const permIcons = { view: 'ðŸ‘ï¸', comment: 'ðŸ’¬', edit: 'âœï¸', admin: 'ðŸ‘‘' };
    const statusColors = { pending: '#ffaa44', accepted: '#4ecdc4', declined: '#ff6b6b' };
    
    return `
      <div class="collaborator-card">
        <div class="collaborator-avatar" style="background: ${collab.color}">
          ${collab.name.charAt(0).toUpperCase()}
        </div>
        <div class="collaborator-info">
          <div class="collaborator-name">${collab.name}</div>
          <div class="collaborator-email">${collab.email || 'No email'}</div>
        </div>
        <div class="collaborator-permission">
          <select onchange="updateCollaboratorPermission('${collab.id}', this.value)">
            <option value="view" ${collab.permission === 'view' ? 'selected' : ''}>ðŸ‘ï¸ View</option>
            <option value="comment" ${collab.permission === 'comment' ? 'selected' : ''}>ðŸ’¬ Comment</option>
            <option value="edit" ${collab.permission === 'edit' ? 'selected' : ''}>âœï¸ Edit</option>
            <option value="admin" ${collab.permission === 'admin' ? 'selected' : ''}>ðŸ‘‘ Admin</option>
          </select>
        </div>
        <div class="collaborator-status" style="color: ${statusColors[collab.inviteStatus]}">
          ${collab.inviteStatus}
        </div>
        <button onclick="removeCollaboratorById('${collab.id}')" class="collaborator-remove">âœ•</button>
      </div>
    `;
  }
  
  _renderComments(projectId, stats) {
    return `
      <div class="comments-section">
        <div class="comments-stats">
          <div class="comment-stat">
            <span class="stat-value">${stats.threads}</span>
            <span class="stat-label">Threads</span>
          </div>
          <div class="comment-stat">
            <span class="stat-value">${stats.replies}</span>
            <span class="stat-label">Replies</span>
          </div>
          <div class="comment-stat resolved">
            <span class="stat-value">${stats.resolved}</span>
            <span class="stat-label">Resolved</span>
          </div>
          <div class="comment-stat unresolved">
            <span class="stat-value">${stats.unresolved}</span>
            <span class="stat-label">Open</span>
          </div>
        </div>
        
        <div class="comments-actions">
          <button onclick="openCommentsPanel()" class="comments-view-btn">
            View All Comments
          </button>
          <button onclick="addCommentAtFrame()" class="comments-add-btn">
            + Add Comment at Frame
          </button>
        </div>
        
        <div class="comments-recent">
          <div class="comments-recent-header">Recent Activity</div>
          <div id="recent-comments-list" class="comments-recent-list">
            Loading...
          </div>
        </div>
      </div>
    `;
  }
  
  switchTab(tab) {
    this.currentTab = tab;
    this.render('share-container');
  }
  
  async loadRecentComments(projectId) {
    const comments = await commentSystem.getComments(projectId);
    const recent = comments.sort((a, b) => b.created - a.created).slice(0, 5);
    
    const list = document.getElementById('recent-comments-list');
    if (!list) return;
    
    if (recent.length === 0) {
      list.innerHTML = '<div class="no-comments">No comments yet</div>';
      return;
    }
    
    list.innerHTML = recent.map(c => `
      <div class="recent-comment" onclick="goToCommentFrame(${c.frame})">
        <div class="comment-author-badge" style="background: ${c.authorColor}">${c.author.charAt(0)}</div>
        <div class="comment-preview">
          <div class="comment-author-name">${c.author}</div>
          <div class="comment-text-preview">${c.text.substring(0, 50)}${c.text.length > 50 ? '...' : ''}</div>
        </div>
        ${c.frame !== null ? `<div class="comment-frame-badge">F${c.frame}</div>` : ''}
      </div>
    `).join('');
  }
}

// Global instances
const shareManager = new ShareManager();
const commentSystem = new CommentSystem();
const collaboratorManager = new CollaboratorManager();
const shareUI = new ShareUI();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.23 â€” GLOBAL SEARCH ENGINE
// Search across all content types with ranking
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GlobalSearchEngine {
  constructor() {
    this.searchHistory = [];
    this.maxHistory = 20;
  }
  
  // Main search function
  async search(query, options = {}) {
    const {
      types = ['projects', 'clips', 'markers', 'comments', 'frames', 'symbols'],
      projectId = null,
      filters = {},
      limit = 50,
      sortBy = 'relevance' // relevance, date, name
    } = options;
    
    const results = {
      query,
      timestamp: Date.now(),
      total: 0,
      projects: [],
      clips: [],
      markers: [],
      comments: [],
      frames: [],
      symbols: []
    };
    
    const normalizedQuery = query.toLowerCase().trim();
    if (!normalizedQuery) return results;
    
    // Add to history
    this._addToHistory(query);
    
    // Search each type
    if (types.includes('projects')) {
      results.projects = await this._searchProjects(normalizedQuery, filters);
    }
    
    if (types.includes('clips')) {
      results.clips = await this._searchClips(normalizedQuery, projectId, filters);
    }
    
    if (types.includes('markers')) {
      results.markers = await this._searchMarkers(normalizedQuery, projectId, filters);
    }
    
    if (types.includes('comments')) {
      results.comments = await this._searchComments(normalizedQuery, projectId, filters);
    }
    
    if (types.includes('frames')) {
      results.frames = this._searchFrames(normalizedQuery, filters);
    }
    
    if (types.includes('symbols')) {
      results.symbols = this._searchSymbols(normalizedQuery, filters);
    }
    
    // Calculate total
    results.total = results.projects.length + results.clips.length + 
                    results.markers.length + results.comments.length +
                    results.frames.length + results.symbols.length;
    
    // Sort results
    if (sortBy === 'date') {
      this._sortByDate(results);
    } else if (sortBy === 'name') {
      this._sortByName(results);
    }
    
    // Apply limit
    Object.keys(results).forEach(key => {
      if (Array.isArray(results[key])) {
        results[key] = results[key].slice(0, limit);
      }
    });
    
    return results;
  }
  
  // Search projects
  async _searchProjects(query, filters) {
    const projects = await projectManager.getProjects();
    return projects
      .filter(p => {
        const matchesQuery = p.name.toLowerCase().includes(query) ||
                           (p.description || '').toLowerCase().includes(query);
        const matchesDate = !filters.dateAfter || p.modified >= filters.dateAfter;
        return matchesQuery && matchesDate;
      })
      .map(p => ({
        type: 'project',
        id: p.id,
        title: p.name,
        subtitle: p.description || 'No description',
        meta: `${p.recording?.frameCount || 0} frames â€¢ ${new Date(p.modified).toLocaleDateString()}`,
        score: this._calculateScore(query, p.name, p.description),
        data: p
      }))
      .sort((a, b) => b.score - a.score);
  }
  
  // Search clips
  async _searchClips(query, projectId, filters) {
    const clips = clipEditor.getClips();
    return clips
      .filter(c => {
        const matchesQuery = c.name.toLowerCase().includes(query);
        const matchesType = !filters.clipType || c.type === filters.clipType;
        return matchesQuery && matchesType;
      })
      .map(c => ({
        type: 'clip',
        id: c.id,
        title: c.name,
        subtitle: `Frames ${c.startFrame} - ${c.endFrame}`,
        meta: `Duration: ${c.endFrame - c.startFrame} frames`,
        score: this._calculateScore(query, c.name),
        data: c
      }))
      .sort((a, b) => b.score - a.score);
  }
  
  // Search markers
  async _searchMarkers(query, projectId, filters) {
    const markers = annotationTimeline.markers;
    return markers
      .filter(m => {
        const matchesQuery = m.label.toLowerCase().includes(query);
        const matchesType = !filters.markerType || m.type === filters.markerType;
        const matchesColor = !filters.markerColor || m.color === filters.markerColor;
        return matchesQuery && matchesType && matchesColor;
      })
      .map(m => ({
        type: 'marker',
        id: m.id,
        title: m.label,
        subtitle: `Frame ${m.frame} â€¢ ${m.type}`,
        meta: `Type: ${m.type}`,
        frame: m.frame,
        score: this._calculateScore(query, m.label),
        data: m
      }))
      .sort((a, b) => b.score - a.score);
  }
  
  // Search comments
  async _searchComments(query, projectId, filters) {
    const pid = projectId || projectManager.currentProject?.id;
    if (!pid) return [];
    
    const comments = await commentSystem.getComments(pid);
    return comments
      .filter(c => {
        const matchesQuery = c.text.toLowerCase().includes(query) ||
                           c.author.toLowerCase().includes(query);
        const matchesAuthor = !filters.author || c.author === filters.author;
        const matchesResolved = filters.resolved === undefined || c.resolved === filters.resolved;
        return matchesQuery && matchesAuthor && matchesResolved;
      })
      .map(c => ({
        type: 'comment',
        id: c.id,
        title: c.text.substring(0, 50) + (c.text.length > 50 ? '...' : ''),
        subtitle: `By ${c.author}`,
        meta: c.frame !== null ? `Frame ${c.frame}` : 'General',
        frame: c.frame,
        score: this._calculateScore(query, c.text, c.author),
        data: c
      }))
      .sort((a, b) => b.score - a.score);
  }
  
  // Search frames
  _searchFrames(query, filters) {
    const container = orch?.getContainer();
    if (!container || container.frames.length === 0) return [];
    
    const results = [];
    container.frames.forEach((frame, index) => {
      // Search in layers
      const layerMatch = frame.layers?.some(l => 
        l.label?.toLowerCase().includes(query) ||
        l.type?.toLowerCase().includes(query)
      );
      
      // Search in causal inferences
      const causalMatch = frame.causalInferences?.some(ci =>
        ci.description?.toLowerCase().includes(query) ||
        ci.cause?.toLowerCase().includes(query) ||
        ci.effect?.toLowerCase().includes(query)
      );
      
      if (layerMatch || causalMatch) {
        results.push({
          type: 'frame',
          id: frame.id,
          title: `Frame ${index}`,
          subtitle: frame.layers?.map(l => l.label).join(', ') || 'No layers',
          meta: `${frame.timestamp}ms`,
          frame: index,
          score: layerMatch && causalMatch ? 2 : 1,
          data: frame
        });
      }
    });
    
    return results.slice(0, 20);
  }
  
  // Search symbols
  _searchSymbols(query, filters) {
    const container = orch?.getContainer();
    if (!container || container.symbols.size === 0) return [];
    
    const results = [];
    container.symbols.forEach((symbol, key) => {
      const matchesQuery = key.toLowerCase().includes(query) ||
                          symbol.type?.toLowerCase().includes(query) ||
                          symbol.label?.toLowerCase().includes(query);
      
      if (matchesQuery) {
        results.push({
          type: 'symbol',
          id: key,
          title: symbol.label || key,
          subtitle: `Type: ${symbol.type || 'unknown'}`,
          meta: `Count: ${symbol.count || 1}`,
          score: this._calculateScore(query, key, symbol.label, symbol.type),
          data: symbol
        });
      }
    });
    
    return results.sort((a, b) => b.score - a.score).slice(0, 20);
  }
  
  // Calculate relevance score
  _calculateScore(query, ...fields) {
    let score = 0;
    fields.forEach(field => {
      if (!field) return;
      const lower = field.toLowerCase();
      if (lower === query) score += 10; // Exact match
      else if (lower.startsWith(query)) score += 5; // Starts with
      else if (lower.includes(query)) score += 2; // Contains
    });
    return score;
  }
  
  // Sort helpers
  _sortByDate(results) {
    const sortFn = (a, b) => (b.data?.modified || b.data?.created || 0) - 
                            (a.data?.modified || a.data?.created || 0);
    Object.keys(results).forEach(key => {
      if (Array.isArray(results[key])) {
        results[key].sort(sortFn);
      }
    });
  }
  
  _sortByName(results) {
    const sortFn = (a, b) => (a.title || '').localeCompare(b.title || '');
    Object.keys(results).forEach(key => {
      if (Array.isArray(results[key])) {
        results[key].sort(sortFn);
      }
    });
  }
  
  // History management
  _addToHistory(query) {
    this.searchHistory = this.searchHistory.filter(h => h !== query);
    this.searchHistory.unshift(query);
    if (this.searchHistory.length > this.maxHistory) {
      this.searchHistory.pop();
    }
    this._saveHistory();
  }
  
  getHistory() {
    return this.searchHistory;
  }
  
  clearHistory() {
    this.searchHistory = [];
    this._saveHistory();
  }
  
  _saveHistory() {
    localStorage.setItem('virecai_search_history', JSON.stringify(this.searchHistory));
  }
  
  loadHistory() {
    try {
      const data = localStorage.getItem('virecai_search_history');
      this.searchHistory = data ? JSON.parse(data) : [];
    } catch {
      this.searchHistory = [];
    }
  }
  
  // Quick search - returns flat list
  async quickSearch(query, limit = 10) {
    const results = await this.search(query, { limit });
    const flat = [
      ...results.projects,
      ...results.clips,
      ...results.markers,
      ...results.comments,
      ...results.frames,
      ...results.symbols
    ];
    return flat.sort((a, b) => b.score - a.score).slice(0, limit);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.23 â€” FILTER MANAGER
// Manage search filters and presets
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class FilterManager {
  constructor() {
    this.activeFilters = {};
    this.filterPresets = this._getDefaultPresets();
  }
  
  _getDefaultPresets() {
    return [
      {
        id: 'recent',
        name: 'Recent (7 days)',
        icon: 'ðŸ“…',
        filters: { dateAfter: Date.now() - 7 * 24 * 60 * 60 * 1000 }
      },
      {
        id: 'chapters',
        name: 'Chapters Only',
        icon: 'ðŸ“‘',
        filters: { markerType: 'chapter' }
      },
      {
        id: 'important',
        name: 'Important Markers',
        icon: 'â­',
        filters: { markerType: 'important' }
      },
      {
        id: 'unresolved',
        name: 'Open Comments',
        icon: 'ðŸ’¬',
        filters: { resolved: false }
      },
      {
        id: 'resolved',
        name: 'Resolved Comments',
        icon: 'âœ…',
        filters: { resolved: true }
      }
    ];
  }
  
  setFilter(key, value) {
    if (value === null || value === undefined || value === '') {
      delete this.activeFilters[key];
    } else {
      this.activeFilters[key] = value;
    }
  }
  
  getFilters() {
    return { ...this.activeFilters };
  }
  
  clearFilters() {
    this.activeFilters = {};
  }
  
  applyPreset(presetId) {
    const preset = this.filterPresets.find(p => p.id === presetId);
    if (preset) {
      this.activeFilters = { ...preset.filters };
    }
  }
  
  getPresets() {
    return this.filterPresets;
  }
  
  hasActiveFilters() {
    return Object.keys(this.activeFilters).length > 0;
  }
  
  getActiveFilterCount() {
    return Object.keys(this.activeFilters).length;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.23 â€” SAVED SEARCH MANAGER
// Save and recall search queries
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SavedSearchManager {
  constructor() {
    this.storageKey = 'virecai_saved_searches';
    this.savedSearches = this._load();
  }
  
  save(name, query, filters = {}, types = []) {
    const search = {
      id: `search_${Date.now()}`,
      name,
      query,
      filters,
      types,
      created: Date.now(),
      useCount: 0
    };
    
    this.savedSearches.push(search);
    this._persist();
    return search;
  }
  
  getAll() {
    return this.savedSearches.sort((a, b) => b.useCount - a.useCount);
  }
  
  get(searchId) {
    return this.savedSearches.find(s => s.id === searchId);
  }
  
  delete(searchId) {
    this.savedSearches = this.savedSearches.filter(s => s.id !== searchId);
    this._persist();
  }
  
  incrementUseCount(searchId) {
    const search = this.get(searchId);
    if (search) {
      search.useCount++;
      this._persist();
    }
  }
  
  _load() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  _persist() {
    localStorage.setItem(this.storageKey, JSON.stringify(this.savedSearches));
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.23 â€” SEARCH UI
// Visual search interface with results
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SearchUI {
  constructor() {
    this.isOpen = false;
    this.currentQuery = '';
    this.results = null;
    this.selectedTypes = ['projects', 'clips', 'markers', 'comments'];
    this.sortBy = 'relevance';
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const history = globalSearch.getHistory();
    const presets = filterManager.getPresets();
    const saved = savedSearchManager.getAll();
    const filterCount = filterManager.getActiveFilterCount();
    
    container.innerHTML = `
      <div class="search-ui">
        <!-- Search Input -->
        <div class="search-input-container">
          <span class="search-icon">ðŸ”</span>
          <input type="text" 
                 id="global-search-input" 
                 class="search-input" 
                 placeholder="Search projects, clips, markers, comments..."
                 value="${this.currentQuery}"
                 autocomplete="off">
          ${this.currentQuery ? `
            <button class="search-clear" onclick="clearGlobalSearch()">âœ•</button>
          ` : ''}
        </div>
        
        <!-- Type Filters -->
        <div class="search-type-filters">
          ${['projects', 'clips', 'markers', 'comments', 'frames', 'symbols'].map(type => `
            <label class="search-type-filter ${this.selectedTypes.includes(type) ? 'active' : ''}">
              <input type="checkbox" 
                     ${this.selectedTypes.includes(type) ? 'checked' : ''}
                     onchange="toggleSearchType('${type}')">
              <span>${this._getTypeIcon(type)} ${type}</span>
            </label>
          `).join('')}
        </div>
        
        <!-- Filter Bar -->
        <div class="search-filter-bar">
          <div class="filter-presets">
            ${presets.map(p => `
              <button class="filter-preset-btn" onclick="applySearchPreset('${p.id}')" title="${p.name}">
                ${p.icon}
              </button>
            `).join('')}
          </div>
          <div class="filter-actions">
            ${filterCount > 0 ? `
              <span class="filter-count">${filterCount} filter${filterCount > 1 ? 's' : ''}</span>
              <button class="clear-filters-btn" onclick="clearSearchFilters()">Clear</button>
            ` : ''}
            <select class="sort-select" onchange="setSearchSort(this.value)">
              <option value="relevance" ${this.sortBy === 'relevance' ? 'selected' : ''}>Relevance</option>
              <option value="date" ${this.sortBy === 'date' ? 'selected' : ''}>Date</option>
              <option value="name" ${this.sortBy === 'name' ? 'selected' : ''}>Name</option>
            </select>
          </div>
        </div>
        
        <!-- Results / History / Saved -->
        <div class="search-content">
          ${this.results ? this._renderResults() : this._renderStartScreen(history, saved)}
        </div>
      </div>
    `;
    
    // Auto-focus input
    setTimeout(() => {
      document.getElementById('global-search-input')?.focus();
    }, 100);
  }
  
  _renderStartScreen(history, saved) {
    return `
      ${saved.length > 0 ? `
        <div class="search-section">
          <div class="search-section-header">
            <span>â­ Saved Searches</span>
          </div>
          <div class="saved-searches">
            ${saved.slice(0, 5).map(s => `
              <div class="saved-search-item" onclick="runSavedSearch('${s.id}')">
                <span class="saved-search-query">${s.query}</span>
                <span class="saved-search-name">${s.name}</span>
                <button onclick="event.stopPropagation(); deleteSavedSearch('${s.id}')" class="saved-search-delete">âœ•</button>
              </div>
            `).join('')}
          </div>
        </div>
      ` : ''}
      
      ${history.length > 0 ? `
        <div class="search-section">
          <div class="search-section-header">
            <span>ðŸ• Recent Searches</span>
            <button onclick="clearSearchHistory()" class="clear-history-btn">Clear</button>
          </div>
          <div class="search-history">
            ${history.slice(0, 8).map(h => `
              <button class="history-item" onclick="searchFromHistory('${h.replace(/'/g, "\\'")}')">${h}</button>
            `).join('')}
          </div>
        </div>
      ` : ''}
      
      ${!saved.length && !history.length ? `
        <div class="search-empty-state">
          <div class="search-empty-icon">ðŸ”</div>
          <div class="search-empty-text">Start typing to search</div>
          <div class="search-empty-hint">Search across projects, clips, markers, and comments</div>
        </div>
      ` : ''}
    `;
  }
  
  _renderResults() {
    if (!this.results || this.results.total === 0) {
      return `
        <div class="search-no-results">
          <div class="no-results-icon">ðŸ˜•</div>
          <div class="no-results-text">No results for "${this.currentQuery}"</div>
          <div class="no-results-hint">Try different keywords or remove filters</div>
        </div>
      `;
    }
    
    return `
      <div class="search-results-header">
        <span>${this.results.total} result${this.results.total !== 1 ? 's' : ''}</span>
        <button onclick="saveCurrentSearch()" class="save-search-btn">â­ Save Search</button>
      </div>
      
      <div class="search-results">
        ${this._renderResultSection('Projects', this.results.projects, 'ðŸ“')}
        ${this._renderResultSection('Clips', this.results.clips, 'ðŸŽ¬')}
        ${this._renderResultSection('Markers', this.results.markers, 'ðŸ“')}
        ${this._renderResultSection('Comments', this.results.comments, 'ðŸ’¬')}
        ${this._renderResultSection('Frames', this.results.frames, 'ðŸ–¼ï¸')}
        ${this._renderResultSection('Symbols', this.results.symbols, 'â—‰')}
      </div>
    `;
  }
  
  _renderResultSection(title, items, icon) {
    if (!items || items.length === 0) return '';
    
    return `
      <div class="result-section">
        <div class="result-section-header">
          <span>${icon} ${title}</span>
          <span class="result-count">${items.length}</span>
        </div>
        <div class="result-list">
          ${items.map(item => `
            <div class="result-item" onclick="handleSearchResult('${item.type}', '${item.id}', ${item.frame || 'null'})">
              <div class="result-item-icon">${this._getTypeIcon(item.type)}</div>
              <div class="result-item-content">
                <div class="result-item-title">${this._highlight(item.title, this.currentQuery)}</div>
                <div class="result-item-subtitle">${item.subtitle}</div>
              </div>
              <div class="result-item-meta">${item.meta}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }
  
  _highlight(text, query) {
    if (!query || !text) return text;
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }
  
  _getTypeIcon(type) {
    const icons = {
      project: 'ðŸ“',
      projects: 'ðŸ“',
      clip: 'ðŸŽ¬',
      clips: 'ðŸŽ¬',
      marker: 'ðŸ“',
      markers: 'ðŸ“',
      comment: 'ðŸ’¬',
      comments: 'ðŸ’¬',
      frame: 'ðŸ–¼ï¸',
      frames: 'ðŸ–¼ï¸',
      symbol: 'â—‰',
      symbols: 'â—‰'
    };
    return icons[type] || 'â€¢';
  }
  
  async performSearch(query) {
    this.currentQuery = query;
    
    if (!query.trim()) {
      this.results = null;
      this.render('search-container');
      return;
    }
    
    this.results = await globalSearch.search(query, {
      types: this.selectedTypes,
      filters: filterManager.getFilters(),
      sortBy: this.sortBy
    });
    
    this.render('search-container');
  }
  
  setTypes(types) {
    this.selectedTypes = types;
    if (this.currentQuery) {
      this.performSearch(this.currentQuery);
    }
  }
  
  setSortBy(sortBy) {
    this.sortBy = sortBy;
    if (this.currentQuery) {
      this.performSearch(this.currentQuery);
    }
  }
  
  clear() {
    this.currentQuery = '';
    this.results = null;
    this.render('search-container');
  }
}

// Global instances
const globalSearch = new GlobalSearchEngine();
const filterManager = new FilterManager();
const savedSearchManager = new SavedSearchManager();
const searchUI = new SearchUI();

// Initialize search history
globalSearch.loadHistory();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” SYSTEM DIAGNOSTICS
// Runtime health checks for all components
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SystemDiagnostics {
  constructor() {
    this.checks = new Map();
    this.lastResults = null;
    this.checkInterval = null;
    
    this._registerDefaultChecks();
  }
  
  _registerDefaultChecks() {
    // Core systems
    this.register('orchestrator', () => ({
      healthy: typeof orch !== 'undefined' && orch !== null,
      details: orch ? `State: ${orch.getState()}` : 'Not initialized'
    }));
    
    this.register('persistence', () => ({
      healthy: typeof persistence !== 'undefined',
      details: 'IndexedDB persistence layer'
    }));
    
    this.register('recording', () => ({
      healthy: typeof recordingController !== 'undefined',
      details: recordingController?.isRecording ? 'Active' : 'Idle'
    }));
    
    this.register('playback', () => ({
      healthy: typeof playbackEngine !== 'undefined',
      details: `Frames: ${playbackEngine?.totalFrames || 0}`
    }));
    
    // Memory check
    this.register('memory', () => {
      if (performance.memory) {
        const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
        const total = Math.round(performance.memory.totalJSHeapSize / 1048576);
        return {
          healthy: used < total * 0.9,
          details: `${used}MB / ${total}MB`
        };
      }
      return { healthy: true, details: 'Memory API not available' };
    });
    
    // Storage check
    this.register('storage', async () => {
      try {
        if (navigator.storage && navigator.storage.estimate) {
          const estimate = await navigator.storage.estimate();
          const usedMB = Math.round((estimate.usage || 0) / 1048576);
          const quotaMB = Math.round((estimate.quota || 0) / 1048576);
          const percentUsed = Math.round((estimate.usage / estimate.quota) * 100);
          return {
            healthy: percentUsed < 90,
            details: `${usedMB}MB / ${quotaMB}MB (${percentUsed}%)`
          };
        }
        return { healthy: true, details: 'Storage API not available' };
      } catch {
        return { healthy: false, details: 'Storage check failed' };
      }
    });
    
    // Data integrity
    this.register('dataIntegrity', () => {
      const container = orch?.getContainer();
      if (!container || container.frames.length === 0) {
        return { healthy: true, details: 'No data to check' };
      }
      const issues = integrityChecker?.quickCheck(container) || [];
      return {
        healthy: issues.length === 0,
        details: issues.length === 0 ? 'All frames valid' : `${issues.length} issues found`
      };
    });
    
    // Project state
    this.register('project', () => {
      const proj = projectManager?.currentProject;
      return {
        healthy: true,
        details: proj ? `${proj.name} (${proj.recording?.frameCount || 0} frames)` : 'No project loaded'
      };
    });
  }
  
  register(name, checkFn) {
    this.checks.set(name, checkFn);
  }
  
  async runAll() {
    const results = {
      timestamp: Date.now(),
      overall: 'healthy',
      checks: {}
    };
    
    for (const [name, checkFn] of this.checks) {
      try {
        const result = await checkFn();
        results.checks[name] = result;
        if (!result.healthy && results.overall === 'healthy') {
          results.overall = 'degraded';
        }
      } catch (err) {
        results.checks[name] = { healthy: false, details: `Error: ${err.message}` };
        results.overall = 'unhealthy';
      }
    }
    
    this.lastResults = results;
    return results;
  }
  
  async runCheck(name) {
    const checkFn = this.checks.get(name);
    if (!checkFn) return { healthy: false, details: 'Check not found' };
    
    try {
      return await checkFn();
    } catch (err) {
      return { healthy: false, details: `Error: ${err.message}` };
    }
  }
  
  startMonitoring(intervalMs = 30000) {
    this.stopMonitoring();
    this.checkInterval = setInterval(() => {
      this.runAll().then(results => {
        if (results.overall !== 'healthy') {
          console.warn('[Diagnostics] System health:', results.overall, results.checks);
        }
      });
    }, intervalMs);
  }
  
  stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }
  
  getReport() {
    return this.lastResults;
  }
  
  getSummary() {
    if (!this.lastResults) return 'No diagnostics run yet';
    
    const healthy = Object.values(this.lastResults.checks).filter(c => c.healthy).length;
    const total = Object.keys(this.lastResults.checks).length;
    return `System: ${this.lastResults.overall} (${healthy}/${total} checks passed)`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” COMPREHENSIVE DATA VALIDATOR
// Validate all data structures before save/load
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class DataValidator {
  constructor() {
    this.schemas = new Map();
    this._registerSchemas();
  }
  
  _registerSchemas() {
    // Frame schema
    this.schemas.set('frame', {
      required: ['id', 'timestamp', 'layers'],
      types: {
        id: 'string',
        timestamp: 'number',
        layers: 'array'
      },
      validate: (frame) => {
        const errors = [];
        if (frame.timestamp < 0) errors.push('Timestamp must be positive');
        if (!Array.isArray(frame.layers)) errors.push('Layers must be an array');
        return errors;
      }
    });
    
    // Project schema
    this.schemas.set('project', {
      required: ['id', 'name', 'version', 'created'],
      types: {
        id: 'string',
        name: 'string',
        version: 'string',
        created: 'number'
      },
      validate: (proj) => {
        const errors = [];
        if (!proj.name || proj.name.trim().length === 0) errors.push('Project name required');
        if (proj.created > Date.now()) errors.push('Created date in future');
        return errors;
      }
    });
    
    // Marker schema
    this.schemas.set('marker', {
      required: ['id', 'frame', 'label'],
      types: {
        id: 'string',
        frame: 'number',
        label: 'string'
      },
      validate: (marker) => {
        const errors = [];
        if (marker.frame < 0) errors.push('Frame must be non-negative');
        if (!marker.label || marker.label.trim().length === 0) errors.push('Label required');
        return errors;
      }
    });
    
    // Comment schema
    this.schemas.set('comment', {
      required: ['id', 'text', 'author', 'created'],
      types: {
        id: 'string',
        text: 'string',
        author: 'string',
        created: 'number'
      },
      validate: (comment) => {
        const errors = [];
        if (!comment.text || comment.text.trim().length === 0) errors.push('Comment text required');
        return errors;
      }
    });
    
    // Clip schema
    this.schemas.set('clip', {
      required: ['id', 'name', 'startFrame', 'endFrame'],
      types: {
        id: 'string',
        name: 'string',
        startFrame: 'number',
        endFrame: 'number'
      },
      validate: (clip) => {
        const errors = [];
        if (clip.startFrame < 0) errors.push('Start frame must be non-negative');
        if (clip.endFrame < clip.startFrame) errors.push('End frame must be after start frame');
        return errors;
      }
    });
    
    // Share schema
    this.schemas.set('share', {
      required: ['id', 'projectId', 'created'],
      types: {
        id: 'string',
        projectId: 'string',
        created: 'number'
      },
      validate: () => []
    });
  }
  
  validate(schemaName, data) {
    const schema = this.schemas.get(schemaName);
    if (!schema) return { valid: false, errors: [`Unknown schema: ${schemaName}`] };
    
    const errors = [];
    
    // Check required fields
    for (const field of schema.required) {
      if (data[field] === undefined || data[field] === null) {
        errors.push(`Missing required field: ${field}`);
      }
    }
    
    // Check types
    for (const [field, expectedType] of Object.entries(schema.types)) {
      if (data[field] !== undefined && data[field] !== null) {
        const actualType = Array.isArray(data[field]) ? 'array' : typeof data[field];
        if (actualType !== expectedType) {
          errors.push(`Field ${field}: expected ${expectedType}, got ${actualType}`);
        }
      }
    }
    
    // Run custom validation
    if (schema.validate && errors.length === 0) {
      errors.push(...schema.validate(data));
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  validateArray(schemaName, dataArray) {
    const results = {
      valid: true,
      totalItems: dataArray.length,
      validItems: 0,
      invalidItems: [],
      errors: []
    };
    
    dataArray.forEach((item, index) => {
      const result = this.validate(schemaName, item);
      if (result.valid) {
        results.validItems++;
      } else {
        results.valid = false;
        results.invalidItems.push(index);
        results.errors.push({ index, errors: result.errors });
      }
    });
    
    return results;
  }
  
  sanitize(schemaName, data) {
    const schema = this.schemas.get(schemaName);
    if (!schema) return data;
    
    const sanitized = { ...data };
    
    // Ensure required fields have defaults
    for (const field of schema.required) {
      if (sanitized[field] === undefined || sanitized[field] === null) {
        const expectedType = schema.types[field];
        switch (expectedType) {
          case 'string': sanitized[field] = ''; break;
          case 'number': sanitized[field] = 0; break;
          case 'array': sanitized[field] = []; break;
          case 'object': sanitized[field] = {}; break;
        }
      }
    }
    
    // Type coercion
    for (const [field, expectedType] of Object.entries(schema.types)) {
      if (sanitized[field] !== undefined) {
        try {
          switch (expectedType) {
            case 'string':
              sanitized[field] = String(sanitized[field]);
              break;
            case 'number':
              sanitized[field] = Number(sanitized[field]) || 0;
              break;
          }
        } catch { /* Keep original */ }
      }
    }
    
    return sanitized;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” AUTO-SAVE MANAGER
// Automatic saving and crash recovery
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AutoSaveManager {
  constructor() {
    this.autoSaveKey = 'virecai_autosave';
    this.recoveryKey = 'virecai_recovery';
    this.autoSaveInterval = null;
    this.lastSaveTime = 0;
    this.saveIntervalMs = 60000; // 1 minute
    this.maxBackups = 3;
    this.isDirty = false;
  }
  
  start() {
    this.stop();
    
    // Check for recovery on start
    this._checkRecovery();
    
    // Start auto-save interval
    this.autoSaveInterval = setInterval(() => {
      this.save();
    }, this.saveIntervalMs);
    
    // Save on visibility change (tab switching)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        this.save();
      }
    });
    
    // Save before unload
    window.addEventListener('beforeunload', (e) => {
      if (this.isDirty) {
        this.save();
        e.preventDefault();
        e.returnValue = 'You have unsaved changes.';
      }
    });
    
    Log.ok('autosave', 'Auto-save started');
  }
  
  stop() {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
  }
  
  markDirty() {
    this.isDirty = true;
  }
  
  markClean() {
    this.isDirty = false;
  }
  
  async save() {
    try {
      const container = orch?.getContainer();
      const project = projectManager?.currentProject;
      
      if (!container && !project) return false;
      
      const snapshot = {
        timestamp: Date.now(),
        version: 'v2.26',
        project: project ? {
          id: project.id,
          name: project.name,
          modified: project.modified
        } : null,
        recording: container ? {
          frameCount: container.frames.length,
          duration: container.duration,
          mode: container.mode
        } : null,
        state: {
          clips: clipEditor?.getClips?.()?.length || 0,
          markers: annotationTimeline?.markers?.length || 0,
          comments: 0 // Async, skip for quick save
        }
      };
      
      // Rotate backups
      const backups = this._getBackups();
      backups.unshift(snapshot);
      if (backups.length > this.maxBackups) {
        backups.pop();
      }
      
      localStorage.setItem(this.autoSaveKey, JSON.stringify(backups));
      
      // Save recovery data (full state)
      if (project && this.isDirty) {
        const recoveryData = {
          timestamp: Date.now(),
          project: projectManager.saveState()
        };
        localStorage.setItem(this.recoveryKey, JSON.stringify(recoveryData));
      }
      
      this.lastSaveTime = Date.now();
      this.isDirty = false;
      
      return true;
    } catch (err) {
      console.error('[AutoSave] Save failed:', err);
      return false;
    }
  }
  
  _getBackups() {
    try {
      const data = localStorage.getItem(this.autoSaveKey);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }
  
  _checkRecovery() {
    try {
      const data = localStorage.getItem(this.recoveryKey);
      if (!data) return;
      
      const recovery = JSON.parse(data);
      const age = Date.now() - recovery.timestamp;
      
      // Only offer recovery if less than 24 hours old
      if (age < 24 * 60 * 60 * 1000) {
        this._offerRecovery(recovery);
      } else {
        // Clear old recovery data
        localStorage.removeItem(this.recoveryKey);
      }
    } catch {
      localStorage.removeItem(this.recoveryKey);
    }
  }
  
  _offerRecovery(recovery) {
    const ageMinutes = Math.round((Date.now() - recovery.timestamp) / 60000);
    
    setTimeout(() => {
      if (confirm(`Recover unsaved work from ${ageMinutes} minutes ago?\n\nProject: ${recovery.project?.name || 'Unknown'}`)) {
        this._recover(recovery);
      } else {
        localStorage.removeItem(this.recoveryKey);
      }
    }, 1000);
  }
  
  async _recover(recovery) {
    try {
      if (recovery.project) {
        await projectManager.loadState(recovery.project);
        toast?.success?.('Work recovered successfully');
      }
      localStorage.removeItem(this.recoveryKey);
    } catch (err) {
      console.error('[AutoSave] Recovery failed:', err);
      toast?.error?.('Recovery failed');
    }
  }
  
  getLastSaveTime() {
    return this.lastSaveTime;
  }
  
  getBackups() {
    return this._getBackups();
  }
  
  clearBackups() {
    localStorage.removeItem(this.autoSaveKey);
    localStorage.removeItem(this.recoveryKey);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” MEMORY MANAGER
// Monitor and optimize memory usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class MemoryManager {
  constructor() {
    this.warningThreshold = 0.8; // 80% of available heap
    this.criticalThreshold = 0.95; // 95% of available heap
    this.lastCleanup = 0;
    this.cleanupCooldown = 10000; // 10 seconds
  }
  
  getUsage() {
    if (!performance.memory) {
      return { available: false };
    }
    
    const used = performance.memory.usedJSHeapSize;
    const total = performance.memory.totalJSHeapSize;
    const limit = performance.memory.jsHeapSizeLimit;
    
    return {
      available: true,
      usedMB: Math.round(used / 1048576),
      totalMB: Math.round(total / 1048576),
      limitMB: Math.round(limit / 1048576),
      percentUsed: Math.round((used / total) * 100),
      percentOfLimit: Math.round((used / limit) * 100)
    };
  }
  
  checkStatus() {
    const usage = this.getUsage();
    if (!usage.available) return 'unknown';
    
    const ratio = usage.percentUsed / 100;
    
    if (ratio >= this.criticalThreshold) return 'critical';
    if (ratio >= this.warningThreshold) return 'warning';
    return 'healthy';
  }
  
  shouldCleanup() {
    const status = this.checkStatus();
    const cooldownPassed = Date.now() - this.lastCleanup > this.cleanupCooldown;
    return (status === 'warning' || status === 'critical') && cooldownPassed;
  }
  
  cleanup() {
    if (!this.shouldCleanup()) return false;
    
    this.lastCleanup = Date.now();
    
    // Clear caches
    thumbnailGen?.clearCache?.();
    
    // Clear old search history (keep last 5)
    if (globalSearch?.searchHistory?.length > 5) {
      globalSearch.searchHistory = globalSearch.searchHistory.slice(0, 5);
    }
    
    // Suggest garbage collection (if available in dev tools)
    if (window.gc) {
      window.gc();
    }
    
    console.log('[Memory] Cleanup performed');
    return true;
  }
  
  monitorAndWarn() {
    const status = this.checkStatus();
    
    if (status === 'critical') {
      toast?.warning?.('Memory critically low. Consider saving and refreshing.');
      this.cleanup();
    } else if (status === 'warning') {
      this.cleanup();
    }
    
    return status;
  }
  
  getReport() {
    const usage = this.getUsage();
    const status = this.checkStatus();
    
    return {
      status,
      usage,
      lastCleanup: this.lastCleanup,
      recommendations: this._getRecommendations(status, usage)
    };
  }
  
  _getRecommendations(status, usage) {
    const recs = [];
    
    if (status === 'critical') {
      recs.push('Save your work immediately');
      recs.push('Close other browser tabs');
      recs.push('Consider splitting large recordings');
    } else if (status === 'warning') {
      recs.push('Memory usage is elevated');
      recs.push('Avoid loading additional large recordings');
    }
    
    if (usage.usedMB > 500) {
      recs.push('Consider exporting and clearing old recordings');
    }
    
    return recs;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” INTEGRITY CHECKER
// Verify data integrity for recordings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class IntegrityChecker {
  constructor() {
    this.checksPerformed = 0;
    this.issuesFound = 0;
  }
  
  // Quick check - runs fast, catches common issues
  quickCheck(container) {
    if (!container) return ['No container provided'];
    
    const issues = [];
    const frames = container.frames || [];
    
    // Check frame count
    if (frames.length === 0) {
      return ['No frames in container'];
    }
    
    // Check timestamps are sequential
    let prevTimestamp = -1;
    for (let i = 0; i < Math.min(frames.length, 100); i++) {
      const frame = frames[i];
      
      if (!frame.id) {
        issues.push(`Frame ${i}: Missing ID`);
      }
      
      if (frame.timestamp < prevTimestamp) {
        issues.push(`Frame ${i}: Non-sequential timestamp`);
      }
      prevTimestamp = frame.timestamp;
      
      if (!frame.layers || !Array.isArray(frame.layers)) {
        issues.push(`Frame ${i}: Invalid layers`);
      }
    }
    
    this.checksPerformed++;
    this.issuesFound += issues.length;
    
    return issues;
  }
  
  // Full check - comprehensive, may be slow
  fullCheck(container) {
    if (!container) return { valid: false, issues: ['No container provided'] };
    
    const issues = this.quickCheck(container);
    const frames = container.frames || [];
    
    // Check hash chain integrity
    for (let i = 1; i < frames.length; i++) {
      if (frames[i].prevHash && frames[i].prevHash !== frames[i-1].signature) {
        issues.push(`Frame ${i}: Hash chain broken`);
      }
    }
    
    // Check symbols reference valid data
    const symbolKeys = new Set(container.symbols?.keys?.() || []);
    for (let i = 0; i < frames.length; i++) {
      const frame = frames[i];
      for (const layer of (frame.layers || [])) {
        if (layer.symbolId && !symbolKeys.has(layer.symbolId)) {
          issues.push(`Frame ${i}: References unknown symbol ${layer.symbolId}`);
        }
      }
    }
    
    // Check scenes reference valid frames
    const sceneIssues = this._checkScenes(container);
    issues.push(...sceneIssues);
    
    this.checksPerformed++;
    this.issuesFound += issues.length;
    
    return {
      valid: issues.length === 0,
      issues,
      stats: {
        framesChecked: frames.length,
        symbolsChecked: symbolKeys.size,
        scenesChecked: (container.scenes || []).length
      }
    };
  }
  
  _checkScenes(container) {
    const issues = [];
    const frameCount = (container.frames || []).length;
    
    for (const scene of (container.scenes || [])) {
      if (scene.startFrame < 0 || scene.startFrame >= frameCount) {
        issues.push(`Scene "${scene.label}": Invalid start frame ${scene.startFrame}`);
      }
      if (scene.endFrame < scene.startFrame) {
        issues.push(`Scene "${scene.label}": End frame before start frame`);
      }
    }
    
    return issues;
  }
  
  // Verify export data before saving
  verifyExport(exportData, format) {
    const issues = [];
    
    if (!exportData) {
      return { valid: false, issues: ['No export data'] };
    }
    
    switch (format) {
      case 'json':
        try {
          JSON.parse(JSON.stringify(exportData));
        } catch {
          issues.push('Export data not JSON serializable');
        }
        break;
        
      case 'project':
        if (!exportData.id) issues.push('Missing project ID');
        if (!exportData.name) issues.push('Missing project name');
        if (!exportData.version) issues.push('Missing version');
        break;
    }
    
    return {
      valid: issues.length === 0,
      issues
    };
  }
  
  // Repair common issues
  repair(container) {
    if (!container) return { repaired: false, fixes: [] };
    
    const fixes = [];
    const frames = container.frames || [];
    
    // Fix missing IDs
    frames.forEach((frame, i) => {
      if (!frame.id) {
        frame.id = `frame_${i}_${Date.now()}`;
        fixes.push(`Frame ${i}: Generated ID`);
      }
    });
    
    // Fix missing layers array
    frames.forEach((frame, i) => {
      if (!frame.layers) {
        frame.layers = [];
        fixes.push(`Frame ${i}: Created empty layers array`);
      }
    });
    
    // Fix non-sequential timestamps
    let prevTimestamp = 0;
    frames.forEach((frame, i) => {
      if (frame.timestamp <= prevTimestamp && i > 0) {
        frame.timestamp = prevTimestamp + 33; // ~30fps interval
        fixes.push(`Frame ${i}: Fixed timestamp`);
      }
      prevTimestamp = frame.timestamp;
    });
    
    return {
      repaired: fixes.length > 0,
      fixes
    };
  }
  
  getStats() {
    return {
      checksPerformed: this.checksPerformed,
      issuesFound: this.issuesFound
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” STATE VALIDATOR
// Validate state machine transitions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class StateValidator {
  constructor() {
    this.validStates = ['idle', 'ready', 'recording', 'paused', 'stopped', 'playing', 'error'];
    this.validTransitions = new Map([
      ['idle', ['ready', 'error']],
      ['ready', ['recording', 'idle', 'error']],
      ['recording', ['paused', 'stopped', 'error']],
      ['paused', ['recording', 'stopped', 'error']],
      ['stopped', ['idle', 'ready', 'playing', 'error']],
      ['playing', ['paused', 'stopped', 'idle', 'error']],
      ['error', ['idle', 'ready']]
    ]);
    this.stateHistory = [];
    this.maxHistory = 50;
  }
  
  isValidState(state) {
    return this.validStates.includes(state);
  }
  
  isValidTransition(fromState, toState) {
    const allowed = this.validTransitions.get(fromState);
    return allowed ? allowed.includes(toState) : false;
  }
  
  recordTransition(fromState, toState, context = '') {
    this.stateHistory.push({
      timestamp: Date.now(),
      from: fromState,
      to: toState,
      valid: this.isValidTransition(fromState, toState),
      context
    });
    
    if (this.stateHistory.length > this.maxHistory) {
      this.stateHistory.shift();
    }
    
    if (!this.isValidTransition(fromState, toState)) {
      console.warn(`[StateValidator] Invalid transition: ${fromState} â†’ ${toState}`);
    }
  }
  
  getHistory() {
    return [...this.stateHistory];
  }
  
  getInvalidTransitions() {
    return this.stateHistory.filter(t => !t.valid);
  }
  
  getLastState() {
    if (this.stateHistory.length === 0) return null;
    return this.stateHistory[this.stateHistory.length - 1].to;
  }
  
  clearHistory() {
    this.stateHistory = [];
  }
  
  getReport() {
    const invalid = this.getInvalidTransitions();
    return {
      totalTransitions: this.stateHistory.length,
      invalidTransitions: invalid.length,
      lastState: this.getLastState(),
      recentHistory: this.stateHistory.slice(-10)
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.24 â€” API RESPONSE NORMALIZER
// Consistent API responses across all systems
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class APIResponse {
  static success(data, message = null) {
    return {
      success: true,
      data,
      message,
      error: null,
      timestamp: Date.now()
    };
  }
  
  static error(error, data = null) {
    return {
      success: false,
      data,
      message: null,
      error: typeof error === 'string' ? error : error.message,
      timestamp: Date.now()
    };
  }
  
  static paginated(items, page, pageSize, total) {
    return {
      success: true,
      data: {
        items,
        pagination: {
          page,
          pageSize,
          total,
          totalPages: Math.ceil(total / pageSize),
          hasNext: page * pageSize < total,
          hasPrev: page > 1
        }
      },
      error: null,
      timestamp: Date.now()
    };
  }
  
  static fromPromise(promise) {
    return promise
      .then(data => APIResponse.success(data))
      .catch(err => APIResponse.error(err));
  }
}

// Global hardening instances
const systemDiagnostics = new SystemDiagnostics();
const dataValidator = new DataValidator();
const autoSaveManager = new AutoSaveManager();
const memoryManager = new MemoryManager();
const integrityChecker = new IntegrityChecker();
const stateValidator = new StateValidator();

// Start auto-save after DOM ready
document.addEventListener('DOMContentLoaded', () => {
  autoSaveManager.start();
  systemDiagnostics.startMonitoring();
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.25 â€” MAIN MENU SYSTEM
// Comprehensive navigation menu for all features
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class MainMenu {
  constructor() {
    this.isOpen = false;
    this.activeSection = null;
    
    this.menuStructure = [
      {
        id: 'file',
        label: 'File',
        icon: 'ðŸ“',
        items: [
          { id: 'new-project', label: 'New Project', shortcut: 'Ctrl+N', action: 'openNewProjectDialog' },
          { id: 'open-project', label: 'Open Project', shortcut: 'Ctrl+P', action: 'openProjectBrowser' },
          { id: 'save-project', label: 'Save Project', shortcut: 'Ctrl+S', action: 'saveCurrentRecording' },
          { type: 'divider' },
          { id: 'import', label: 'Import...', action: 'showImportDialog' },
          { id: 'export', label: 'Export...', shortcut: 'Ctrl+E', action: 'openExportPanel' },
          { type: 'divider' },
          { id: 'templates', label: 'Templates', action: 'openTemplatesBrowser' }
        ]
      },
      {
        id: 'edit',
        label: 'Edit',
        icon: 'âœï¸',
        items: [
          { id: 'undo', label: 'Undo', shortcut: 'Ctrl+Z', action: 'doUndo' },
          { id: 'redo', label: 'Redo', shortcut: 'Ctrl+Y', action: 'doRedo' },
          { type: 'divider' },
          { id: 'clips', label: 'Clip Editor', shortcut: 'X', action: 'openClipEditorPanel' },
          { id: 'markers', label: 'Timeline Markers', shortcut: 'Z', action: 'openAnnotationPanel' },
          { id: 'annotations', label: 'Annotations', action: 'openAnnotationsPanel' },
          { type: 'divider' },
          { id: 'history', label: 'Edit History', shortcut: 'Ctrl+H', action: 'openHistoryPanel' }
        ]
      },
      {
        id: 'view',
        label: 'View',
        icon: 'ðŸ‘ï¸',
        items: [
          { id: 'playback', label: 'Playback', shortcut: 'P', action: 'openPlaybackPanel' },
          { id: 'compare', label: 'Compare', shortcut: 'C', action: 'openComparePanel' },
          { id: 'analytics', label: 'Analytics', shortcut: 'A', action: 'openAnalyticsPanel' },
          { type: 'divider' },
          { id: 'symbol-mesh', label: 'Symbol Mesh', shortcut: 'S', action: 'openMeshPanel' },
          { id: 'causal-chains', label: 'Causal Chains', shortcut: 'D', action: 'openChainsPanel' },
          { id: 'ontology', label: 'Ontology Browser', shortcut: 'O', action: 'openOntologyPanel' },
          { type: 'divider' },
          { id: 'audio', label: 'Audio Waveform', shortcut: 'U', action: 'openAudioPanel' },
          { id: 'motion', label: 'Motion Trajectory', shortcut: 'J', action: 'openMotionPanel' }
        ]
      },
      {
        id: 'record',
        label: 'Record',
        icon: 'âºï¸',
        items: [
          { id: 'start-record', label: 'Start Recording', shortcut: 'Space', action: 'toggleRecording' },
          { id: 'camera-settings', label: 'Camera Settings', shortcut: 'V', action: 'openCameraPanel' },
          { type: 'divider' },
          { id: 'sensors', label: 'Sensor Monitor', action: 'openSensorPanel' },
          { id: 'patterns', label: 'Pattern Detection', shortcut: 'Y', action: 'openPatternsPanel' }
        ]
      },
      {
        id: 'symbolic',
        label: 'Symbolic',
        icon: 'â—‰',
        items: [
          { id: 'query', label: 'Query Console', shortcut: 'Q', action: 'openQueryPanel' },
          { id: 'inceptadive', label: 'InceptaDive', shortcut: 'I', action: 'openDivePanel' },
          { id: 'wh-analysis', label: 'WH Analysis', shortcut: 'W', action: 'openWHPanel' },
          { type: 'divider' },
          { id: 'narrative', label: 'Narrative Generator', shortcut: 'Shift+N', action: 'openNarrativePanel' },
          { id: 'theory', label: 'Theory Analysis', shortcut: 'T', action: 'openTheoryPanel' },
          { type: 'divider' },
          { id: 'mullu-export', label: 'Mullu Export', shortcut: 'E', action: 'openMulluPanel' }
        ]
      },
      {
        id: 'collaborate',
        label: 'Collaborate',
        icon: 'ðŸ‘¥',
        items: [
          { id: 'share', label: 'Share Project', shortcut: 'Ctrl+Shift+S', action: 'openSharePanel' },
          { id: 'comments', label: 'Comments', action: 'openCommentsPanel' },
          { id: 'collaborators', label: 'Manage Team', action: 'openCollaboratorsPanel' }
        ]
      },
      {
        id: 'tools',
        label: 'Tools',
        icon: 'ðŸ”§',
        items: [
          { id: 'search', label: 'Global Search', shortcut: 'Ctrl+K', action: 'openSearchPanel' },
          { id: 'diagnostics', label: 'System Diagnostics', action: 'openDiagnosticsPanel' },
          { type: 'divider' },
          { id: 'data-manager', label: 'Data Manager', shortcut: 'G', action: 'openDataPanel' },
          { id: 'performance', label: 'Performance Monitor', action: 'togglePerfMonitor' },
          { type: 'divider' },
          { id: 'settings', label: 'Settings', action: 'openSettingsPanel' }
        ]
      },
      {
        id: 'help',
        label: 'Help',
        icon: 'â“',
        items: [
          { id: 'keyboard', label: 'Keyboard Shortcuts', shortcut: '?', action: 'toggleCheatsheet' },
          { id: 'help-overlay', label: 'Help Overlay', shortcut: 'F1', action: 'openHelpPanel' },
          { id: 'tour', label: 'Take a Tour', action: 'startTour' },
          { type: 'divider' },
          { id: 'info', label: 'System Information', action: 'openInfoPanel' },
          { id: 'about', label: 'About VIRECAI', action: 'showAboutDialog' }
        ]
      }
    ];
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="main-menu ${this.isOpen ? 'open' : ''}">
        <div class="menu-backdrop" onclick="mainMenu.close()"></div>
        <div class="menu-bar">
          ${this.menuStructure.map(section => `
            <div class="menu-section" data-section="${section.id}">
              <button class="menu-section-btn ${this.activeSection === section.id ? 'active' : ''}"
                      onclick="mainMenu.toggleSection('${section.id}')">
                <span class="menu-icon">${section.icon}</span>
                <span class="menu-label">${section.label}</span>
              </button>
              ${this.activeSection === section.id ? this._renderDropdown(section) : ''}
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }
  
  _renderDropdown(section) {
    return `
      <div class="menu-dropdown">
        ${section.items.map(item => {
          if (item.type === 'divider') {
            return '<div class="menu-divider"></div>';
          }
          return `
            <button class="menu-item" onclick="mainMenu.executeAction('${item.action}')">
              <span class="menu-item-label">${item.label}</span>
              ${item.shortcut ? `<span class="menu-item-shortcut">${item.shortcut}</span>` : ''}
            </button>
          `;
        }).join('')}
      </div>
    `;
  }
  
  toggle() {
    this.isOpen = !this.isOpen;
    if (this.isOpen && !this.activeSection) {
      // Auto-select first section when opening
      this.activeSection = 'file';
    }
    if (!this.isOpen) {
      this.activeSection = null;
    }
    this.render('main-menu-container');
  }
  
  toggleSection(sectionId) {
    // Keep menu open when switching sections
    this.isOpen = true;
    if (this.activeSection === sectionId) {
      this.activeSection = null;
    } else {
      this.activeSection = sectionId;
    }
    this.render('main-menu-container');
  }
  
  close() {
    this.isOpen = false;
    this.activeSection = null;
    this.render('main-menu-container');
  }
  
  executeAction(actionName) {
    this.close();
    
    if (typeof window[actionName] === 'function') {
      window[actionName]();
    } else {
      console.warn(`[MainMenu] Action not found: ${actionName}`);
      toast?.info?.(`Action: ${actionName}`);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.25 â€” INFORMATION PANEL
// System information and status display
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class InfoPanel {
  constructor() {
    this.version = 'v2.26';
    this.buildDate = '2025-12-23';
    this.codename = 'Mullu Symbolic Intelligence';
  }
  
  async getSystemInfo() {
    const memory = memoryManager.getUsage();
    const diagnostics = await systemDiagnostics.runAll();
    const project = projectManager?.currentProject;
    const container = orch?.getContainer();
    
    return {
      version: {
        number: this.version,
        build: this.buildDate,
        codename: this.codename
      },
      system: {
        status: diagnostics.overall,
        checks: diagnostics.checks,
        memory: memory
      },
      project: project ? {
        name: project.name,
        id: project.id,
        created: new Date(project.created).toLocaleDateString(),
        modified: new Date(project.modified).toLocaleString(),
        isDirty: project.isDirty
      } : null,
      recording: container ? {
        frames: container.frames.length,
        duration: container.duration,
        symbols: container.symbols?.size || 0,
        scenes: (container.scenes || []).length,
        mode: container.mode
      } : null,
      stats: await this._getStats()
    };
  }
  
  async _getStats() {
    const projects = await projectManager?.getProjects() || [];
    const clips = clipEditor?.getClips() || [];
    const markers = annotationTimeline?.markers || [];
    
    return {
      totalProjects: projects.length,
      totalClips: clips.length,
      totalMarkers: markers.length,
      searchHistory: globalSearch?.searchHistory?.length || 0,
      savedSearches: savedSearchManager?.getAll()?.length || 0
    };
  }
  
  async render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const info = await this.getSystemInfo();
    
    container.innerHTML = `
      <div class="info-panel-content">
        <!-- Version Section -->
        <div class="info-section">
          <div class="info-section-header">
            <span class="info-icon">â—‰</span>
            <span>VIRECAI</span>
          </div>
          <div class="info-grid">
            <div class="info-item">
              <span class="info-label">Version</span>
              <span class="info-value">${info.version.number}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Build</span>
              <span class="info-value">${info.version.build}</span>
            </div>
            <div class="info-item full-width">
              <span class="info-label">Codename</span>
              <span class="info-value">${info.version.codename}</span>
            </div>
          </div>
        </div>
        
        <!-- System Health -->
        <div class="info-section">
          <div class="info-section-header">
            <span class="info-icon">${info.system.status === 'healthy' ? 'âœ“' : 'âš '}</span>
            <span>System Health</span>
            <span class="info-badge ${info.system.status}">${info.system.status}</span>
          </div>
          <div class="info-checks">
            ${Object.entries(info.system.checks).map(([name, check]) => `
              <div class="info-check ${check.healthy ? 'ok' : 'error'}">
                <span class="check-icon">${check.healthy ? 'âœ“' : 'âœ—'}</span>
                <span class="check-name">${name}</span>
                <span class="check-detail">${check.details}</span>
              </div>
            `).join('')}
          </div>
        </div>
        
        <!-- Memory -->
        ${info.system.memory.available ? `
          <div class="info-section">
            <div class="info-section-header">
              <span class="info-icon">ðŸ’¾</span>
              <span>Memory Usage</span>
            </div>
            <div class="info-memory">
              <div class="memory-bar">
                <div class="memory-fill" style="width: ${info.system.memory.percentUsed}%"></div>
              </div>
              <div class="memory-stats">
                <span>${info.system.memory.usedMB} MB used</span>
                <span>${info.system.memory.totalMB} MB allocated</span>
              </div>
            </div>
          </div>
        ` : ''}
        
        <!-- Current Project -->
        ${info.project ? `
          <div class="info-section">
            <div class="info-section-header">
              <span class="info-icon">ðŸ“</span>
              <span>Current Project</span>
              ${info.project.isDirty ? '<span class="info-badge warning">Unsaved</span>' : ''}
            </div>
            <div class="info-grid">
              <div class="info-item full-width">
                <span class="info-label">Name</span>
                <span class="info-value">${info.project.name}</span>
              </div>
              <div class="info-item">
                <span class="info-label">Created</span>
                <span class="info-value">${info.project.created}</span>
              </div>
              <div class="info-item">
                <span class="info-label">Modified</span>
                <span class="info-value">${info.project.modified}</span>
              </div>
            </div>
          </div>
        ` : ''}
        
        <!-- Recording Stats -->
        ${info.recording ? `
          <div class="info-section">
            <div class="info-section-header">
              <span class="info-icon">ðŸŽ¬</span>
              <span>Recording</span>
            </div>
            <div class="info-stats-grid">
              <div class="stat-card">
                <span class="stat-number">${info.recording.frames}</span>
                <span class="stat-label">Frames</span>
              </div>
              <div class="stat-card">
                <span class="stat-number">${info.recording.symbols}</span>
                <span class="stat-label">Symbols</span>
              </div>
              <div class="stat-card">
                <span class="stat-number">${info.recording.scenes}</span>
                <span class="stat-label">Scenes</span>
              </div>
              <div class="stat-card">
                <span class="stat-number">${Math.round(info.recording.duration / 1000)}s</span>
                <span class="stat-label">Duration</span>
              </div>
            </div>
          </div>
        ` : ''}
        
        <!-- Workspace Stats -->
        <div class="info-section">
          <div class="info-section-header">
            <span class="info-icon">ðŸ“Š</span>
            <span>Workspace</span>
          </div>
          <div class="info-stats-grid">
            <div class="stat-card">
              <span class="stat-number">${info.stats.totalProjects}</span>
              <span class="stat-label">Projects</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">${info.stats.totalClips}</span>
              <span class="stat-label">Clips</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">${info.stats.totalMarkers}</span>
              <span class="stat-label">Markers</span>
            </div>
            <div class="stat-card">
              <span class="stat-number">${info.stats.savedSearches}</span>
              <span class="stat-label">Saved Searches</span>
            </div>
          </div>
        </div>
        
        <!-- Quick Actions -->
        <div class="info-section">
          <div class="info-section-header">
            <span class="info-icon">âš¡</span>
            <span>Quick Actions</span>
          </div>
          <div class="info-actions">
            <button onclick="runDiagnostics().then(r => alert(r))" class="info-action-btn">
              ðŸ” Run Diagnostics
            </button>
            <button onclick="forceMemoryCleanup(); toast?.success?.('Cleanup done')" class="info-action-btn">
              ðŸ§¹ Cleanup Memory
            </button>
            <button onclick="forceAutoSave(); toast?.success?.('Saved')" class="info-action-btn">
              ðŸ’¾ Force Save
            </button>
            <button onclick="openSearchPanel()" class="info-action-btn">
              ðŸ”Ž Search
            </button>
          </div>
        </div>
        
        <!-- Footer -->
        <div class="info-footer">
          <span>Â© 2025 Mullu SI</span>
          <span>â€¢</span>
          <a href="https://mullusi.com" target="_blank">mullusi.com</a>
        </div>
      </div>
    `;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.25 â€” DASHBOARD VIEW
// Welcome dashboard with overview and quick access
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Dashboard {
  constructor() {
    this.recentLimit = 5;
  }
  
  async render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const projects = await projectManager?.getProjects() || [];
    const recentProjects = projects.slice(0, this.recentLimit);
    const currentProject = projectManager?.currentProject;
    const health = systemDiagnostics.getSummary();
    
    container.innerHTML = `
      <div class="dashboard">
        <!-- Welcome Header -->
        <div class="dashboard-header">
          <div class="dashboard-logo">
            <span class="logo-icon">â—‰</span>
            <div class="logo-text">
              <span class="logo-title">VIRECAI</span>
              <span class="logo-subtitle">Symbolic Video Intelligence</span>
            </div>
          </div>
          <div class="dashboard-status">
            <span class="status-badge ${health.includes('healthy') ? 'healthy' : 'warning'}">
              ${health}
            </span>
          </div>
        </div>
        
        <!-- Quick Start -->
        <div class="dashboard-section">
          <h3 class="dashboard-section-title">Quick Start</h3>
          <div class="quick-start-grid">
            <button class="quick-start-card" onclick="openNewProjectDialog(); closeDashboard();">
              <span class="qs-icon">ðŸ“</span>
              <span class="qs-title">New Project</span>
              <span class="qs-desc">Create a new recording project</span>
            </button>
            <button class="quick-start-card" onclick="openProjectBrowser(); closeDashboard();">
              <span class="qs-icon">ðŸ“‚</span>
              <span class="qs-title">Open Project</span>
              <span class="qs-desc">Load an existing project</span>
            </button>
            <button class="quick-start-card" onclick="closeDashboard(); toggleRecording();">
              <span class="qs-icon">âºï¸</span>
              <span class="qs-title">Quick Record</span>
              <span class="qs-desc">Start recording immediately</span>
            </button>
            <button class="quick-start-card" onclick="openSearchPanel(); closeDashboard();">
              <span class="qs-icon">ðŸ”</span>
              <span class="qs-title">Search</span>
              <span class="qs-desc">Find anything in your workspace</span>
            </button>
          </div>
        </div>
        
        ${currentProject ? `
          <!-- Current Project -->
          <div class="dashboard-section">
            <h3 class="dashboard-section-title">Current Project</h3>
            <div class="current-project-card">
              <div class="cp-info">
                <span class="cp-name">${currentProject.name}</span>
                <span class="cp-meta">${currentProject.recording?.frameCount || 0} frames â€¢ Last modified ${new Date(currentProject.modified).toLocaleString()}</span>
              </div>
              <div class="cp-actions">
                <button onclick="closeDashboard(); openPlaybackPanel();">â–¶ Play</button>
                <button onclick="closeDashboard(); openExportPanel();">ðŸ“¤ Export</button>
              </div>
            </div>
          </div>
        ` : ''}
        
        <!-- Recent Projects -->
        ${recentProjects.length > 0 ? `
          <div class="dashboard-section">
            <h3 class="dashboard-section-title">Recent Projects</h3>
            <div class="recent-projects-list">
              ${recentProjects.map(p => `
                <button class="recent-project-item" onclick="loadProjectById('${p.id}'); closeDashboard();">
                  <span class="rp-icon">ðŸ“</span>
                  <div class="rp-info">
                    <span class="rp-name">${p.name}</span>
                    <span class="rp-meta">${p.recording?.frameCount || 0} frames â€¢ ${new Date(p.modified).toLocaleDateString()}</span>
                  </div>
                  <span class="rp-arrow">â†’</span>
                </button>
              `).join('')}
            </div>
          </div>
        ` : `
          <div class="dashboard-section">
            <div class="no-projects">
              <span class="np-icon">ðŸ“</span>
              <span class="np-text">No projects yet</span>
              <button onclick="openNewProjectDialog(); closeDashboard();" class="np-btn">Create your first project</button>
            </div>
          </div>
        `}
        
        <!-- Feature Highlights -->
        <div class="dashboard-section">
          <h3 class="dashboard-section-title">Features</h3>
          <div class="features-grid">
            <div class="feature-card" onclick="closeDashboard(); openMeshPanel();">
              <span class="feat-icon">â—‰</span>
              <span class="feat-title">Symbol Mesh</span>
            </div>
            <div class="feature-card" onclick="closeDashboard(); openChainsPanel();">
              <span class="feat-icon">ðŸ”—</span>
              <span class="feat-title">Causal Chains</span>
            </div>
            <div class="feature-card" onclick="closeDashboard(); openDivePanel();">
              <span class="feat-icon">ðŸŒ€</span>
              <span class="feat-title">InceptaDive</span>
            </div>
            <div class="feature-card" onclick="closeDashboard(); openQueryPanel();">
              <span class="feat-icon">ðŸ’¬</span>
              <span class="feat-title">Query Console</span>
            </div>
            <div class="feature-card" onclick="closeDashboard(); openAnalyticsPanel();">
              <span class="feat-icon">ðŸ“Š</span>
              <span class="feat-title">Analytics</span>
            </div>
            <div class="feature-card" onclick="closeDashboard(); openSharePanel();">
              <span class="feat-icon">ðŸ‘¥</span>
              <span class="feat-title">Collaborate</span>
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div class="dashboard-footer">
          <span>VIRECAI v2.27</span>
          <span>â€¢</span>
          <span>Mullu Symbolic Intelligence</span>
          <span>â€¢</span>
          <a href="#" onclick="startTour(); closeDashboard();">Take a Tour</a>
        </div>
      </div>
    `;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.25 â€” ABOUT DIALOG
// About VIRECAI information
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AboutDialog {
  render() {
    return `
      <div class="about-content">
        <div class="about-logo">
          <span class="about-icon">â—‰</span>
          <span class="about-title">VIRECAI</span>
        </div>
        <div class="about-version">Version 2.25</div>
        <div class="about-tagline">Video Intelligence Reality Encoder with Causal AI</div>
        
        <div class="about-description">
          A revolutionary symbolic video format that captures not just pixels,
          but meaning, causality, and intelligence. Built on Mullu Symbolic
          Intelligence principles for transparent, queryable video data.
        </div>
        
        <div class="about-features">
          <div class="about-feature">
            <span>â—‰</span>
            <span>Symbolic Frame Encoding</span>
          </div>
          <div class="about-feature">
            <span>ðŸ”—</span>
            <span>Causal Chain Reasoning</span>
          </div>
          <div class="about-feature">
            <span>ðŸŒ€</span>
            <span>InceptaDive Exploration</span>
          </div>
          <div class="about-feature">
            <span>ðŸ’¬</span>
            <span>Natural Language Queries</span>
          </div>
          <div class="about-feature">
            <span>ðŸ”</span>
            <span>Transparent AI</span>
          </div>
        </div>
        
        <div class="about-credits">
          <div class="credit-item">
            <span class="credit-label">Created by</span>
            <span class="credit-value">Mullu SI</span>
          </div>
          <div class="credit-item">
            <span class="credit-label">Website</span>
            <a href="https://mullusi.com" target="_blank">mullusi.com</a>
          </div>
          <div class="credit-item">
            <span class="credit-label">Contact</span>
            <a href="mailto:research@mullusi.com">research@mullusi.com</a>
          </div>
        </div>
        
        <div class="about-copyright">
          Â© 2025 Mullu SI. All rights reserved.
        </div>
      </div>
    `;
  }
}

// Global instances
const mainMenu = new MainMenu();
const infoPanel = new InfoPanel();
const dashboard = new Dashboard();
const aboutDialog = new AboutDialog();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” STATUS BAR
// Always-visible status at bottom of screen
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class StatusBar {
  constructor() {
    this.updateInterval = null;
    this.isInitialized = false;
  }
  
  render() {
    const container = document.getElementById('status-bar');
    if (!container) return;
    
    // Don't show on splash screen
    if (!this.isInitialized) {
      container.style.display = 'none';
      return;
    }
    container.style.display = 'flex';
    
    const project = projectManager?.currentProject;
    const container2 = orch?.getContainer();
    const currentFrame = playbackEngine?.currentFrame || 0;
    const totalFrames = container2?.frames?.length || playbackEngine?.totalFrames || 0;
    const state = recordingController?.getState() || 'idle';
    const memory = memoryManager?.getUsage();
    const isDirty = project?.isDirty || autoSaveManager?.isDirty;
    
    // Calculate duration
    const duration = container2?.duration || 0;
    const currentTime = totalFrames > 0 ? (currentFrame / totalFrames) * duration : 0;
    
    container.innerHTML = `
      <div class="status-item clickable" onclick="openProjectBrowser()" title="Current Project">
        <span class="status-icon">ðŸ“</span>
        <span>${project?.name || 'No Project'}</span>
      </div>
      <div class="status-item" title="Frame Position">
        <span class="status-icon">ðŸŽ¬</span>
        <span>Frame ${currentFrame}/${totalFrames}</span>
      </div>
      <div class="status-item" title="Duration">
        <span class="status-icon">â±ï¸</span>
        <span>${this._formatTime(currentTime)} / ${this._formatTime(duration)}</span>
      </div>
      <div class="status-item" title="Recording State">
        <span class="status-dot ${state === 'recording' ? 'recording' : state === 'playing' ? 'playing' : state === 'paused' ? 'paused' : ''}"></span>
        <span>${this._formatState(state)}</span>
      </div>
      ${memory?.available ? `
        <div class="status-item clickable" onclick="checkMemory().then(r => alert(r))" title="Memory Usage">
          <span class="status-icon">ðŸ’¾</span>
          <span>${memory.usedMB}MB</span>
        </div>
      ` : ''}
      <div class="status-item" title="Save Status">
        <span class="status-badge ${isDirty ? 'unsaved' : 'saved'}">${isDirty ? 'â— Unsaved' : 'âœ“ Saved'}</span>
      </div>
      <div class="status-item clickable" onclick="toggleNotifications()" title="Notifications">
        <span class="notification-bell" id="status-bell">
          ðŸ””
          ${notificationCenter?.unreadCount > 0 ? `<span class="notification-badge">${notificationCenter.unreadCount}</span>` : ''}
        </span>
      </div>
    `;
  }
  
  _formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
  
  _formatState(state) {
    const states = {
      idle: 'Idle',
      ready: 'Ready',
      recording: 'Recording',
      paused: 'Paused',
      stopped: 'Stopped',
      playing: 'Playing'
    };
    return states[state] || state;
  }
  
  initialize() {
    this.isInitialized = true;
    this.startUpdating();
  }
  
  startUpdating() {
    this.stopUpdating();
    this.render();
    this.updateInterval = setInterval(() => this.render(), 1000);
  }
  
  stopUpdating() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” BREADCRUMBS
// Navigation path display
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Breadcrumbs {
  constructor() {
    this.path = [];
  }
  
  setPath(items) {
    // items: [{icon, label, action}, ...]
    this.path = items;
    this.render();
  }
  
  updateFromContext() {
    const path = [
      { icon: 'ðŸ ', label: 'Home', action: 'openDashboard' }
    ];
    
    const project = projectManager?.currentProject;
    if (project) {
      path.push({ icon: 'ðŸ“', label: project.name, action: 'openProjectBrowser' });
    }
    
    const container = orch?.getContainer();
    if (container && container.frames.length > 0) {
      // Check if in a scene
      const currentFrame = playbackEngine?.currentFrame || 0;
      const scene = container.scenes?.find(s => currentFrame >= s.startFrame && currentFrame <= s.endFrame);
      if (scene) {
        path.push({ icon: 'ðŸŽ¬', label: scene.label, action: null });
      }
      
      path.push({ icon: 'ðŸ–¼ï¸', label: `Frame ${currentFrame}`, action: null, current: true });
    }
    
    this.path = path;
    this.render();
  }
  
  render() {
    const container = document.getElementById('breadcrumbs');
    if (!container) return;
    
    if (this.path.length === 0) {
      container.innerHTML = '';
      container.style.display = 'none';
      return;
    }
    
    container.style.display = 'flex';
    container.innerHTML = this.path.map((item, i) => `
      ${i > 0 ? '<span class="breadcrumb-separator">â€º</span>' : ''}
      <span class="breadcrumb-item ${item.action ? 'clickable' : ''} ${item.current ? 'current' : ''}"
            ${item.action ? `onclick="${item.action}()"` : ''}>
        <span>${item.icon}</span>
        <span>${item.label}</span>
      </span>
    `).join('');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” CONTEXT MENU
// Right-click menu system
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ContextMenu {
  constructor() {
    this.isOpen = false;
    this.currentContext = null;
    
    // Close on click outside
    document.addEventListener('click', () => this.close());
    document.addEventListener('contextmenu', (e) => this._handleContextMenu(e));
  }
  
  _handleContextMenu(e) {
    // Check if right-click is on a specific element
    const target = e.target;
    
    // Timeline context
    if (target.closest('.timeline-track, .timeline-minimap, #filmstrip-track')) {
      e.preventDefault();
      this.showTimelineMenu(e.clientX, e.clientY);
      return;
    }
    
    // Project list item context
    if (target.closest('.recent-project-item, .project-card')) {
      e.preventDefault();
      const projectId = target.closest('[data-project-id]')?.dataset?.projectId;
      this.showProjectMenu(e.clientX, e.clientY, projectId);
      return;
    }
    
    // Symbol/mesh context
    if (target.closest('.mesh-node, .symbol-item')) {
      e.preventDefault();
      const symbolId = target.closest('[data-symbol-id]')?.dataset?.symbolId;
      this.showSymbolMenu(e.clientX, e.clientY, symbolId);
      return;
    }
    
    // Marker context
    if (target.closest('.marker-item, .timeline-marker')) {
      e.preventDefault();
      const markerId = target.closest('[data-marker-id]')?.dataset?.markerId;
      this.showMarkerMenu(e.clientX, e.clientY, markerId);
      return;
    }
  }
  
  show(x, y, items) {
    this.close();
    
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.id = 'context-menu';
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    
    menu.innerHTML = items.map(item => {
      if (item.type === 'divider') {
        return '<div class="context-menu-divider"></div>';
      }
      if (item.type === 'header') {
        return `<div class="context-menu-header">${item.label}</div>`;
      }
      return `
        <button class="context-menu-item ${item.danger ? 'danger' : ''} ${item.disabled ? 'disabled' : ''}"
                onclick="contextMenu.executeAction('${item.action}', '${item.data || ''}')">
          <span class="context-menu-item-icon">${item.icon || ''}</span>
          <span>${item.label}</span>
          ${item.shortcut ? `<span class="context-menu-item-shortcut">${item.shortcut}</span>` : ''}
        </button>
      `;
    }).join('');
    
    document.body.appendChild(menu);
    
    // Adjust position if off-screen
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) {
      menu.style.left = `${window.innerWidth - rect.width - 10}px`;
    }
    if (rect.bottom > window.innerHeight) {
      menu.style.top = `${window.innerHeight - rect.height - 10}px`;
    }
    
    this.isOpen = true;
  }
  
  close() {
    const existing = document.getElementById('context-menu');
    if (existing) existing.remove();
    this.isOpen = false;
  }
  
  executeAction(action, data) {
    this.close();
    
    if (typeof window[action] === 'function') {
      window[action](data);
    } else {
      console.warn(`[ContextMenu] Action not found: ${action}`);
    }
  }
  
  showTimelineMenu(x, y) {
    this.show(x, y, [
      { type: 'header', label: 'Timeline' },
      { icon: 'ðŸ“', label: 'Add Marker Here', action: 'addMarkerAtPlayhead', shortcut: 'M' },
      { icon: 'ðŸ“‘', label: 'Add Chapter', action: 'addChapterHere' },
      { type: 'divider' },
      { icon: 'âœ‚ï¸', label: 'Split at Playhead', action: 'splitAtPlayhead' },
      { icon: 'ðŸ”²', label: 'Select Region', action: 'startRegionSelect' },
      { type: 'divider' },
      { icon: 'ðŸ”', label: 'Zoom to Fit', action: 'zoomToFit' },
      { icon: 'ðŸŽ¯', label: 'Go to Frame...', action: 'showGotoFrame' }
    ]);
  }
  
  showProjectMenu(x, y, projectId) {
    this.currentContext = { type: 'project', id: projectId };
    const project = projectManager?.projects?.find(p => p.id === projectId);
    const isStarred = starredManager?.isStarred(projectId);
    
    this.show(x, y, [
      { type: 'header', label: project?.name || 'Project' },
      { icon: 'ðŸ“‚', label: 'Open', action: 'contextOpenProject', data: projectId },
      { icon: isStarred ? 'â­' : 'â˜†', label: isStarred ? 'Unstar' : 'Star', action: 'contextToggleStar', data: projectId },
      { type: 'divider' },
      { icon: 'ðŸ“‹', label: 'Duplicate', action: 'contextDuplicateProject', data: projectId },
      { icon: 'ðŸ“¤', label: 'Export', action: 'contextExportProject', data: projectId },
      { icon: 'ðŸ“', label: 'Rename', action: 'contextRenameProject', data: projectId },
      { type: 'divider' },
      { icon: 'ðŸ—‘ï¸', label: 'Delete', action: 'contextDeleteProject', data: projectId, danger: true }
    ]);
  }
  
  showSymbolMenu(x, y, symbolId) {
    this.currentContext = { type: 'symbol', id: symbolId };
    
    this.show(x, y, [
      { type: 'header', label: 'Symbol' },
      { icon: 'ðŸ”', label: 'Inspect', action: 'contextInspectSymbol', data: symbolId },
      { icon: 'âœï¸', label: 'Edit', action: 'contextEditSymbol', data: symbolId },
      { icon: 'ðŸ”—', label: 'Show Connections', action: 'contextShowConnections', data: symbolId },
      { type: 'divider' },
      { icon: 'ðŸ“‹', label: 'Copy ID', action: 'contextCopySymbolId', data: symbolId },
      { icon: 'ðŸŒ€', label: 'InceptaDive', action: 'contextDiveSymbol', data: symbolId }
    ]);
  }
  
  showMarkerMenu(x, y, markerId) {
    this.currentContext = { type: 'marker', id: markerId };
    
    this.show(x, y, [
      { type: 'header', label: 'Marker' },
      { icon: 'â–¶ï¸', label: 'Go to Marker', action: 'contextGoToMarker', data: markerId },
      { icon: 'âœï¸', label: 'Edit', action: 'contextEditMarker', data: markerId },
      { icon: 'ðŸŽ¨', label: 'Change Color', action: 'contextChangeMarkerColor', data: markerId },
      { type: 'divider' },
      { icon: 'ðŸ—‘ï¸', label: 'Delete', action: 'contextDeleteMarker', data: markerId, danger: true }
    ]);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” NOTIFICATION CENTER
// Centralized notification management
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class NotificationCenter {
  constructor() {
    this.notifications = [];
    this.maxNotifications = 50;
    this.unreadCount = 0;
    this.isOpen = false;
  }
  
  add(type, message) {
    const notification = {
      id: `notif_${Date.now()}`,
      type, // 'success', 'warning', 'error', 'info'
      message,
      timestamp: Date.now(),
      read: false
    };
    
    this.notifications.unshift(notification);
    
    if (this.notifications.length > this.maxNotifications) {
      this.notifications.pop();
    }
    
    this.unreadCount++;
    statusBar?.render();
    
    return notification.id;
  }
  
  success(message) { return this.add('success', message); }
  warning(message) { return this.add('warning', message); }
  error(message) { return this.add('error', message); }
  info(message) { return this.add('info', message); }
  
  markAllRead() {
    this.notifications.forEach(n => n.read = true);
    this.unreadCount = 0;
    statusBar?.render();
  }
  
  clear() {
    this.notifications = [];
    this.unreadCount = 0;
    statusBar?.render();
    this.render();
  }
  
  toggle() {
    this.isOpen = !this.isOpen;
    this.render();
    
    if (this.isOpen) {
      this.markAllRead();
    }
  }
  
  render() {
    const panel = document.getElementById('notification-panel');
    if (!panel) return;
    
    if (this.isOpen) {
      panel.classList.add('open');
    } else {
      panel.classList.remove('open');
      return;
    }
    
    const icons = {
      success: 'âœ“',
      warning: 'âš ',
      error: 'âœ—',
      info: 'â„¹'
    };
    
    const listHtml = this.notifications.length === 0 
      ? '<div class="notification-empty">No notifications</div>'
      : this.notifications.map(n => `
          <div class="notification-item">
            <div class="notification-icon ${n.type}">${icons[n.type]}</div>
            <div class="notification-content">
              <div class="notification-message">${n.message}</div>
              <div class="notification-time">${this._formatTime(n.timestamp)}</div>
            </div>
          </div>
        `).join('');
    
    document.getElementById('notification-list').innerHTML = listHtml;
  }
  
  _formatTime(timestamp) {
    const diff = Date.now() - timestamp;
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)} min ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)} hours ago`;
    return new Date(timestamp).toLocaleDateString();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” TIMELINE MINIMAP
// Bird's eye view of timeline
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TimelineMinimap {
  constructor() {
    this.densityData = [];
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const frames = orch?.getContainer()?.frames || [];
    const totalFrames = frames.length || playbackEngine?.totalFrames || 100;
    const currentFrame = playbackEngine?.currentFrame || 0;
    const markers = annotationTimeline?.markers || [];
    
    // Calculate density (activity per segment)
    this._calculateDensity(frames);
    
    // Render minimap
    container.innerHTML = `
      <div class="timeline-minimap" onclick="timelineMinimap.handleClick(event)">
        <div class="minimap-track">
          ${this._renderDensity(totalFrames)}
          ${this._renderMarkers(markers, totalFrames)}
          <div class="minimap-playhead" style="left: ${(currentFrame / totalFrames) * 100}%"></div>
        </div>
      </div>
    `;
  }
  
  _calculateDensity(frames) {
    if (frames.length === 0) {
      this.densityData = [];
      return;
    }
    
    const segments = 50;
    const framesPerSegment = Math.ceil(frames.length / segments);
    this.densityData = [];
    
    for (let i = 0; i < segments; i++) {
      const start = i * framesPerSegment;
      const end = Math.min(start + framesPerSegment, frames.length);
      const segmentFrames = frames.slice(start, end);
      
      // Calculate activity based on layer count
      const avgLayers = segmentFrames.reduce((sum, f) => sum + (f.layers?.length || 0), 0) / segmentFrames.length;
      this.densityData.push(Math.min(avgLayers / 5, 1)); // Normalize to 0-1
    }
  }
  
  _renderDensity(totalFrames) {
    if (this.densityData.length === 0) return '';
    
    const segmentWidth = 100 / this.densityData.length;
    return this.densityData.map((density, i) => {
      if (density < 0.1) return '';
      return `<div class="minimap-density" style="left: ${i * segmentWidth}%; width: ${segmentWidth}%; opacity: ${0.2 + density * 0.6}"></div>`;
    }).join('');
  }
  
  _renderMarkers(markers, totalFrames) {
    return markers.map(m => {
      const pos = (m.frame / totalFrames) * 100;
      return `<div class="minimap-marker" style="left: ${pos}%" title="${m.label}"></div>`;
    }).join('');
  }
  
  handleClick(e) {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percent = x / rect.width;
    const totalFrames = orch?.getContainer()?.frames?.length || playbackEngine?.totalFrames || 0;
    const targetFrame = Math.floor(percent * totalFrames);
    
    if (playbackEngine?.seek) {
      playbackEngine.seek(targetFrame);
      this.render('timeline-minimap-container');
    }
  }
  
  update() {
    this.render('timeline-minimap-container');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” FLOATING ACTIONS BAR
// Quick access floating toolbar
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class FloatingActions {
  constructor() {
    this.isVisible = false; // Hidden by default until system initialized
    this.isInitialized = false;
    this.lastRender = 0;
    this.renderThrottle = 100; // ms
  }
  
  render() {
    const container = document.getElementById('floating-actions');
    if (!container) return;
    
    // v2.27: Throttle rendering to avoid excessive updates
    const now = performance.now();
    if (now - this.lastRender < this.renderThrottle) return;
    this.lastRender = now;
    
    // Don't show until explicitly initialized
    if (!this.isInitialized || !this.isVisible) {
      container.innerHTML = '';
      return;
    }
    
    const state = recordingController?.getState() || 'idle';
    const isRecording = state === 'recording';
    const isPaused = state === 'paused';
    const hasRecording = (orch?.getContainer()?.frames?.length || 0) > 0;
    
    // v2.27: Get recording health
    const stats = recordingController?.getStats?.() || {};
    const health = stats.health || 'n/a';
    const frameRate = stats.frameRate || 0;
    
    // v2.27: Health indicator color
    const healthColors = {
      'good': '#22cc88',
      'fair': '#ffcc44',
      'degraded': '#ff8844',
      'critical': '#ff4444',
      'n/a': 'transparent'
    };
    const healthColor = healthColors[health] || 'transparent';
    
    container.innerHTML = `
      <div class="floating-actions">
        <div class="floating-action-group">
          <button class="floating-action-btn ${isRecording ? 'recording' : ''}" 
                  onclick="toggleRecording()" 
                  title="${isRecording ? 'Pause (Space)' : 'Record (Space)'}"
                  data-tooltip="${isRecording ? 'Pause' : 'Record'}">
            ${isRecording ? 'â¸ï¸' : 'âºï¸'}
            ${isRecording ? '<span class="recording-ring"></span>' : ''}
          </button>
          ${(isRecording || isPaused) ? `
            <button class="floating-action-btn" onclick="stopRecording()" title="Stop (Esc)">â¹ï¸</button>
          ` : ''}
        </div>
        ${isRecording ? `
          <div class="floating-action-group" style="padding: 0 8px;">
            <span class="status-indicator recording" style="border: 2px solid ${healthColor};">
              <span style="font-size: 10px; font-weight: 600;">${frameRate.toFixed(1)} fps</span>
            </span>
          </div>
        ` : ''}
        ${hasRecording ? `
          <div class="floating-action-group">
            <button class="floating-action-btn" onclick="addMarkerAtPlayhead()" title="Add Marker (M)">ðŸ“</button>
            <button class="floating-action-btn" onclick="openClipEditorPanel()" title="Clip (X)">âœ‚ï¸</button>
            <button class="floating-action-btn" onclick="openCommentsPanel()" title="Comment">ðŸ’¬</button>
          </div>
        ` : ''}
        <div class="floating-action-group">
          <button class="floating-action-btn" onclick="openSearchPanel()" title="Search (Ctrl+K)">ðŸ”</button>
          <button class="floating-action-btn" onclick="openHelpPanel()" title="Help (F1)">â“</button>
        </div>
      </div>
    `;
  }
  
  initialize() {
    this.isInitialized = true;
    this.isVisible = true;
    this.render();
    
    // v2.27: Auto-update during recording
    this._startAutoUpdate();
  }
  
  // v2.27: Auto-update for frame rate display
  _startAutoUpdate() {
    setInterval(() => {
      if (this.isVisible && recordingController?.getState() === 'recording') {
        this.render();
      }
    }, 1000);
  }
  
  toggle() {
    if (!this.isInitialized) return;
    this.isVisible = !this.isVisible;
    this.lastRender = 0; // Force immediate render
    this.render();
  }
  
  show() {
    if (!this.isInitialized) return;
    this.isVisible = true;
    this.lastRender = 0;
    this.render();
  }
  
  hide() {
    this.isVisible = false;
    this.lastRender = 0;
    this.render();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” EXPORT PRESETS
// Saved export configurations
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ExportPresets {
  constructor() {
    this.presets = [
      {
        id: 'youtube',
        name: 'YouTube Upload',
        icon: 'ðŸ“º',
        description: '1080p, optimized for streaming',
        config: { format: 'mullu', quality: 'high', includeSymbols: true }
      },
      {
        id: 'archive',
        name: 'Full Archive',
        icon: 'ðŸ—„ï¸',
        description: 'Complete data, maximum quality',
        config: { format: 'mullu', quality: 'lossless', includeSymbols: true, includeMetadata: true }
      },
      {
        id: 'share',
        name: 'Quick Share',
        icon: 'ðŸ“¤',
        description: 'Lightweight, fast upload',
        config: { format: 'json', quality: 'medium', includeSymbols: false }
      },
      {
        id: 'analysis',
        name: 'Analysis Export',
        icon: 'ðŸ“Š',
        description: 'CSV data for external analysis',
        config: { format: 'csv', includeTimestamps: true, includeSymbols: true }
      },
      {
        id: 'report',
        name: 'PDF Report',
        icon: 'ðŸ“„',
        description: 'Formatted document with insights',
        config: { format: 'report', includeCharts: true, includeNarrative: true }
      }
    ];
    this.selectedPreset = null;
    this.customPresets = this._loadCustomPresets();
  }
  
  _loadCustomPresets() {
    try {
      return JSON.parse(localStorage.getItem('virecai_export_presets') || '[]');
    } catch {
      return [];
    }
  }
  
  _saveCustomPresets() {
    localStorage.setItem('virecai_export_presets', JSON.stringify(this.customPresets));
  }
  
  getAllPresets() {
    return [...this.presets, ...this.customPresets];
  }
  
  getPreset(id) {
    return this.getAllPresets().find(p => p.id === id);
  }
  
  select(id) {
    this.selectedPreset = id;
  }
  
  addCustomPreset(preset) {
    preset.id = `custom_${Date.now()}`;
    preset.custom = true;
    this.customPresets.push(preset);
    this._saveCustomPresets();
    return preset.id;
  }
  
  removeCustomPreset(id) {
    this.customPresets = this.customPresets.filter(p => p.id !== id);
    this._saveCustomPresets();
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="export-presets">
        ${this.getAllPresets().map(preset => `
          <div class="export-preset-card ${this.selectedPreset === preset.id ? 'selected' : ''}"
               onclick="exportPresets.select('${preset.id}'); exportPresets.render('${containerId}')">
            <span class="export-preset-icon">${preset.icon}</span>
            <div class="export-preset-info">
              <div class="export-preset-name">${preset.name}</div>
              <div class="export-preset-desc">${preset.description}</div>
            </div>
            <span class="export-preset-check">${this.selectedPreset === preset.id ? 'âœ“' : ''}</span>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  getSelectedConfig() {
    const preset = this.getPreset(this.selectedPreset);
    return preset?.config || null;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” STARRED MANAGER
// Manage favorite/starred projects
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class StarredManager {
  constructor() {
    this.starred = this._load();
  }
  
  _load() {
    try {
      return new Set(JSON.parse(localStorage.getItem('virecai_starred') || '[]'));
    } catch {
      return new Set();
    }
  }
  
  _save() {
    localStorage.setItem('virecai_starred', JSON.stringify([...this.starred]));
  }
  
  isStarred(projectId) {
    return this.starred.has(projectId);
  }
  
  toggle(projectId) {
    if (this.starred.has(projectId)) {
      this.starred.delete(projectId);
    } else {
      this.starred.add(projectId);
    }
    this._save();
    return this.isStarred(projectId);
  }
  
  star(projectId) {
    this.starred.add(projectId);
    this._save();
  }
  
  unstar(projectId) {
    this.starred.delete(projectId);
    this._save();
  }
  
  getStarred() {
    return [...this.starred];
  }
  
  getStarredProjects(allProjects) {
    return allProjects.filter(p => this.starred.has(p.id));
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” RECENT ACTIONS
// Track and display recent user actions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class RecentActions {
  constructor() {
    this.actions = [];
    this.maxActions = 20;
  }
  
  add(icon, text, undoAction = null) {
    const action = {
      id: `action_${Date.now()}`,
      icon,
      text,
      timestamp: Date.now(),
      undoAction
    };
    
    this.actions.unshift(action);
    
    if (this.actions.length > this.maxActions) {
      this.actions.pop();
    }
    
    return action.id;
  }
  
  getRecent(limit = 10) {
    return this.actions.slice(0, limit);
  }
  
  clear() {
    this.actions = [];
  }
  
  undo(actionId) {
    const action = this.actions.find(a => a.id === actionId);
    if (action?.undoAction && typeof window[action.undoAction] === 'function') {
      window[action.undoAction]();
      this.actions = this.actions.filter(a => a.id !== actionId);
    }
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    if (this.actions.length === 0) {
      container.innerHTML = '<div class="notification-empty">No recent actions</div>';
      return;
    }
    
    container.innerHTML = `
      <div class="recent-actions">
        ${this.actions.slice(0, 10).map(action => `
          <div class="recent-action-item">
            <span class="recent-action-icon">${action.icon}</span>
            <span class="recent-action-text">${action.text}</span>
            <span class="recent-action-time">${this._formatTime(action.timestamp)}</span>
            ${action.undoAction ? `
              <button class="recent-action-undo" onclick="recentActions.undo('${action.id}')">Undo</button>
            ` : ''}
          </div>
        `).join('')}
      </div>
    `;
  }
  
  _formatTime(timestamp) {
    const diff = Date.now() - timestamp;
    if (diff < 60000) return 'now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m`;
    return `${Math.floor(diff / 3600000)}h`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” SYMBOL PALETTE
// Draggable symbols for annotation
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SymbolPalette {
  constructor() {
    this.symbols = [
      { id: 'person', icon: 'ðŸ‘¤', label: 'Person' },
      { id: 'object', icon: 'ðŸ“¦', label: 'Object' },
      { id: 'action', icon: 'âš¡', label: 'Action' },
      { id: 'event', icon: 'ðŸ“Œ', label: 'Event' },
      { id: 'place', icon: 'ðŸ“', label: 'Place' },
      { id: 'time', icon: 'â°', label: 'Time' },
      { id: 'cause', icon: 'ðŸ”—', label: 'Cause' },
      { id: 'effect', icon: 'ðŸ’«', label: 'Effect' },
      { id: 'custom', icon: 'â—‰', label: 'Custom' }
    ];
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="symbol-palette">
        ${this.symbols.map(s => `
          <div class="symbol-palette-item" 
               draggable="true" 
               data-symbol-type="${s.id}"
               ondragstart="symbolPalette.handleDragStart(event, '${s.id}')">
            <span class="symbol-palette-icon">${s.icon}</span>
            <span class="symbol-palette-label">${s.label}</span>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  handleDragStart(e, symbolType) {
    e.dataTransfer.setData('text/plain', symbolType);
    e.dataTransfer.effectAllowed = 'copy';
  }
  
  getSymbol(type) {
    return this.symbols.find(s => s.id === type);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” WH QUERY BUILDER
// Visual query builder
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class WHQueryBuilder {
  constructor() {
    this.fields = {
      who: '',
      what: '',
      when: '',
      where: '',
      why: '',
      how: ''
    };
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="wh-query-builder">
        ${Object.keys(this.fields).map(field => `
          <div class="wh-query-row">
            <span class="wh-query-label">${field.toUpperCase()}</span>
            <input class="wh-query-input" 
                   type="text" 
                   placeholder="Enter ${field}..."
                   value="${this.fields[field]}"
                   onchange="whQueryBuilder.setField('${field}', this.value)">
          </div>
        `).join('')}
        <button class="wh-query-execute" onclick="whQueryBuilder.execute()">
          ðŸ” Execute Query
        </button>
      </div>
    `;
  }
  
  setField(field, value) {
    this.fields[field] = value;
  }
  
  execute() {
    // Build query string
    const parts = [];
    if (this.fields.who) parts.push(`who:${this.fields.who}`);
    if (this.fields.what) parts.push(`what:${this.fields.what}`);
    if (this.fields.when) parts.push(`when:${this.fields.when}`);
    if (this.fields.where) parts.push(`where:${this.fields.where}`);
    if (this.fields.why) parts.push(`why:${this.fields.why}`);
    if (this.fields.how) parts.push(`how:${this.fields.how}`);
    
    const query = parts.join(' ');
    
    if (query) {
      const result = symbolicQuery.parse(query, orch?.getContainer());
      const formatted = symbolicQuery.formatResult(result);
      
      // Display result
      const output = document.getElementById('query-output');
      if (output) {
        output.innerHTML = `<pre style="white-space: pre-wrap;">${formatted}</pre>`;
      }
      switchTab?.('query');
      openPanel?.();
    } else {
      toast?.warning?.('Please fill at least one field');
    }
  }
  
  clear() {
    Object.keys(this.fields).forEach(k => this.fields[k] = '');
    this.render('wh-query-builder-container');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V2.26 â€” WORKSPACE LAYOUTS
// Save and restore panel arrangements
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class WorkspaceLayouts {
  constructor() {
    this.layouts = {
      recording: {
        name: 'Recording',
        icon: 'âºï¸',
        panels: ['camera'],
        floatingActions: true
      },
      editing: {
        name: 'Editing',
        icon: 'âœï¸',
        panels: ['clips', 'timeline'],
        floatingActions: true
      },
      analysis: {
        name: 'Analysis',
        icon: 'ðŸ“Š',
        panels: ['query', 'mesh', 'analytics'],
        floatingActions: false
      }
    };
    this.currentLayout = 'recording';
  }
  
  apply(layoutId) {
    const layout = this.layouts[layoutId];
    if (!layout) return;
    
    this.currentLayout = layoutId;
    
    // Close all panels first
    closePanel?.();
    
    // Apply layout settings
    if (layout.floatingActions) {
      floatingActions?.show();
    } else {
      floatingActions?.hide();
    }
    
    // Open first panel if specified
    if (layout.panels.length > 0) {
      const panelMap = {
        camera: 'openCameraPanel',
        clips: 'openClipEditorPanel',
        timeline: 'openAnnotationPanel',
        query: 'openQueryPanel',
        mesh: 'openMeshPanel',
        analytics: 'openAnalyticsPanel'
      };
      
      const openFn = panelMap[layout.panels[0]];
      if (openFn && typeof window[openFn] === 'function') {
        window[openFn]();
      }
    }
    
    toast?.info?.(`Layout: ${layout.name}`);
    this.render('workspace-layouts-container');
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="workspace-layouts">
        ${Object.entries(this.layouts).map(([id, layout]) => `
          <button class="workspace-layout-btn ${this.currentLayout === id ? 'active' : ''}"
                  onclick="workspaceLayouts.apply('${id}')">
            <span class="workspace-layout-icon">${layout.icon}</span>
            ${layout.name}
          </button>
        `).join('')}
      </div>
    `;
  }
}

// V2.26 Global instances
const statusBar = new StatusBar();
const breadcrumbs = new Breadcrumbs();
const contextMenu = new ContextMenu();
const notificationCenter = new NotificationCenter();
const timelineMinimap = new TimelineMinimap();
const floatingActions = new FloatingActions();
const exportPresets = new ExportPresets();
const starredManager = new StarredManager();
const recentActions = new RecentActions();
const symbolPalette = new SymbolPalette();
const whQueryBuilder = new WHQueryBuilder();
const workspaceLayouts = new WorkspaceLayouts();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PLAYBACK ENGINE â€” Replay Saved Recordings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PlaybackEngine {
  constructor() {
    this.isPlaying = false;
    this.isPaused = false;
    this.currentFrame = 0;
    this.totalFrames = 0;
    this.playbackSpeed = 1.0;
    this.recording = null;
    this.frames = [];
    this.startTime = 0;
    this.animationId = null;
    this.onFrameChange = null;
    this.onPlaybackEnd = null;
  }
  
  async load(recordingId) {
    try {
      const recording = await persistence.getRecording(recordingId);
      if (!recording || !recording.vrcData) {
        throw new Error('Recording not found');
      }
      
      // Parse VRC data
      const vrcData = recording.vrcData;
      const mode = vrcData[7] === 'F' ? 'full' : 'lite';
      const jsonStr = decodeURIComponent(escape(atob(vrcData.slice(8))));
      const data = JSON.parse(jsonStr);
      
      this.recording = recording;
      this.frames = data.frames || [];
      this.totalFrames = this.frames.length;
      this.currentFrame = 0;
      
      Log.ok('playback', `Loaded: ${recording.name} (${this.totalFrames} frames)`);
      return { success: true, recording, frameCount: this.totalFrames };
    } catch (err) {
      Log.error('playback', err.message);
      return { success: false, error: err.message };
    }
  }
  
  loadFromContainer(container) {
    if (!container || container.frames.length === 0) {
      return { success: false, error: 'No frames in container' };
    }
    
    this.recording = {
      name: 'Current Recording',
      mode: container.mode,
      frameCount: container.frames.length
    };
    
    // Extract frame data for playback
    this.frames = container.frames.map(f => ({
      index: f.index,
      timestamp: f.timestamp,
      wh: f.wh,
      theoretical: f.theoretical,
      causalInferences: f.causalInferences,
      visual: f.getLayer('visual'),
      signature: f.signature
    }));
    
    this.totalFrames = this.frames.length;
    this.currentFrame = 0;
    
    return { success: true, frameCount: this.totalFrames };
  }
  
  play() {
    if (this.totalFrames === 0) return;
    
    this.isPlaying = true;
    this.isPaused = false;
    this.startTime = performance.now() - (this.frames[this.currentFrame]?.timestamp || 0) / this.playbackSpeed;
    
    this._playbackLoop();
    Log.info('playback', 'Playing...');
  }
  
  pause() {
    this.isPaused = true;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    Log.info('playback', 'Paused');
  }
  
  resume() {
    if (!this.isPlaying) return;
    this.isPaused = false;
    this.startTime = performance.now() - (this.frames[this.currentFrame]?.timestamp || 0) / this.playbackSpeed;
    this._playbackLoop();
  }
  
  stop() {
    this.isPlaying = false;
    this.isPaused = false;
    this.currentFrame = 0;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    Log.info('playback', 'Stopped');
  }
  
  seek(frameIndex) {
    this.currentFrame = Math.max(0, Math.min(frameIndex, this.totalFrames - 1));
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame, this.frames[this.currentFrame]);
    }
    
    // Update start time if playing
    if (this.isPlaying && !this.isPaused) {
      this.startTime = performance.now() - (this.frames[this.currentFrame]?.timestamp || 0) / this.playbackSpeed;
    }
  }
  
  seekPercent(percent) {
    const frameIndex = Math.floor((percent / 100) * (this.totalFrames - 1));
    this.seek(frameIndex);
  }
  
  nextFrame() {
    if (this.currentFrame < this.totalFrames - 1) {
      this.seek(this.currentFrame + 1);
    }
  }
  
  prevFrame() {
    if (this.currentFrame > 0) {
      this.seek(this.currentFrame - 1);
    }
  }
  
  setSpeed(speed) {
    this.playbackSpeed = Math.max(0.1, Math.min(speed, 4.0));
    if (this.isPlaying && !this.isPaused) {
      this.startTime = performance.now() - (this.frames[this.currentFrame]?.timestamp || 0) / this.playbackSpeed;
    }
  }
  
  _playbackLoop() {
    if (!this.isPlaying || this.isPaused) return;
    
    const elapsed = (performance.now() - this.startTime) * this.playbackSpeed;
    
    // Find frame at current time
    let targetFrame = this.currentFrame;
    while (targetFrame < this.totalFrames - 1 && 
           this.frames[targetFrame + 1]?.timestamp <= elapsed) {
      targetFrame++;
    }
    
    if (targetFrame !== this.currentFrame) {
      this.currentFrame = targetFrame;
      if (this.onFrameChange) {
        this.onFrameChange(this.currentFrame, this.frames[this.currentFrame]);
      }
    }
    
    // Check if playback complete
    if (this.currentFrame >= this.totalFrames - 1) {
      this.isPlaying = false;
      if (this.onPlaybackEnd) {
        this.onPlaybackEnd();
      }
      Log.ok('playback', 'Playback complete');
      return;
    }
    
    this.animationId = requestAnimationFrame(() => this._playbackLoop());
  }
  
  getCurrentFrame() {
    return this.frames[this.currentFrame] || null;
  }
  
  getProgress() {
    if (this.totalFrames === 0) return 0;
    return (this.currentFrame / (this.totalFrames - 1)) * 100;
  }
  
  getTimeString() {
    const frame = this.frames[this.currentFrame];
    return frame ? U.formatTime(frame.timestamp) : '0:00';
  }
  
  getState() {
    return {
      isPlaying: this.isPlaying,
      isPaused: this.isPaused,
      currentFrame: this.currentFrame,
      totalFrames: this.totalFrames,
      progress: this.getProgress(),
      speed: this.playbackSpeed,
      time: this.getTimeString()
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FRAME VIEWER â€” Visual Frame Browser
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class FrameViewer {
  constructor(canvasId = 'frame-canvas') {
    this.canvasId = canvasId;
    this.canvas = null;
    this.ctx = null;
    this.currentFrame = null;
    this.showGrid = true;
    this.showWH = true;
    this.showTheory = true;
    this.gridSize = 8;
  }
  
  init() {
    this.canvas = document.getElementById(this.canvasId);
    if (!this.canvas) return false;
    this.ctx = this.canvas.getContext('2d');
    return true;
  }
  
  render(frameData) {
    if (!this.ctx || !frameData) return;
    this.currentFrame = frameData;
    
    const visual = frameData.visual;
    const grid = visual?.grid;
    
    if (!grid) {
      this._renderPlaceholder();
      return;
    }
    
    const cellW = this.canvas.width / grid[0].length;
    const cellH = this.canvas.height / grid.length;
    
    // Draw grid
    for (let y = 0; y < grid.length; y++) {
      for (let x = 0; x < grid[0].length; x++) {
        const cell = grid[y][x];
        this.ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
        this.ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }
    
    // Draw overlay info
    if (this.showGrid) {
      this._drawGridLines(grid[0].length, grid.length, cellW, cellH);
    }
  }
  
  _renderPlaceholder() {
    this.ctx.fillStyle = '#1a1a2a';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = '#606070';
    this.ctx.font = '12px sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('No frame data', this.canvas.width / 2, this.canvas.height / 2);
  }
  
  _drawGridLines(cols, rows, cellW, cellH) {
    this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    this.ctx.lineWidth = 0.5;
    
    for (let x = 1; x < cols; x++) {
      this.ctx.beginPath();
      this.ctx.moveTo(x * cellW, 0);
      this.ctx.lineTo(x * cellW, this.canvas.height);
      this.ctx.stroke();
    }
    
    for (let y = 1; y < rows; y++) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y * cellH);
      this.ctx.lineTo(this.canvas.width, y * cellH);
      this.ctx.stroke();
    }
  }
  
  renderFrameInfo(frameData) {
    if (!frameData) return '';
    
    const visual = frameData.visual || {};
    const theory = frameData.theoretical || {};
    const wh = frameData.wh || {};
    
    return `
FRAME ${frameData.index}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Time: ${U.formatTime(frameData.timestamp || 0)}
Signature: ${frameData.signature?.slice(0, 16) || 'â€”'}...

VISUAL
â€¢ Scene: ${visual.sceneType || 'unknown'}
â€¢ Entropy: ${visual.entropy?.total?.toFixed(3) || 'â€”'}
â€¢ Motion: ${visual.motionDelta?.toFixed(3) || 'â€”'}
â€¢ Luminance: ${visual.stats?.luminance?.toFixed(3) || 'â€”'}

THEORETICAL
â€¢ Score: ${theory.theoreticalScore?.toFixed(1) || 'â€”'}
â€¢ Phase: ${theory.thermodynamics?.phase || 'â€”'}
â€¢ Lyapunov: ${theory.dynamicalSystems?.lyapunov?.toFixed(3) || 'â€”'}

WH SEMANTICS
â€¢ What: ${wh.what || 'â€”'}
â€¢ Where: ${wh.where || 'â€”'}
â€¢ When: ${wh.when || 'â€”'}
â€¢ Why: ${wh.why || 'â€”'}
â€¢ How: ${wh.how || 'â€”'}

CAUSAL (${frameData.causalInferences?.length || 0})
${(frameData.causalInferences || []).slice(0, 3).map(i => `â€¢ ${i.type} (${(i.confidence * 100).toFixed(0)}%)`).join('\n')}`;
  }
  
  getAttentionMap(frameData) {
    if (!frameData?.visual?.grid) return null;
    
    const grid = frameData.visual.grid;
    const avgLum = frameData.visual.stats?.luminance || 0.5;
    
    return grid.map((row, y) => 
      row.map((cell, x) => {
        let edge = 0;
        if (y > 0) edge += Math.abs(cell.lum - grid[y-1][x].lum);
        if (x > 0) edge += Math.abs(cell.lum - grid[y][x-1].lum);
        edge /= 2;
        
        const lumVar = Math.abs(cell.lum - avgLum);
        return Math.min(1, edge * 0.6 + lumVar * 0.4);
      })
    );
  }
  
  renderAttentionOverlay(attention) {
    if (!this.ctx || !attention) return;
    
    const cellW = this.canvas.width / attention[0].length;
    const cellH = this.canvas.height / attention.length;
    
    for (let y = 0; y < attention.length; y++) {
      for (let x = 0; x < attention[0].length; x++) {
        const a = attention[y][x];
        if (a > 0.3) {
          this.ctx.fillStyle = `rgba(255, 100, 100, ${a * 0.4})`;
          this.ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
        }
      }
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COMPARISON VIEW â€” Side-by-side Frame Analysis
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ComparisonView {
  constructor() {
    this.frameA = null;
    this.frameB = null;
  }
  
  setFrames(a, b) {
    this.frameA = a;
    this.frameB = b;
  }
  
  compare() {
    if (!this.frameA || !this.frameB) return null;
    
    const visA = this.frameA.visual || {};
    const visB = this.frameB.visual || {};
    const thA = this.frameA.theoretical || {};
    const thB = this.frameB.theoretical || {};
    
    return {
      frameDelta: Math.abs(this.frameA.index - this.frameB.index),
      timeDelta: Math.abs((this.frameA.timestamp || 0) - (this.frameB.timestamp || 0)),
      entropyDelta: Math.abs((visA.entropy?.total || 0) - (visB.entropy?.total || 0)),
      motionDelta: Math.abs((visA.motionDelta || 0) - (visB.motionDelta || 0)),
      luminanceDelta: Math.abs((visA.stats?.luminance || 0) - (visB.stats?.luminance || 0)),
      scoreDelta: Math.abs((thA.theoreticalScore || 0) - (thB.theoreticalScore || 0)),
      sceneChanged: visA.sceneType !== visB.sceneType,
      phaseChanged: thA.thermodynamics?.phase !== thB.thermodynamics?.phase
    };
  }
  
  getSummary() {
    const diff = this.compare();
    if (!diff) return 'No frames to compare';
    
    return `
FRAME COMPARISON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame A: ${this.frameA.index} @ ${U.formatTime(this.frameA.timestamp || 0)}
Frame B: ${this.frameB.index} @ ${U.formatTime(this.frameB.timestamp || 0)}

DELTAS
â€¢ Frames: ${diff.frameDelta}
â€¢ Time: ${U.formatTime(diff.timeDelta)}
â€¢ Entropy: ${diff.entropyDelta.toFixed(3)}
â€¢ Motion: ${diff.motionDelta.toFixed(3)}
â€¢ Luminance: ${diff.luminanceDelta.toFixed(3)}
â€¢ Score: ${diff.scoreDelta.toFixed(1)}

CHANGES
â€¢ Scene: ${diff.sceneChanged ? 'YES' : 'No'}
â€¢ Phase: ${diff.phaseChanged ? 'YES' : 'No'}`;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// METRICS GRAPH â€” Time-series Visualization
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class MetricsGraph {
  constructor(canvasId) {
    this.canvasId = canvasId;
    this.canvas = null;
    this.ctx = null;
    this.data = {
      entropy: [],
      motion: [],
      score: [],
      luminance: []
    };
    this.colors = {
      entropy: '#22ddee',
      motion: '#ff8844',
      score: '#8855ff',
      luminance: '#ffc744'
    };
    this.showMetrics = {
      entropy: true,
      motion: true,
      score: false,
      luminance: false
    };
    this.hoveredFrame = -1;
  }
  
  init() {
    this.canvas = document.getElementById(this.canvasId);
    if (!this.canvas) return false;
    this.ctx = this.canvas.getContext('2d');
    return true;
  }
  
  updateFromContainer(container) {
    if (!container || container.frames.length === 0) return;
    
    this.data = {
      entropy: [],
      motion: [],
      score: [],
      luminance: []
    };
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual') || {};
      const theory = frame.theoretical || {};
      
      this.data.entropy.push(visual.entropy?.total || 0);
      this.data.motion.push(visual.motionDelta || 0);
      this.data.score.push((theory.theoreticalScore || 0) / 100);
      this.data.luminance.push(visual.stats?.luminance || 0);
    });
    
    this.render();
  }
  
  render() {
    if (!this.ctx) return;
    
    const w = this.canvas.width;
    const h = this.canvas.height;
    const padding = { top: 10, right: 10, bottom: 20, left: 30 };
    const graphW = w - padding.left - padding.right;
    const graphH = h - padding.top - padding.bottom;
    
    // Clear
    this.ctx.fillStyle = '#0c0c14';
    this.ctx.fillRect(0, 0, w, h);
    
    // Grid
    this.ctx.strokeStyle = '#1e1e32';
    this.ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (graphH / 4) * i;
      this.ctx.beginPath();
      this.ctx.moveTo(padding.left, y);
      this.ctx.lineTo(w - padding.right, y);
      this.ctx.stroke();
    }
    
    // Y-axis labels
    this.ctx.fillStyle = '#606070';
    this.ctx.font = '8px sans-serif';
    this.ctx.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (graphH / 4) * i;
      const val = (1 - i / 4).toFixed(1);
      this.ctx.fillText(val, padding.left - 4, y + 3);
    }
    
    // Draw each metric
    const numPoints = Math.max(...Object.values(this.data).map(d => d.length));
    if (numPoints === 0) return;
    
    const xStep = graphW / Math.max(1, numPoints - 1);
    
    Object.keys(this.showMetrics).forEach(metric => {
      if (!this.showMetrics[metric]) return;
      
      const values = this.data[metric];
      if (values.length === 0) return;
      
      this.ctx.strokeStyle = this.colors[metric];
      this.ctx.lineWidth = 1.5;
      this.ctx.beginPath();
      
      values.forEach((val, i) => {
        const x = padding.left + i * xStep;
        const y = padding.top + graphH * (1 - Math.min(1, Math.max(0, val)));
        
        if (i === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }
      });
      
      this.ctx.stroke();
    });
    
    // Hovered frame indicator
    if (this.hoveredFrame >= 0 && this.hoveredFrame < numPoints) {
      const x = padding.left + this.hoveredFrame * xStep;
      this.ctx.strokeStyle = '#ffffff';
      this.ctx.lineWidth = 1;
      this.ctx.setLineDash([3, 3]);
      this.ctx.beginPath();
      this.ctx.moveTo(x, padding.top);
      this.ctx.lineTo(x, h - padding.bottom);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
    }
    
    // X-axis labels
    this.ctx.fillStyle = '#606070';
    this.ctx.textAlign = 'center';
    const labelStep = Math.max(1, Math.floor(numPoints / 5));
    for (let i = 0; i < numPoints; i += labelStep) {
      const x = padding.left + i * xStep;
      this.ctx.fillText(i.toString(), x, h - 5);
    }
  }
  
  setHoveredFrame(frameIndex) {
    this.hoveredFrame = frameIndex;
    this.render();
  }
  
  toggleMetric(metric) {
    if (this.showMetrics.hasOwnProperty(metric)) {
      this.showMetrics[metric] = !this.showMetrics[metric];
      this.render();
    }
  }
  
  frameAtPosition(x) {
    if (!this.canvas) return -1;
    
    const padding = { left: 30, right: 10 };
    const graphW = this.canvas.width - padding.left - padding.right;
    const numPoints = Math.max(...Object.values(this.data).map(d => d.length));
    
    if (x < padding.left || x > this.canvas.width - padding.right) return -1;
    
    const relX = x - padding.left;
    return Math.round((relX / graphW) * (numPoints - 1));
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FILMSTRIP VIEW â€” Thumbnail Timeline
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class FilmstripView {
  constructor(containerId) {
    this.containerId = containerId;
    this.container = null;
    this.thumbnails = [];
    this.selectedFrame = -1;
    this.thumbWidth = 48;
    this.thumbHeight = 36;
    this.onFrameSelect = null;
  }
  
  init() {
    this.container = document.getElementById(this.containerId);
    return !!this.container;
  }
  
  updateFromContainer(realityContainer) {
    if (!realityContainer || realityContainer.frames.length === 0) return;
    if (!this.container) return;
    
    this.thumbnails = [];
    
    // Sample frames (every Nth frame based on count)
    const maxThumbs = 30;
    const frameCount = realityContainer.frames.length;
    const step = Math.max(1, Math.floor(frameCount / maxThumbs));
    
    this.container.innerHTML = '';
    
    for (let i = 0; i < frameCount; i += step) {
      const frame = realityContainer.frames[i];
      const visual = frame.getLayer('visual');
      
      if (!visual?.grid) continue;
      
      const thumb = this._createThumbnail(i, visual.grid, visual.sceneType);
      this.container.appendChild(thumb);
      this.thumbnails.push({ index: i, element: thumb });
    }
  }
  
  _createThumbnail(frameIndex, grid, sceneType) {
    const canvas = document.createElement('canvas');
    canvas.width = this.thumbWidth;
    canvas.height = this.thumbHeight;
    canvas.className = 'filmstrip-thumb';
    canvas.dataset.frame = frameIndex;
    
    const ctx = canvas.getContext('2d');
    const cellW = this.thumbWidth / grid[0].length;
    const cellH = this.thumbHeight / grid.length;
    
    // Draw grid
    for (let y = 0; y < grid.length; y++) {
      for (let x = 0; x < grid[0].length; x++) {
        const cell = grid[y][x];
        ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
        ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }
    
    // Frame number overlay
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, this.thumbHeight - 12, 24, 12);
    ctx.fillStyle = '#fff';
    ctx.font = '8px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(frameIndex.toString(), 2, this.thumbHeight - 3);
    
    // Click handler
    canvas.onclick = () => {
      this.selectFrame(frameIndex);
      if (this.onFrameSelect) {
        this.onFrameSelect(frameIndex);
      }
    };
    
    return canvas;
  }
  
  selectFrame(frameIndex) {
    this.selectedFrame = frameIndex;
    
    this.thumbnails.forEach(t => {
      t.element.classList.toggle('selected', t.index === frameIndex);
    });
  }
  
  scrollToFrame(frameIndex) {
    const thumb = this.thumbnails.find(t => t.index === frameIndex);
    if (thumb && thumb.element) {
      thumb.element.scrollIntoView({ behavior: 'smooth', inline: 'center' });
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ANNOTATION MANAGER â€” Frame Notes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AnnotationManager {
  constructor() {
    this.annotations = new Map(); // frameIndex -> { text, tags, timestamp }
    this.onAnnotationChange = null;
  }
  
  add(frameIndex, text, tags = []) {
    this.annotations.set(frameIndex, {
      text,
      tags,
      timestamp: U.timestamp(),
      updated: U.timestamp()
    });
    
    if (this.onAnnotationChange) {
      this.onAnnotationChange('add', frameIndex);
    }
    
    // Persist to IndexedDB
    this._persist();
  }
  
  update(frameIndex, text, tags = null) {
    const existing = this.annotations.get(frameIndex);
    if (!existing) return false;
    
    existing.text = text;
    if (tags !== null) existing.tags = tags;
    existing.updated = U.timestamp();
    
    if (this.onAnnotationChange) {
      this.onAnnotationChange('update', frameIndex);
    }
    
    this._persist();
    return true;
  }
  
  remove(frameIndex) {
    const had = this.annotations.delete(frameIndex);
    
    if (had && this.onAnnotationChange) {
      this.onAnnotationChange('remove', frameIndex);
    }
    
    this._persist();
    return had;
  }
  
  get(frameIndex) {
    return this.annotations.get(frameIndex) || null;
  }
  
  getAll() {
    return Array.from(this.annotations.entries()).map(([index, data]) => ({
      frameIndex: index,
      ...data
    })).sort((a, b) => a.frameIndex - b.frameIndex);
  }
  
  getByTag(tag) {
    return this.getAll().filter(a => a.tags.includes(tag));
  }
  
  getAllTags() {
    const tags = new Set();
    this.annotations.forEach(a => a.tags.forEach(t => tags.add(t)));
    return Array.from(tags).sort();
  }
  
  getCount() {
    return this.annotations.size;
  }
  
  hasAnnotation(frameIndex) {
    return this.annotations.has(frameIndex);
  }
  
  clear() {
    this.annotations.clear();
    this._persist();
  }
  
  async _persist() {
    try {
      const sessionId = recordingSession.id;
      if (!sessionId) return;
      
      const data = Array.from(this.annotations.entries());
      await persistence.saveSetting(`annotations_${sessionId}`, data);
    } catch (err) {
      console.warn('Failed to persist annotations:', err);
    }
  }
  
  async load(sessionId) {
    try {
      const data = await persistence.getSetting(`annotations_${sessionId}`);
      if (data && Array.isArray(data)) {
        this.annotations = new Map(data);
      }
    } catch (err) {
      console.warn('Failed to load annotations:', err);
    }
  }
  
  toJSON() {
    return Array.from(this.annotations.entries());
  }
  
  fromJSON(data) {
    if (Array.isArray(data)) {
      this.annotations = new Map(data);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SCENE TIMELINE â€” Colored Scene Segments
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SceneTimeline {
  constructor(containerId) {
    this.containerId = containerId;
    this.container = null;
    this.scenes = [];
    this.totalFrames = 0;
    this.onSceneClick = null;
    
    this.sceneColors = {
      'dark_scene': '#334455',
      'bright_scene': '#ffdd88',
      'colorful_scene': '#ff88aa',
      'flat_scene': '#556677',
      'detailed_scene': '#88ccff',
      'normal_scene': '#5588aa',
      'unknown': '#444466'
    };
  }
  
  init() {
    this.container = document.getElementById(this.containerId);
    return !!this.container;
  }
  
  updateFromContainer(realityContainer) {
    if (!realityContainer) return;
    if (!this.container) return;
    
    this.totalFrames = realityContainer.frames.length;
    this.scenes = realityContainer.getSceneSummary();
    
    this.render();
  }
  
  render() {
    if (!this.container || this.totalFrames === 0) return;
    
    this.container.innerHTML = '';
    
    this.scenes.forEach((scene, i) => {
      const [start, end] = scene.frames.split('-').map(Number);
      const duration = end - start + 1;
      const widthPercent = (duration / this.totalFrames) * 100;
      
      const segment = document.createElement('div');
      segment.className = 'scene-segment';
      segment.style.width = `${widthPercent}%`;
      segment.style.background = this.sceneColors[scene.dominantType] || this.sceneColors.unknown;
      segment.title = `Scene ${i + 1}: F${start}-${end} (${scene.dominantType})`;
      segment.dataset.sceneIndex = i;
      segment.dataset.startFrame = start;
      segment.dataset.endFrame = end;
      
      // Tags indicator
      if (scene.tags && scene.tags.length > 0) {
        const tagDot = document.createElement('span');
        tagDot.className = 'scene-tag-indicator';
        tagDot.textContent = scene.tags.length;
        segment.appendChild(tagDot);
      }
      
      segment.onclick = () => {
        if (this.onSceneClick) {
          this.onSceneClick(i, start, end);
        }
      };
      
      this.container.appendChild(segment);
    });
  }
  
  highlightScene(sceneIndex) {
    const segments = this.container?.querySelectorAll('.scene-segment');
    segments?.forEach((seg, i) => {
      seg.classList.toggle('highlighted', i === sceneIndex);
    });
  }
  
  getSceneAtFrame(frameIndex) {
    return this.scenes.findIndex(scene => {
      const [start, end] = scene.frames.split('-').map(Number);
      return frameIndex >= start && frameIndex <= end;
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ANALYTICS DASHBOARD â€” Combined Visualization
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AnalyticsDashboard {
  constructor() {
    this.metricsGraph = null;
    this.filmstrip = null;
    this.sceneTimeline = null;
    this.isOpen = false;
  }
  
  init() {
    this.metricsGraph = new MetricsGraph('analytics-graph');
    this.filmstrip = new FilmstripView('analytics-filmstrip');
    this.sceneTimeline = new SceneTimeline('analytics-scenes');
    
    this.metricsGraph.init();
    this.filmstrip.init();
    this.sceneTimeline.init();
    
    // Connect filmstrip to playback
    this.filmstrip.onFrameSelect = (frameIndex) => {
      playbackEngine.seek(frameIndex);
      updatePlaybackUI();
      renderCurrentFrame();
    };
    
    // Connect scene timeline to playback
    this.sceneTimeline.onSceneClick = (sceneIndex, startFrame, endFrame) => {
      playbackEngine.seek(startFrame);
      updatePlaybackUI();
      renderCurrentFrame();
    };
  }
  
  update(container) {
    if (!container) return;
    
    this.metricsGraph?.updateFromContainer(container);
    this.filmstrip?.updateFromContainer(container);
    this.sceneTimeline?.updateFromContainer(container);
  }
  
  setHoveredFrame(frameIndex) {
    this.metricsGraph?.setHoveredFrame(frameIndex);
    this.filmstrip?.selectFrame(frameIndex);
    
    const sceneIndex = this.sceneTimeline?.getSceneAtFrame(frameIndex);
    if (sceneIndex >= 0) {
      this.sceneTimeline?.highlightScene(sceneIndex);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CLIP EXPORTER â€” Export Frame Ranges
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ClipExporter {
  constructor() {
    this.startFrame = 0;
    this.endFrame = 0;
    this.container = null;
  }
  
  setRange(start, end) {
    this.startFrame = Math.max(0, start);
    this.endFrame = Math.max(this.startFrame, end);
  }
  
  setContainer(container) {
    this.container = container;
    if (container) {
      this.endFrame = Math.min(this.endFrame, container.frames.length - 1);
    }
  }
  
  getFrameCount() {
    return this.endFrame - this.startFrame + 1;
  }
  
  getFrames() {
    if (!this.container) return [];
    return this.container.frames.slice(this.startFrame, this.endFrame + 1);
  }
  
  async exportAsJSON(filename = 'clip.json') {
    if (!this.container) return { success: false, error: 'No container' };
    
    const frames = this.getFrames();
    const data = {
      version: '2.8',
      type: 'clip',
      exported: new Date().toISOString(),
      range: { start: this.startFrame, end: this.endFrame, count: frames.length },
      frames: frames.map(f => ({
        index: f.index,
        timestamp: f.timestamp,
        wh: f.wh,
        theoretical: f.theoretical,
        causalInferences: f.causalInferences,
        visual: {
          entropy: f.getLayer('visual')?.entropy,
          motionDelta: f.getLayer('visual')?.motionDelta,
          sceneType: f.getLayer('visual')?.sceneType,
          stats: f.getLayer('visual')?.stats,
          grid: f.getLayer('visual')?.grid
        }
      }))
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    return { success: true, size: blob.size, frameCount: frames.length };
  }
  
  async exportAsGIF(filename = 'clip.gif', delay = 100) {
    if (!this.container) return { success: false, error: 'No container' };
    
    const frames = this.getFrames();
    if (frames.length === 0) return { success: false, error: 'No frames' };
    
    // Simple GIF generation using canvas snapshots
    const canvas = document.createElement('canvas');
    canvas.width = 160;
    canvas.height = 120;
    const ctx = canvas.getContext('2d');
    
    // For now, create a single combined image showing frame grid
    const cols = Math.min(5, frames.length);
    const rows = Math.ceil(frames.length / cols);
    const thumbW = 32;
    const thumbH = 24;
    
    canvas.width = cols * thumbW;
    canvas.height = rows * thumbH;
    
    frames.forEach((frame, i) => {
      const grid = frame.getLayer('visual')?.grid;
      if (!grid) return;
      
      const x = (i % cols) * thumbW;
      const y = Math.floor(i / cols) * thumbH;
      const cellW = thumbW / grid[0].length;
      const cellH = thumbH / grid.length;
      
      for (let gy = 0; gy < grid.length; gy++) {
        for (let gx = 0; gx < grid[0].length; gx++) {
          const cell = grid[gy][gx];
          ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
          ctx.fillRect(x + gx * cellW, y + gy * cellH, cellW + 1, cellH + 1);
        }
      }
    });
    
    const dataUrl = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = filename.replace('.gif', '.png'); // PNG for now
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    return { success: true, frameCount: frames.length };
  }
  
  getPreview() {
    const frames = this.getFrames();
    if (frames.length === 0) return null;
    
    return {
      range: `F${this.startFrame} - F${this.endFrame}`,
      count: frames.length,
      duration: frames.length > 1 ? 
        frames[frames.length - 1].timestamp - frames[0].timestamp : 0,
      avgEntropy: frames.reduce((s, f) => s + (f.getLayer('visual')?.entropy?.total || 0), 0) / frames.length,
      avgMotion: frames.reduce((s, f) => s + (f.getLayer('visual')?.motionDelta || 0), 0) / frames.length
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HEATMAP OVERLAY â€” Visual Metric Overlay
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HeatmapOverlay {
  constructor() {
    this.mode = 'none'; // 'none', 'entropy', 'motion', 'attention', 'luminance'
    this.intensity = 0.5;
    this.colors = {
      entropy: { low: [0, 0, 100], high: [255, 100, 100] },
      motion: { low: [0, 100, 0], high: [255, 200, 0] },
      attention: { low: [0, 0, 0], high: [255, 0, 100] },
      luminance: { low: [50, 50, 80], high: [255, 255, 200] }
    };
  }
  
  setMode(mode) {
    this.mode = ['none', 'entropy', 'motion', 'attention', 'luminance'].includes(mode) ? mode : 'none';
  }
  
  setIntensity(intensity) {
    this.intensity = Math.max(0, Math.min(1, intensity));
  }
  
  generateOverlay(frame) {
    if (this.mode === 'none') return null;
    if (!frame) return null;
    
    const visual = frame.getLayer?.('visual') || frame.visual;
    const grid = visual?.grid;
    if (!grid || grid.length === 0) return null;
    
    const rows = grid.length;
    const cols = grid[0].length;
    const overlay = [];
    
    for (let y = 0; y < rows; y++) {
      const row = [];
      for (let x = 0; x < cols; x++) {
        let value = 0;
        
        switch (this.mode) {
          case 'entropy':
            // Local entropy based on neighbor variance
            value = this._localEntropy(grid, x, y);
            break;
          case 'motion':
            // Use motion delta if available, otherwise estimate
            value = visual.motionDelta || 0;
            break;
          case 'attention':
            // Edge + center bias
            value = this._attentionValue(grid, x, y, cols, rows);
            break;
          case 'luminance':
            value = grid[y][x].lum || 0;
            break;
        }
        
        row.push(this._valueToColor(value, this.mode));
      }
      overlay.push(row);
    }
    
    return overlay;
  }
  
  _localEntropy(grid, x, y) {
    const neighbors = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const ny = y + dy;
        const nx = x + dx;
        if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
          neighbors.push(grid[ny][nx].lum || 0);
        }
      }
    }
    
    const mean = neighbors.reduce((a, b) => a + b, 0) / neighbors.length;
    const variance = neighbors.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / neighbors.length;
    return Math.min(1, Math.sqrt(variance) * 3);
  }
  
  _attentionValue(grid, x, y, cols, rows) {
    // Edge strength
    let edge = 0;
    if (y > 0) edge += Math.abs(grid[y][x].lum - grid[y-1][x].lum);
    if (x > 0) edge += Math.abs(grid[y][x].lum - grid[y][x-1].lum);
    edge = Math.min(1, edge * 2);
    
    // Center bias
    const cx = (x - cols/2) / (cols/2);
    const cy = (y - rows/2) / (rows/2);
    const centerBias = Math.exp(-(cx*cx + cy*cy) * 0.5) * 0.3;
    
    return Math.min(1, edge * 0.7 + centerBias);
  }
  
  _valueToColor(value, mode) {
    const colors = this.colors[mode] || this.colors.entropy;
    const v = Math.max(0, Math.min(1, value));
    
    return {
      r: Math.round(colors.low[0] + (colors.high[0] - colors.low[0]) * v),
      g: Math.round(colors.low[1] + (colors.high[1] - colors.low[1]) * v),
      b: Math.round(colors.low[2] + (colors.high[2] - colors.low[2]) * v),
      a: this.intensity * v
    };
  }
  
  renderToCanvas(canvas, overlay) {
    if (!canvas || !overlay) return;
    
    const ctx = canvas.getContext('2d');
    const cellW = canvas.width / overlay[0].length;
    const cellH = canvas.height / overlay.length;
    
    for (let y = 0; y < overlay.length; y++) {
      for (let x = 0; x < overlay[0].length; x++) {
        const c = overlay[y][x];
        ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${c.a})`;
        ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SEARCH RESULTS â€” Visual Frame Search Results
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SearchResults {
  constructor(containerId) {
    this.containerId = containerId;
    this.container = null;
    this.results = [];
    this.thumbWidth = 48;
    this.thumbHeight = 36;
    this.onResultClick = null;
    this.query = '';
  }
  
  init() {
    this.container = document.getElementById(this.containerId);
    return !!this.container;
  }
  
  setResults(frameIndices, realityContainer, queryText = '') {
    this.results = frameIndices;
    this.query = queryText;
    this.render(realityContainer);
  }
  
  render(realityContainer) {
    if (!this.container || !realityContainer) return;
    
    if (this.results.length === 0) {
      this.container.innerHTML = `
        <div style="text-align:center;padding:20px;color:var(--text-muted);font-size:10px">
          ${this.query ? `No results for "${this.query}"` : 'No search results'}
        </div>`;
      return;
    }
    
    this.container.innerHTML = `
      <div style="font-size:9px;color:var(--text-secondary);margin-bottom:8px">
        Found ${this.results.length} frames ${this.query ? `for "${this.query}"` : ''}
      </div>
      <div class="search-results-grid" id="search-grid"></div>
    `;
    
    const grid = document.getElementById('search-grid');
    
    this.results.slice(0, 24).forEach(frameIndex => {
      const frame = realityContainer.frames[frameIndex];
      if (!frame) return;
      
      const visual = frame.getLayer('visual');
      const thumb = this._createThumb(frameIndex, visual?.grid, visual?.sceneType);
      grid.appendChild(thumb);
    });
    
    if (this.results.length > 24) {
      const more = document.createElement('div');
      more.className = 'search-more';
      more.textContent = `+${this.results.length - 24} more`;
      grid.appendChild(more);
    }
  }
  
  _createThumb(frameIndex, grid, sceneType) {
    const canvas = document.createElement('canvas');
    canvas.width = this.thumbWidth;
    canvas.height = this.thumbHeight;
    canvas.className = 'search-result-thumb';
    canvas.dataset.frame = frameIndex;
    canvas.title = `F${frameIndex}`;
    
    const ctx = canvas.getContext('2d');
    
    if (grid) {
      const cellW = this.thumbWidth / grid[0].length;
      const cellH = this.thumbHeight / grid.length;
      
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
          const cell = grid[y][x];
          ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
          ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
        }
      }
    } else {
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, this.thumbWidth, this.thumbHeight);
    }
    
    // Frame number badge
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, this.thumbHeight - 10, 20, 10);
    ctx.fillStyle = '#fff';
    ctx.font = '7px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(frameIndex.toString(), 2, this.thumbHeight - 2);
    
    canvas.onclick = () => {
      if (this.onResultClick) {
        this.onResultClick(frameIndex);
      }
    };
    
    return canvas;
  }
  
  clear() {
    this.results = [];
    this.query = '';
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// QUICK TAGS â€” Fast Frame Categorization
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class QuickTags {
  constructor() {
    this.tags = new Map(); // frameIndex -> Set of tags
    this.predefinedTags = [
      { name: 'important', color: '#ff6666', icon: 'â­' },
      { name: 'motion', color: '#ff8844', icon: 'ðŸ’¨' },
      { name: 'scene', color: '#8855ff', icon: 'ðŸŽ¬' },
      { name: 'anomaly', color: '#ffcc44', icon: 'âš¡' },
      { name: 'good', color: '#22cc88', icon: 'âœ“' },
      { name: 'bad', color: '#ff4466', icon: 'âœ—' }
    ];
  }
  
  addTag(frameIndex, tagName) {
    if (!this.tags.has(frameIndex)) {
      this.tags.set(frameIndex, new Set());
    }
    this.tags.get(frameIndex).add(tagName);
    
    // Also add to symbolic index
    symbolicIndex.tag([frameIndex], tagName);
  }
  
  removeTag(frameIndex, tagName) {
    if (this.tags.has(frameIndex)) {
      this.tags.get(frameIndex).delete(tagName);
      if (this.tags.get(frameIndex).size === 0) {
        this.tags.delete(frameIndex);
      }
    }
    symbolicIndex.untag([frameIndex], tagName);
  }
  
  toggleTag(frameIndex, tagName) {
    if (this.hasTag(frameIndex, tagName)) {
      this.removeTag(frameIndex, tagName);
      return false;
    } else {
      this.addTag(frameIndex, tagName);
      return true;
    }
  }
  
  hasTag(frameIndex, tagName) {
    return this.tags.get(frameIndex)?.has(tagName) || false;
  }
  
  getTags(frameIndex) {
    return Array.from(this.tags.get(frameIndex) || []);
  }
  
  getFramesWithTag(tagName) {
    const frames = [];
    this.tags.forEach((tags, frameIndex) => {
      if (tags.has(tagName)) frames.push(frameIndex);
    });
    return frames.sort((a, b) => a - b);
  }
  
  getAllUsedTags() {
    const allTags = new Set();
    this.tags.forEach(tags => tags.forEach(t => allTags.add(t)));
    return Array.from(allTags).sort();
  }
  
  getTagColor(tagName) {
    const predefined = this.predefinedTags.find(t => t.name === tagName);
    return predefined?.color || '#888888';
  }
  
  getTagIcon(tagName) {
    const predefined = this.predefinedTags.find(t => t.name === tagName);
    return predefined?.icon || 'ðŸ·';
  }
  
  clear() {
    this.tags.clear();
  }
  
  toJSON() {
    const data = {};
    this.tags.forEach((tags, frameIndex) => {
      data[frameIndex] = Array.from(tags);
    });
    return data;
  }
  
  fromJSON(data) {
    this.tags.clear();
    Object.entries(data).forEach(([frameIndex, tags]) => {
      this.tags.set(parseInt(frameIndex), new Set(tags));
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REPORT GENERATOR â€” Comprehensive Analysis Reports
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ReportGenerator {
  constructor() {
    this.formats = ['html', 'markdown', 'json'];
    this.sections = [
      'overview', 'scenes', 'frames', 'theory', 
      'causal', 'timeline', 'annotations', 'stats'
    ];
    this.enabledSections = new Set(this.sections);
  }
  
  toggleSection(section) {
    if (this.enabledSections.has(section)) {
      this.enabledSections.delete(section);
    } else {
      this.enabledSections.add(section);
    }
  }
  
  async generate(container, format = 'html') {
    if (!container || container.frames.length === 0) {
      return { success: false, error: 'No data to report' };
    }
    
    const data = this._collectData(container);
    
    switch (format) {
      case 'html':
        return this._generateHTML(data);
      case 'markdown':
        return this._generateMarkdown(data);
      case 'json':
        return this._generateJSON(data);
      default:
        return { success: false, error: 'Unknown format' };
    }
  }
  
  _collectData(container) {
    const frames = container.frames;
    const scenes = container.getSceneSummary();
    const compression = container.getCompressionStats();
    const annotations = annotationManager.getAll();
    const tags = quickTags.getAllUsedTags();
    
    // Aggregate stats
    const entropies = frames.map(f => f.getLayer('visual')?.entropy?.total || 0);
    const motions = frames.map(f => f.getLayer('visual')?.motionDelta || 0);
    const scores = frames.map(f => f.theoretical?.theoreticalScore || 0);
    
    // Find key frames
    const maxEntropyFrame = frames.reduce((max, f, i) => 
      (f.getLayer('visual')?.entropy?.total || 0) > (frames[max].getLayer('visual')?.entropy?.total || 0) ? i : max, 0);
    const maxMotionFrame = frames.reduce((max, f, i) => 
      (f.getLayer('visual')?.motionDelta || 0) > (frames[max].getLayer('visual')?.motionDelta || 0) ? i : max, 0);
    
    return {
      meta: {
        generated: new Date().toISOString(),
        version: '2.9',
        sessionId: recordingSession.id,
        sessionName: recordingSession.name
      },
      overview: {
        frameCount: frames.length,
        duration: frames.length > 0 ? frames[frames.length - 1].timestamp : 0,
        sceneCount: scenes.length,
        symbolCount: container.symbols.size,
        mode: container.mode
      },
      stats: {
        entropy: { min: Math.min(...entropies), max: Math.max(...entropies), avg: U.mean(entropies), std: U.stdDev(entropies) },
        motion: { min: Math.min(...motions), max: Math.max(...motions), avg: U.mean(motions), std: U.stdDev(motions) },
        score: { min: Math.min(...scores), max: Math.max(...scores), avg: U.mean(scores), std: U.stdDev(scores) }
      },
      scenes,
      compression,
      keyFrames: {
        maxEntropy: maxEntropyFrame,
        maxMotion: maxMotionFrame,
        first: 0,
        last: frames.length - 1
      },
      annotations,
      tags: tags.map(t => ({ name: t, count: quickTags.getFramesWithTag(t).length })),
      causalSummary: this._summarizeCausal(frames)
    };
  }
  
  _summarizeCausal(frames) {
    const allInferences = frames.flatMap(f => f.causalInferences || []);
    const byType = {};
    allInferences.forEach(inf => {
      byType[inf.type] = (byType[inf.type] || 0) + 1;
    });
    
    return {
      total: allInferences.length,
      byType,
      avgConfidence: allInferences.length > 0 ? 
        allInferences.reduce((s, i) => s + (i.confidence || 0), 0) / allInferences.length : 0
    };
  }
  
  _generateHTML(data) {
    const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>VIRECAI Report - ${data.meta.sessionName || 'Recording'}</title>
  <style>
    body { font-family: -apple-system, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background: #0c0c14; color: #e0e0e8; }
    h1 { color: #22ddee; border-bottom: 2px solid #22ddee40; padding-bottom: 10px; }
    h2 { color: #8855ff; margin-top: 30px; }
    h3 { color: #ff8844; }
    .meta { color: #888; font-size: 12px; margin-bottom: 20px; }
    .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
    .stat-card { background: #1a1a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; }
    .stat-value { font-size: 24px; font-weight: bold; color: #22ddee; }
    .stat-label { font-size: 12px; color: #888; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #333; }
    th { background: #1a1a2a; color: #ff8844; }
    .tag { display: inline-block; padding: 3px 8px; border-radius: 10px; font-size: 11px; margin: 2px; background: #333; }
    .scene-bar { height: 20px; display: flex; border-radius: 4px; overflow: hidden; margin: 10px 0; }
    .scene-segment { height: 100%; }
    pre { background: #1a1a2a; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; }
  </style>
</head>
<body>
  <h1>ðŸŽ¬ VIRECAI Analysis Report</h1>
  <div class="meta">Generated: ${data.meta.generated} | Version: ${data.meta.version}</div>
  
  ${this.enabledSections.has('overview') ? `
  <h2>ðŸ“Š Overview</h2>
  <div class="stat-grid">
    <div class="stat-card"><div class="stat-value">${data.overview.frameCount}</div><div class="stat-label">Frames</div></div>
    <div class="stat-card"><div class="stat-value">${U.formatTime(data.overview.duration)}</div><div class="stat-label">Duration</div></div>
    <div class="stat-card"><div class="stat-value">${data.overview.sceneCount}</div><div class="stat-label">Scenes</div></div>
    <div class="stat-card"><div class="stat-value">${data.overview.symbolCount}</div><div class="stat-label">Symbols</div></div>
  </div>` : ''}
  
  ${this.enabledSections.has('stats') ? `
  <h2>ðŸ“ˆ Statistics</h2>
  <table>
    <tr><th>Metric</th><th>Min</th><th>Max</th><th>Avg</th><th>StdDev</th></tr>
    <tr><td>Entropy</td><td>${data.stats.entropy.min.toFixed(3)}</td><td>${data.stats.entropy.max.toFixed(3)}</td><td>${data.stats.entropy.avg.toFixed(3)}</td><td>${data.stats.entropy.std.toFixed(3)}</td></tr>
    <tr><td>Motion</td><td>${data.stats.motion.min.toFixed(3)}</td><td>${data.stats.motion.max.toFixed(3)}</td><td>${data.stats.motion.avg.toFixed(3)}</td><td>${data.stats.motion.std.toFixed(3)}</td></tr>
    <tr><td>Theory Score</td><td>${data.stats.score.min.toFixed(1)}</td><td>${data.stats.score.max.toFixed(1)}</td><td>${data.stats.score.avg.toFixed(1)}</td><td>${data.stats.score.std.toFixed(1)}</td></tr>
  </table>` : ''}
  
  ${this.enabledSections.has('scenes') ? `
  <h2>ðŸŽ¬ Scene Breakdown</h2>
  <table>
    <tr><th>#</th><th>Frames</th><th>Type</th><th>Duration</th></tr>
    ${data.scenes.map((s, i) => `<tr><td>${i + 1}</td><td>${s.frames}</td><td>${s.dominantType}</td><td>${s.duration}</td></tr>`).join('')}
  </table>` : ''}
  
  ${this.enabledSections.has('causal') ? `
  <h2>ðŸ”— Causal Analysis</h2>
  <div class="stat-grid">
    <div class="stat-card"><div class="stat-value">${data.causalSummary.total}</div><div class="stat-label">Total Inferences</div></div>
    <div class="stat-card"><div class="stat-value">${(data.causalSummary.avgConfidence * 100).toFixed(0)}%</div><div class="stat-label">Avg Confidence</div></div>
  </div>
  <h3>By Type</h3>
  <table>
    <tr><th>Type</th><th>Count</th></tr>
    ${Object.entries(data.causalSummary.byType).map(([k, v]) => `<tr><td>${k}</td><td>${v}</td></tr>`).join('')}
  </table>` : ''}
  
  ${this.enabledSections.has('annotations') && data.annotations.length > 0 ? `
  <h2>ðŸ“ Annotations</h2>
  <table>
    <tr><th>Frame</th><th>Note</th></tr>
    ${data.annotations.map(a => `<tr><td>F${a.frameIndex}</td><td>${a.text}</td></tr>`).join('')}
  </table>` : ''}
  
  ${this.enabledSections.has('timeline') && data.tags.length > 0 ? `
  <h2>ðŸ·ï¸ Tags</h2>
  ${data.tags.map(t => `<span class="tag">${t.name} (${t.count})</span>`).join(' ')}` : ''}
  
  <h2>âš™ï¸ Technical</h2>
  <pre>
Mode: ${data.overview.mode}
Compression Ratio: ${data.compression.ratio.toFixed(1)}x
Session: ${data.meta.sessionId || 'N/A'}
  </pre>
  
  <div class="meta" style="margin-top: 40px; text-align: center;">
    Generated by VIRECAI v2.27 â€” Symbolic Reality Capture
  </div>
</body>
</html>`;
    
    return { success: true, content: html, format: 'html', size: html.length };
  }
  
  _generateMarkdown(data) {
    const md = `# VIRECAI Analysis Report

**Generated:** ${data.meta.generated}  
**Version:** ${data.meta.version}

---

## ðŸ“Š Overview

| Metric | Value |
|--------|-------|
| Frames | ${data.overview.frameCount} |
| Duration | ${U.formatTime(data.overview.duration)} |
| Scenes | ${data.overview.sceneCount} |
| Symbols | ${data.overview.symbolCount} |
| Mode | ${data.overview.mode} |

## ðŸ“ˆ Statistics

| Metric | Min | Max | Avg | StdDev |
|--------|-----|-----|-----|--------|
| Entropy | ${data.stats.entropy.min.toFixed(3)} | ${data.stats.entropy.max.toFixed(3)} | ${data.stats.entropy.avg.toFixed(3)} | ${data.stats.entropy.std.toFixed(3)} |
| Motion | ${data.stats.motion.min.toFixed(3)} | ${data.stats.motion.max.toFixed(3)} | ${data.stats.motion.avg.toFixed(3)} | ${data.stats.motion.std.toFixed(3)} |
| Score | ${data.stats.score.min.toFixed(1)} | ${data.stats.score.max.toFixed(1)} | ${data.stats.score.avg.toFixed(1)} | ${data.stats.score.std.toFixed(1)} |

## ðŸŽ¬ Scenes

${data.scenes.map((s, i) => `${i + 1}. **${s.dominantType}** â€” Frames ${s.frames} (${s.duration})`).join('\n')}

## ðŸ”— Causal Analysis

- Total Inferences: **${data.causalSummary.total}**
- Average Confidence: **${(data.causalSummary.avgConfidence * 100).toFixed(0)}%**

${Object.entries(data.causalSummary.byType).map(([k, v]) => `- ${k}: ${v}`).join('\n')}

${data.annotations.length > 0 ? `
## ðŸ“ Annotations

${data.annotations.map(a => `- **F${a.frameIndex}:** ${a.text}`).join('\n')}
` : ''}

${data.tags.length > 0 ? `
## ðŸ·ï¸ Tags

${data.tags.map(t => `- ${t.name}: ${t.count} frames`).join('\n')}
` : ''}

---

*Generated by VIRECAI v2.27 â€” Symbolic Reality Capture*
`;
    
    return { success: true, content: md, format: 'markdown', size: md.length };
  }
  
  _generateJSON(data) {
    const json = JSON.stringify(data, null, 2);
    return { success: true, content: json, format: 'json', size: json.length };
  }
  
  async download(container, format = 'html') {
    const result = await this.generate(container, format);
    if (!result.success) return result;
    
    const ext = format === 'markdown' ? 'md' : format;
    const filename = `virecai_report_${Date.now()}.${ext}`;
    const mimeType = format === 'json' ? 'application/json' : 'text/plain';
    
    const blob = new Blob([result.content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    return { success: true, filename, size: result.size };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TIMELINE MARKERS â€” Visual Event Markers on Timeline
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TimelineMarkerManager {
  constructor() {
    this.markers = []; // { frameIndex, type, label, color }
    this.markerTypes = {
      'scene': { color: '#8855ff', icon: 'ðŸŽ¬' },
      'motion': { color: '#ff8844', icon: 'ðŸ’¨' },
      'anomaly': { color: '#ffcc44', icon: 'âš¡' },
      'bookmark': { color: '#22ddee', icon: 'ðŸ”–' },
      'note': { color: '#88cc44', icon: 'ðŸ“' },
      'key': { color: '#ff6666', icon: 'â­' }
    };
  }
  
  add(frameIndex, type, label = '') {
    const typeInfo = this.markerTypes[type] || this.markerTypes.bookmark;
    this.markers.push({
      id: U.uid(),
      frameIndex,
      type,
      label,
      color: typeInfo.color,
      icon: typeInfo.icon,
      timestamp: U.timestamp()
    });
    this.markers.sort((a, b) => a.frameIndex - b.frameIndex);
  }
  
  remove(id) {
    const idx = this.markers.findIndex(m => m.id === id);
    if (idx >= 0) {
      this.markers.splice(idx, 1);
      return true;
    }
    return false;
  }
  
  removeAtFrame(frameIndex) {
    this.markers = this.markers.filter(m => m.frameIndex !== frameIndex);
  }
  
  getAtFrame(frameIndex) {
    return this.markers.filter(m => m.frameIndex === frameIndex);
  }
  
  getByType(type) {
    return this.markers.filter(m => m.type === type);
  }
  
  getInRange(start, end) {
    return this.markers.filter(m => m.frameIndex >= start && m.frameIndex <= end);
  }
  
  autoDetect(container) {
    if (!container || container.frames.length === 0) return;
    
    // Clear existing auto-markers
    this.markers = this.markers.filter(m => m.type === 'bookmark' || m.type === 'note');
    
    // Detect scene changes
    let lastScene = null;
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      const scene = visual?.sceneType;
      if (scene && scene !== lastScene && i > 0) {
        this.add(i, 'scene', `Scene: ${scene}`);
      }
      lastScene = scene;
    });
    
    // Detect high motion frames
    const motions = container.frames.map(f => f.getLayer('visual')?.motionDelta || 0);
    const avgMotion = U.mean(motions);
    const stdMotion = U.stdDev(motions);
    const threshold = avgMotion + 2 * stdMotion;
    
    container.frames.forEach((frame, i) => {
      const motion = frame.getLayer('visual')?.motionDelta || 0;
      if (motion > threshold && motion > 0.3) {
        this.add(i, 'motion', `High motion: ${motion.toFixed(2)}`);
      }
    });
  }
  
  render(containerId, totalFrames) {
    const container = document.getElementById(containerId);
    if (!container || totalFrames === 0) return;
    
    container.innerHTML = '';
    
    this.markers.forEach(marker => {
      const pos = (marker.frameIndex / (totalFrames - 1)) * 100;
      const el = document.createElement('div');
      el.className = 'timeline-marker-dot';
      el.style.left = `${pos}%`;
      el.style.background = marker.color;
      el.title = `F${marker.frameIndex}: ${marker.label || marker.type}`;
      el.dataset.markerId = marker.id;
      el.dataset.frame = marker.frameIndex;
      container.appendChild(el);
    });
  }
  
  clear() {
    this.markers = [];
  }
  
  toJSON() {
    return this.markers;
  }
  
  fromJSON(data) {
    this.markers = data || [];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BOOKMARKS â€” Quick Access to Important Frames
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BookmarkManager {
  constructor() {
    this.bookmarks = []; // { frameIndex, name, color, created }
    this.maxBookmarks = 20;
  }
  
  add(frameIndex, name = '') {
    if (this.bookmarks.length >= this.maxBookmarks) {
      return { success: false, error: 'Max bookmarks reached' };
    }
    
    // Check if already bookmarked
    if (this.bookmarks.some(b => b.frameIndex === frameIndex)) {
      return { success: false, error: 'Frame already bookmarked' };
    }
    
    const colors = ['#ff6666', '#ffaa44', '#ffee44', '#66dd66', '#44aaff', '#aa66ff'];
    
    this.bookmarks.push({
      id: U.uid(),
      frameIndex,
      name: name || `Bookmark ${this.bookmarks.length + 1}`,
      color: colors[this.bookmarks.length % colors.length],
      created: U.timestamp()
    });
    
    this.bookmarks.sort((a, b) => a.frameIndex - b.frameIndex);
    
    // Also add timeline marker
    timelineMarkers.add(frameIndex, 'bookmark', name || 'Bookmark');
    
    return { success: true };
  }
  
  remove(id) {
    const idx = this.bookmarks.findIndex(b => b.id === id);
    if (idx >= 0) {
      const bookmark = this.bookmarks[idx];
      this.bookmarks.splice(idx, 1);
      timelineMarkers.removeAtFrame(bookmark.frameIndex);
      return true;
    }
    return false;
  }
  
  get(frameIndex) {
    return this.bookmarks.find(b => b.frameIndex === frameIndex);
  }
  
  getAll() {
    return [...this.bookmarks];
  }
  
  getByIndex(index) {
    return this.bookmarks[index] || null;
  }
  
  rename(id, newName) {
    const bookmark = this.bookmarks.find(b => b.id === id);
    if (bookmark) {
      bookmark.name = newName;
      return true;
    }
    return false;
  }
  
  hasBookmark(frameIndex) {
    return this.bookmarks.some(b => b.frameIndex === frameIndex);
  }
  
  getNext(currentFrame) {
    return this.bookmarks.find(b => b.frameIndex > currentFrame);
  }
  
  getPrev(currentFrame) {
    const prev = this.bookmarks.filter(b => b.frameIndex < currentFrame);
    return prev.length > 0 ? prev[prev.length - 1] : null;
  }
  
  clear() {
    this.bookmarks = [];
  }
  
  toJSON() {
    return this.bookmarks;
  }
  
  fromJSON(data) {
    this.bookmarks = data || [];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COMMAND PALETTE â€” Quick Action Interface
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class CommandPalette {
  constructor() {
    this.isOpen = false;
    this.commands = [];
    this.filteredCommands = [];
    this.selectedIndex = 0;
    this._initCommands();
  }
  
  _initCommands() {
    this.commands = [
      // Navigation
      { id: 'play', label: 'Play/Pause Playback', category: 'Playback', action: () => playbackPlay() },
      { id: 'next', label: 'Next Frame', category: 'Playback', action: () => playbackNext() },
      { id: 'prev', label: 'Previous Frame', category: 'Playback', action: () => playbackPrev() },
      { id: 'first', label: 'Go to First Frame', category: 'Playback', action: () => playbackEngine.seek(0) },
      { id: 'last', label: 'Go to Last Frame', category: 'Playback', action: () => playbackEngine.seek(playbackEngine.totalFrames - 1) },
      
      // Panels
      { id: 'playback', label: 'Open Playback Panel', category: 'Panels', action: openPlaybackPanel },
      { id: 'compare', label: 'Open Compare Panel', category: 'Panels', action: openComparePanel },
      { id: 'analytics', label: 'Open Analytics Panel', category: 'Panels', action: openAnalyticsPanel },
      { id: 'clip', label: 'Open Clip Export', category: 'Panels', action: openClipPanel },
      { id: 'report', label: 'Open Report Panel', category: 'Panels', action: openReportPanel },
      { id: 'theory', label: 'Open Theory Panel', category: 'Panels', action: openTheoryPanel },
      { id: 'settings', label: 'Open Settings', category: 'Panels', action: openSettings },
      
      // Recording
      { id: 'record', label: 'Start/Stop Recording', category: 'Recording', action: toggleRecording },
      { id: 'save', label: 'Save to History', category: 'Recording', action: saveToHistory },
      
      // Export
      { id: 'exportVRC', label: 'Export as VRC', category: 'Export', action: downloadVRC },
      { id: 'exportJSON', label: 'Export as JSON', category: 'Export', action: downloadJSON },
      { id: 'exportReport', label: 'Export HTML Report', category: 'Export', action: () => exportReport('html') },
      { id: 'exportReportMD', label: 'Export Markdown Report', category: 'Export', action: () => exportReport('markdown') },
      
      // Bookmarks
      { id: 'bookmark', label: 'Add Bookmark at Current Frame', category: 'Bookmarks', action: () => addBookmarkAtCurrent() },
      { id: 'nextBookmark', label: 'Go to Next Bookmark', category: 'Bookmarks', action: () => goToNextBookmark() },
      { id: 'prevBookmark', label: 'Go to Previous Bookmark', category: 'Bookmarks', action: () => goToPrevBookmark() },
      
      // Visualization
      { id: 'heatmapNone', label: 'Heatmap: Off', category: 'Visualization', action: () => setHeatmapMode('none') },
      { id: 'heatmapEntropy', label: 'Heatmap: Entropy', category: 'Visualization', action: () => setHeatmapMode('entropy') },
      { id: 'heatmapMotion', label: 'Heatmap: Motion', category: 'Visualization', action: () => setHeatmapMode('motion') },
      { id: 'heatmapAttention', label: 'Heatmap: Attention', category: 'Visualization', action: () => setHeatmapMode('attention') },
      
      // Tags
      { id: 'tagImportant', label: 'Tag Frame as Important', category: 'Tags', action: () => toggleQuickTag(playbackEngine.currentFrame, 'important') },
      { id: 'tagMotion', label: 'Tag Frame as Motion', category: 'Tags', action: () => toggleQuickTag(playbackEngine.currentFrame, 'motion') },
      { id: 'tagAnomaly', label: 'Tag Frame as Anomaly', category: 'Tags', action: () => toggleQuickTag(playbackEngine.currentFrame, 'anomaly') }
    ];
    
    this.filteredCommands = [...this.commands];
  }
  
  open() {
    this.isOpen = true;
    this.filteredCommands = [...this.commands];
    this.selectedIndex = 0;
    this._render();
    
    document.getElementById('command-backdrop').classList.add('open');
    document.getElementById('command-panel').classList.add('open');
    document.getElementById('command-input').value = '';
    document.getElementById('command-input').focus();
  }
  
  close() {
    this.isOpen = false;
    document.getElementById('command-backdrop').classList.remove('open');
    document.getElementById('command-panel').classList.remove('open');
  }
  
  filter(query) {
    const q = query.toLowerCase().trim();
    if (!q) {
      this.filteredCommands = [...this.commands];
    } else {
      this.filteredCommands = this.commands.filter(cmd => 
        cmd.label.toLowerCase().includes(q) || 
        cmd.category.toLowerCase().includes(q) ||
        cmd.id.toLowerCase().includes(q)
      );
    }
    this.selectedIndex = 0;
    this._render();
  }
  
  selectNext() {
    if (this.filteredCommands.length > 0) {
      this.selectedIndex = (this.selectedIndex + 1) % this.filteredCommands.length;
      this._render();
    }
  }
  
  selectPrev() {
    if (this.filteredCommands.length > 0) {
      this.selectedIndex = (this.selectedIndex - 1 + this.filteredCommands.length) % this.filteredCommands.length;
      this._render();
    }
  }
  
  execute() {
    if (this.filteredCommands.length > 0 && this.selectedIndex < this.filteredCommands.length) {
      const cmd = this.filteredCommands[this.selectedIndex];
      this.close();
      cmd.action();
    }
  }
  
  _render() {
    const list = document.getElementById('command-list');
    if (!list) return;
    
    if (this.filteredCommands.length === 0) {
      list.innerHTML = '<div class="command-empty">No matching commands</div>';
      return;
    }
    
    list.innerHTML = this.filteredCommands.map((cmd, i) => `
      <div class="command-item ${i === this.selectedIndex ? 'selected' : ''}" data-index="${i}">
        <span class="command-label">${cmd.label}</span>
        <span class="command-category">${cmd.category}</span>
      </div>
    `).join('');
    
    // Scroll selected into view
    const selected = list.querySelector('.command-item.selected');
    if (selected) {
      selected.scrollIntoView({ block: 'nearest' });
    }
  }
}

// Global instances
const persistence = new PersistenceManager();
const thumbnailGen = new ThumbnailGenerator();
const timelineManager = new TimelineManager();
const perfMonLegacy = new PerfMonLegacy();
const recordingSession = new RecordingSession();
const playbackEngine = new PlaybackEngine();
const frameViewer = new FrameViewer('playback-canvas');
const comparisonView = new ComparisonView();
const metricsGraph = new MetricsGraph('metrics-canvas');
const filmstripView = new FilmstripView('filmstrip-container');
const sceneTimeline = new SceneTimeline('scene-timeline');
const annotationManager = new AnnotationManager();
const analyticsDashboard = new AnalyticsDashboard();
const clipExporter = new ClipExporter();
const heatmapOverlay = new HeatmapOverlay();
const searchResults = new SearchResults('search-results');
const quickTags = new QuickTags();
const reportGenerator = new ReportGenerator();
const timelineMarkers = new TimelineMarkerManager();
const bookmarkManager = new BookmarkManager();
const commandPalette = new CommandPalette();
const symbolicIndex = new SymbolicIndex();
const deltaCompressor = new DeltaCompressor(30);
const eventStore = new EventStore();
const lazyCompute = new LazyCompute();

// Initialize persistence on load
persistence.init().catch(err => console.warn('IndexedDB not available:', err));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEORETICAL FOUNDATIONS â€” Mathematical & Physical Enhancement Layer
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INFORMATION THEORY (Shannon) â€” Entropy, Mutual Information, KL-Divergence
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const InformationTheory = {
  // Shannon entropy: H(X) = -Î£ p(x) logâ‚‚ p(x)
  entropy(distribution) {
    if (!distribution || distribution.length === 0) return 0;
    const total = distribution.reduce((a, b) => a + b, 0);
    if (total === 0) return 0;
    return -distribution.reduce((H, count) => {
      if (count <= 0) return H;
      const p = count / total;
      return H + p * Math.log2(p);
    }, 0);
  },
  
  // Normalized entropy (0-1 scale)
  normalizedEntropy(distribution) {
    const H = this.entropy(distribution);
    const maxH = Math.log2(distribution.length);
    return maxH > 0 ? H / maxH : 0;
  },
  
  // Joint entropy: H(X,Y)
  jointEntropy(joint) {
    const flat = joint.flat();
    return this.entropy(flat);
  },
  
  // Conditional entropy: H(Y|X) = H(X,Y) - H(X)
  conditionalEntropy(joint, marginalX) {
    return this.jointEntropy(joint) - this.entropy(marginalX);
  },
  
  // Mutual information: I(X;Y) = H(X) + H(Y) - H(X,Y)
  mutualInformation(distX, distY, joint) {
    return this.entropy(distX) + this.entropy(distY) - this.jointEntropy(joint);
  },
  
  // KL-Divergence: D_KL(P||Q) = Î£ p(x) log(p(x)/q(x))
  klDivergence(P, Q) {
    if (P.length !== Q.length) return Infinity;
    const totalP = P.reduce((a, b) => a + b, 0);
    const totalQ = Q.reduce((a, b) => a + b, 0);
    if (totalP === 0 || totalQ === 0) return Infinity;
    
    let kl = 0;
    for (let i = 0; i < P.length; i++) {
      const p = P[i] / totalP;
      const q = Q[i] / totalQ;
      if (p > 0 && q > 0) {
        kl += p * Math.log2(p / q);
      } else if (p > 0 && q === 0) {
        return Infinity; // Undefined when Q=0 but P>0
      }
    }
    return kl;
  },
  
  // Jensen-Shannon Divergence (symmetric, bounded)
  jsDivergence(P, Q) {
    const M = P.map((p, i) => (p + Q[i]) / 2);
    return (this.klDivergence(P, M) + this.klDivergence(Q, M)) / 2;
  },
  
  // Visual fingerprint entropy
  visualEntropy(grid) {
    if (!grid) return { luminance: 0, color: 0, spatial: 0, total: 0 };
    
    // Luminance distribution (256 bins)
    const lumHist = new Array(256).fill(0);
    // Color hue distribution (36 bins for 360Â°)
    const hueHist = new Array(36).fill(0);
    // Spatial gradient distribution
    const gradHist = new Array(32).fill(0);
    
    const flat = grid.flat();
    let prevLum = 0;
    
    flat.forEach((cell, i) => {
      const lum = Math.round((cell.r * 0.299 + cell.g * 0.587 + cell.b * 0.114));
      lumHist[lum]++;
      
      // Hue calculation
      const max = Math.max(cell.r, cell.g, cell.b);
      const min = Math.min(cell.r, cell.g, cell.b);
      if (max !== min) {
        let hue = 0;
        if (max === cell.r) hue = (cell.g - cell.b) / (max - min);
        else if (max === cell.g) hue = 2 + (cell.b - cell.r) / (max - min);
        else hue = 4 + (cell.r - cell.g) / (max - min);
        hue = Math.floor(((hue * 60 + 360) % 360) / 10);
        hueHist[hue]++;
      }
      
      // Spatial gradient
      if (i > 0) {
        const grad = Math.min(31, Math.abs(lum - prevLum));
        gradHist[grad]++;
      }
      prevLum = lum;
    });
    
    return {
      luminance: this.normalizedEntropy(lumHist),
      color: this.normalizedEntropy(hueHist),
      spatial: this.normalizedEntropy(gradHist),
      total: (this.normalizedEntropy(lumHist) + this.normalizedEntropy(hueHist) + this.normalizedEntropy(gradHist)) / 3
    };
  },
  
  // Information gain between frames
  informationGain(prevGrid, currGrid) {
    if (!prevGrid || !currGrid) return 1.0;
    const prevEntropy = this.visualEntropy(prevGrid);
    const currEntropy = this.visualEntropy(currGrid);
    // Approximate mutual information via entropy difference
    return Math.abs(currEntropy.total - prevEntropy.total);
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TOPOLOGY â€” Continuity, Persistence, Structural Features
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const Topology = {
  // Compute connected components (simplified Betti-0)
  connectedComponents(binaryGrid, threshold = 128) {
    if (!binaryGrid) return { count: 0, sizes: [] };
    
    const rows = binaryGrid.length;
    const cols = binaryGrid[0]?.length || 0;
    const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));
    const binary = binaryGrid.map(row => row.map(cell => {
      const lum = (cell.r + cell.g + cell.b) / 3;
      return lum > threshold ? 1 : 0;
    }));
    
    const components = [];
    
    const bfs = (startR, startC) => {
      const queue = [[startR, startC]];
      let size = 0;
      while (queue.length > 0) {
        const [r, c] = queue.shift();
        if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
        if (visited[r][c] || binary[r][c] === 0) continue;
        visited[r][c] = true;
        size++;
        queue.push([r-1, c], [r+1, c], [r, c-1], [r, c+1]);
      }
      return size;
    };
    
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (!visited[r][c] && binary[r][c] === 1) {
          const size = bfs(r, c);
          if (size > 0) components.push(size);
        }
      }
    }
    
    return { count: components.length, sizes: components.sort((a, b) => b - a) };
  },
  
  // Euler characteristic (simplified): Ï‡ = V - E + F
  eulerCharacteristic(grid) {
    if (!grid) return 0;
    const rows = grid.length;
    const cols = grid[0]?.length || 0;
    
    let V = 0, E = 0, F = 0;
    
    // Count vertices (cells), edges (adjacencies), faces (2x2 blocks)
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        V++;
        if (c < cols - 1) E++; // Horizontal edge
        if (r < rows - 1) E++; // Vertical edge
        if (r < rows - 1 && c < cols - 1) F++; // Face
      }
    }
    
    return V - E + F;
  },
  
  // Topological distance between grids (based on component similarity)
  topologicalDistance(grid1, grid2) {
    const comp1 = this.connectedComponents(grid1);
    const comp2 = this.connectedComponents(grid2);
    
    // Compare component counts and size distributions
    const countDiff = Math.abs(comp1.count - comp2.count);
    
    // Compare largest components
    const maxLen = Math.max(comp1.sizes.length, comp2.sizes.length, 1);
    let sizeDiff = 0;
    for (let i = 0; i < maxLen; i++) {
      const s1 = comp1.sizes[i] || 0;
      const s2 = comp2.sizes[i] || 0;
      sizeDiff += Math.abs(s1 - s2);
    }
    
    return countDiff + sizeDiff / (64 * maxLen); // Normalized
  },
  
  // Persistence-like measure: How long features survive across thresholds
  persistenceSignature(grid) {
    if (!grid) return [];
    const signature = [];
    
    for (let threshold = 32; threshold <= 224; threshold += 32) {
      const comp = this.connectedComponents(grid, threshold);
      signature.push({ threshold, components: comp.count, largestSize: comp.sizes[0] || 0 });
    }
    
    return signature;
  },
  
  // Continuity measure between consecutive frames
  continuity(prevGrid, currGrid) {
    if (!prevGrid || !currGrid) return 1.0;
    
    const topDist = this.topologicalDistance(prevGrid, currGrid);
    // Continuity is inverse of distance, capped at 1
    return Math.max(0, 1 - topDist);
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAUSAL STRUCTURE â€” Structural Causal Model (SCM), Interventions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class StructuralCausalModel {
  constructor() {
    // Causal graph: variable -> [parent variables]
    this.graph = new Map();
    // Structural equations: variable -> function(parents) -> value
    this.equations = new Map();
    // Observed values
    this.observations = new Map();
    // Intervention history
    this.interventions = [];
  }
  
  // Add variable to model
  addVariable(name, parents = [], equation = null) {
    this.graph.set(name, parents);
    if (equation) this.equations.set(name, equation);
  }
  
  // Observe a value
  observe(name, value) {
    this.observations.set(name, value);
  }
  
  // Perform intervention: do(X = x)
  intervene(name, value) {
    this.interventions.push({ variable: name, value, timestamp: U.timestamp() });
    // In intervention, we remove parents (break incoming arrows)
    const prevParents = this.graph.get(name) || [];
    this.graph.set(name, []); // Cut incoming edges
    this.observations.set(name, value);
    return { variable: name, value, prevParents };
  }
  
  // Compute probability under intervention: P(Y | do(X=x))
  // Simplified: returns expected effect based on causal structure
  doCalculus(target, intervention) {
    const { variable: X, value: x } = intervention;
    
    // Check if target is descendant of intervention
    const descendants = this.getDescendants(X);
    if (!descendants.has(target)) {
      // No causal effect
      return { effect: 0, confidence: 1.0, path: [] };
    }
    
    // Find causal path
    const path = this.findCausalPath(X, target);
    
    // Estimate effect strength (product of path strengths)
    const effect = path.length > 0 ? Math.pow(0.8, path.length) : 0;
    
    return { effect, confidence: 0.8, path };
  }
  
  // Get all descendants of a variable
  getDescendants(variable) {
    const descendants = new Set();
    const queue = [variable];
    
    while (queue.length > 0) {
      const current = queue.shift();
      this.graph.forEach((parents, child) => {
        if (parents.includes(current) && !descendants.has(child)) {
          descendants.add(child);
          queue.push(child);
        }
      });
    }
    
    return descendants;
  }
  
  // Find causal path between two variables
  findCausalPath(source, target) {
    const visited = new Set();
    const queue = [[source, [source]]];
    
    while (queue.length > 0) {
      const [current, path] = queue.shift();
      if (current === target) return path;
      if (visited.has(current)) continue;
      visited.add(current);
      
      this.graph.forEach((parents, child) => {
        if (parents.includes(current)) {
          queue.push([child, [...path, child]]);
        }
      });
    }
    
    return [];
  }
  
  // Counterfactual: What would Y be if X had been x?
  counterfactual(target, hypothetical) {
    // Store current state
    const backup = new Map(this.observations);
    
    // Apply hypothetical intervention
    this.intervene(hypothetical.variable, hypothetical.value);
    
    // Propagate through equations
    const result = this.propagate(target);
    
    // Restore state
    this.observations = backup;
    
    return { 
      counterfactual: result, 
      actual: backup.get(target),
      difference: result - (backup.get(target) || 0)
    };
  }
  
  // Propagate values through causal graph
  propagate(target) {
    const parents = this.graph.get(target) || [];
    const equation = this.equations.get(target);
    
    if (this.observations.has(target)) {
      return this.observations.get(target);
    }
    
    if (!equation || parents.length === 0) {
      return 0;
    }
    
    const parentValues = parents.map(p => this.propagate(p));
    return equation(parentValues);
  }
  
  // Build SCM from frame sequence
  static fromFrameSequence(frames) {
    const scm = new StructuralCausalModel();
    
    // Define causal structure for video reality
    scm.addVariable('light', [], () => 0.5);
    scm.addVariable('motion', ['light'], ([l]) => l * 0.3);
    scm.addVariable('visual', ['light', 'motion'], ([l, m]) => l * 0.7 + m * 0.3);
    scm.addVariable('scene', ['visual', 'motion'], ([v, m]) => v * 0.8 + m * 0.2);
    scm.addVariable('audio', [], () => 0.5);
    scm.addVariable('context', ['scene', 'audio'], ([s, a]) => s * 0.6 + a * 0.4);
    
    return scm;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GRAPH THEORY â€” Symbol Mesh Analysis, Centrality, Clustering
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GraphTheory = {
  // Build adjacency list from symbols
  buildAdjacencyList(symbols) {
    const adj = new Map();
    
    symbols.forEach(symbol => {
      if (!adj.has(symbol.id)) adj.set(symbol.id, []);
      
      symbol.relations.forEach(rel => {
        adj.get(symbol.id).push({ target: rel.target, weight: rel.strength, type: rel.type });
        
        // For undirected analysis
        if (!adj.has(rel.target)) adj.set(rel.target, []);
        adj.get(rel.target).push({ target: symbol.id, weight: rel.strength, type: rel.type });
      });
    });
    
    return adj;
  },
  
  // Degree centrality
  degreeCentrality(adj) {
    const centrality = new Map();
    const n = adj.size;
    
    adj.forEach((neighbors, node) => {
      centrality.set(node, neighbors.length / (n - 1 || 1));
    });
    
    return centrality;
  },
  
  // PageRank (simplified)
  pageRank(adj, damping = 0.85, iterations = 20) {
    const n = adj.size;
    if (n === 0) return new Map();
    
    const rank = new Map();
    const nodes = Array.from(adj.keys());
    
    // Initialize
    nodes.forEach(node => rank.set(node, 1 / n));
    
    // Iterate
    for (let iter = 0; iter < iterations; iter++) {
      const newRank = new Map();
      
      nodes.forEach(node => {
        let sum = 0;
        adj.forEach((neighbors, other) => {
          const outDegree = neighbors.length || 1;
          if (neighbors.some(n => n.target === node)) {
            sum += rank.get(other) / outDegree;
          }
        });
        newRank.set(node, (1 - damping) / n + damping * sum);
      });
      
      nodes.forEach(node => rank.set(node, newRank.get(node)));
    }
    
    return rank;
  },
  
  // Clustering coefficient
  clusteringCoefficient(adj, node) {
    const neighbors = adj.get(node) || [];
    const k = neighbors.length;
    if (k < 2) return 0;
    
    let triangles = 0;
    for (let i = 0; i < k; i++) {
      for (let j = i + 1; j < k; j++) {
        const ni = neighbors[i].target;
        const nj = neighbors[j].target;
        const niNeighbors = adj.get(ni) || [];
        if (niNeighbors.some(n => n.target === nj)) {
          triangles++;
        }
      }
    }
    
    return (2 * triangles) / (k * (k - 1));
  },
  
  // Average clustering coefficient
  averageClustering(adj) {
    let sum = 0;
    let count = 0;
    
    adj.forEach((_, node) => {
      sum += this.clusteringCoefficient(adj, node);
      count++;
    });
    
    return count > 0 ? sum / count : 0;
  },
  
  // Shortest path length (BFS)
  shortestPath(adj, source, target) {
    if (source === target) return 0;
    
    const visited = new Set([source]);
    const queue = [[source, 0]];
    
    while (queue.length > 0) {
      const [current, dist] = queue.shift();
      const neighbors = adj.get(current) || [];
      
      for (const { target: neighbor } of neighbors) {
        if (neighbor === target) return dist + 1;
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push([neighbor, dist + 1]);
        }
      }
    }
    
    return Infinity;
  },
  
  // Graph diameter (longest shortest path)
  diameter(adj) {
    let maxDist = 0;
    const nodes = Array.from(adj.keys());
    
    for (let i = 0; i < Math.min(nodes.length, 50); i++) { // Sample for performance
      for (let j = i + 1; j < Math.min(nodes.length, 50); j++) {
        const dist = this.shortestPath(adj, nodes[i], nodes[j]);
        if (dist !== Infinity && dist > maxDist) maxDist = dist;
      }
    }
    
    return maxDist;
  },
  
  // Graph summary statistics
  summarize(symbols) {
    const adj = this.buildAdjacencyList(symbols);
    const centrality = this.degreeCentrality(adj);
    const pageRanks = this.pageRank(adj);
    
    // Find most central nodes
    const topByDegree = Array.from(centrality.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    const topByRank = Array.from(pageRanks.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    return {
      nodes: adj.size,
      edges: Array.from(adj.values()).reduce((sum, n) => sum + n.length, 0) / 2,
      avgClustering: this.averageClustering(adj),
      diameter: this.diameter(adj),
      topByDegree,
      topByRank
    };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DYNAMICAL SYSTEMS â€” State Space, Attractors, Stability
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DynamicalSystems = {
  // State history for trajectory analysis
  stateHistory: [],
  maxHistory: 100,
  
  // Record state point
  recordState(state) {
    this.stateHistory.push({ ...state, t: U.timestamp() });
    if (this.stateHistory.length > this.maxHistory) {
      this.stateHistory.shift();
    }
  },
  
  // Extract state vector from frame
  stateFromFrame(frame) {
    if (!frame) return null;
    
    const visual = frame.getLayer('visual') || {};
    const audio = frame.getLayer('audio')?.data || {};
    const motion = frame.getLayer('motion')?.data || {};
    
    return {
      luminance: visual.stats?.luminance || 0,
      contrast: visual.stats?.contrast || 0,
      motion: visual.motionDelta || 0,
      audioLevel: audio.volume || 0,
      orientation: motion.orientation?.beta || 0
    };
  },
  
  // Compute velocity (rate of change)
  velocity(state1, state2, dt = 1) {
    if (!state1 || !state2) return null;
    
    return {
      dLuminance: (state2.luminance - state1.luminance) / dt,
      dContrast: (state2.contrast - state1.contrast) / dt,
      dMotion: (state2.motion - state1.motion) / dt,
      dAudio: (state2.audioLevel - state1.audioLevel) / dt
    };
  },
  
  // Lyapunov exponent approximation (measures chaos)
  lyapunovExponent() {
    if (this.stateHistory.length < 10) return 0;
    
    let sumLogRatio = 0;
    let count = 0;
    
    for (let i = 1; i < this.stateHistory.length - 1; i++) {
      const d0 = this.stateDistance(this.stateHistory[i-1], this.stateHistory[i]);
      const d1 = this.stateDistance(this.stateHistory[i], this.stateHistory[i+1]);
      
      if (d0 > 0.001 && d1 > 0.001) {
        sumLogRatio += Math.log(d1 / d0);
        count++;
      }
    }
    
    return count > 0 ? sumLogRatio / count : 0;
  },
  
  // State space distance
  stateDistance(s1, s2) {
    if (!s1 || !s2) return Infinity;
    
    return Math.sqrt(
      Math.pow(s1.luminance - s2.luminance, 2) +
      Math.pow(s1.contrast - s2.contrast, 2) +
      Math.pow(s1.motion - s2.motion, 2) +
      Math.pow(s1.audioLevel - s2.audioLevel, 2)
    );
  },
  
  // Detect attractor basins (stable regions)
  detectAttractors() {
    if (this.stateHistory.length < 20) return [];
    
    // Simple clustering to find attractor regions
    const clusters = [];
    const visited = new Set();
    
    for (let i = 0; i < this.stateHistory.length; i++) {
      if (visited.has(i)) continue;
      
      const cluster = { center: this.stateHistory[i], points: [i], stability: 0 };
      
      for (let j = i + 1; j < this.stateHistory.length; j++) {
        if (this.stateDistance(this.stateHistory[i], this.stateHistory[j]) < 0.1) {
          cluster.points.push(j);
          visited.add(j);
        }
      }
      
      if (cluster.points.length >= 3) {
        cluster.stability = cluster.points.length / this.stateHistory.length;
        clusters.push(cluster);
      }
    }
    
    return clusters.sort((a, b) => b.stability - a.stability).slice(0, 5);
  },
  
  // Predict next state (simple linear extrapolation)
  predictNext(steps = 1) {
    if (this.stateHistory.length < 2) return null;
    
    const last = this.stateHistory[this.stateHistory.length - 1];
    const prev = this.stateHistory[this.stateHistory.length - 2];
    const vel = this.velocity(prev, last);
    
    if (!vel) return last;
    
    return {
      luminance: last.luminance + vel.dLuminance * steps,
      contrast: last.contrast + vel.dContrast * steps,
      motion: last.motion + vel.dMotion * steps,
      audioLevel: last.audioLevel + vel.dAudio * steps
    };
  },
  
  // System stability score (0 = chaotic, 1 = stable)
  stabilityScore() {
    const lyap = this.lyapunovExponent();
    const attractors = this.detectAttractors();
    
    // Negative Lyapunov = stable, positive = chaotic
    const lyapScore = Math.max(0, 1 - Math.abs(lyap));
    const attractorScore = attractors.length > 0 ? attractors[0].stability : 0;
    
    return (lyapScore + attractorScore) / 2;
  },
  
  // Clear history
  clear() {
    this.stateHistory = [];
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MEASURE THEORY â€” Uncertainty Propagation, Bayesian Fusion
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MeasureTheory = {
  // Gaussian PDF
  gaussian(x, mean, std) {
    if (std === 0) return x === mean ? Infinity : 0;
    const exp = -Math.pow(x - mean, 2) / (2 * std * std);
    return Math.exp(exp) / (std * Math.sqrt(2 * Math.PI));
  },
  
  // Bayesian update: P(H|E) âˆ P(E|H) P(H)
  bayesianUpdate(prior, likelihood) {
    const posterior = prior * likelihood;
    return posterior; // Caller normalizes
  },
  
  // Fuse multiple uncertain measurements
  fuseMeasurements(measurements) {
    // Weighted average by inverse variance
    let sumWeightedValue = 0;
    let sumWeights = 0;
    
    measurements.forEach(({ value, uncertainty }) => {
      if (uncertainty > 0) {
        const weight = 1 / (uncertainty * uncertainty);
        sumWeightedValue += value * weight;
        sumWeights += weight;
      }
    });
    
    if (sumWeights === 0) {
      // Equal weights if no uncertainty info
      const avg = measurements.reduce((s, m) => s + m.value, 0) / measurements.length;
      return { value: avg, uncertainty: 0.5 };
    }
    
    return {
      value: sumWeightedValue / sumWeights,
      uncertainty: Math.sqrt(1 / sumWeights)
    };
  },
  
  // Propagate uncertainty through function: Ïƒ_f = |df/dx| Ïƒ_x
  propagateUncertainty(value, uncertainty, func, delta = 0.001) {
    const f1 = func(value + delta);
    const f2 = func(value - delta);
    const derivative = (f1 - f2) / (2 * delta);
    
    return {
      value: func(value),
      uncertainty: Math.abs(derivative) * uncertainty
    };
  },
  
  // Dempster-Shafer belief combination
  dempsterShafer(beliefs) {
    if (beliefs.length === 0) return { belief: 0, plausibility: 1, uncertainty: 1 };
    if (beliefs.length === 1) return beliefs[0];
    
    // Combine pairwise
    let combined = beliefs[0];
    for (let i = 1; i < beliefs.length; i++) {
      const b1 = combined;
      const b2 = beliefs[i];
      
      // Combine beliefs
      const k = b1.belief * (1 - b2.plausibility) + b2.belief * (1 - b1.plausibility);
      if (k >= 1) {
        combined = { belief: 0, plausibility: 1, uncertainty: 1 }; // Conflict
      } else {
        combined = {
          belief: (b1.belief * b2.belief) / (1 - k),
          plausibility: 1 - ((1 - b1.plausibility) * (1 - b2.plausibility)) / (1 - k),
          uncertainty: 0
        };
        combined.uncertainty = combined.plausibility - combined.belief;
      }
    }
    
    return combined;
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GROUP THEORY â€” Symmetries, Invariants, Transformations
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GroupTheory = {
  // Rotation invariant features (circular symmetry)
  rotationInvariant(grid) {
    if (!grid || grid.length === 0) return { radialProfile: [], centerMass: { x: 0, y: 0 } };
    
    const size = grid.length;
    const center = { x: size / 2, y: size / 2 };
    const maxRadius = Math.sqrt(2) * size / 2;
    const numBins = 8;
    const radialProfile = new Array(numBins).fill(0);
    const radialCounts = new Array(numBins).fill(0);
    
    let massX = 0, massY = 0, totalMass = 0;
    
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const lum = grid[y][x].lum;
        const dx = x - center.x;
        const dy = y - center.y;
        const r = Math.sqrt(dx * dx + dy * dy);
        const bin = Math.min(numBins - 1, Math.floor((r / maxRadius) * numBins));
        
        radialProfile[bin] += lum;
        radialCounts[bin]++;
        
        massX += x * lum;
        massY += y * lum;
        totalMass += lum;
      }
    }
    
    // Normalize radial profile
    for (let i = 0; i < numBins; i++) {
      if (radialCounts[i] > 0) radialProfile[i] /= radialCounts[i];
    }
    
    return {
      radialProfile,
      centerMass: totalMass > 0 ? { x: massX / totalMass, y: massY / totalMass } : center,
      radialSymmetry: this._computeRadialSymmetry(radialProfile)
    };
  },
  
  _computeRadialSymmetry(profile) {
    // Measure how uniform the radial profile is (high = symmetric)
    if (profile.length === 0) return 0;
    const mean = profile.reduce((a, b) => a + b, 0) / profile.length;
    const variance = profile.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / profile.length;
    return Math.max(0, 1 - Math.sqrt(variance) * 2);
  },
  
  // Scale invariant features (using ratios)
  scaleInvariant(grid) {
    if (!grid || grid.length === 0) return { aspectRatio: 1, relativeContrast: 0 };
    
    const flat = grid.flat();
    const lums = flat.map(c => c.lum);
    const maxLum = Math.max(...lums);
    const minLum = Math.min(...lums);
    const meanLum = lums.reduce((a, b) => a + b, 0) / lums.length;
    
    return {
      relativeContrast: meanLum > 0 ? (maxLum - minLum) / meanLum : 0,
      normalizedRange: maxLum > 0 ? minLum / maxLum : 1,
      luminanceRatio: maxLum > 0 ? meanLum / maxLum : 0
    };
  },
  
  // Reflection symmetry (horizontal, vertical, diagonal)
  reflectionSymmetry(grid) {
    if (!grid || grid.length === 0) return { horizontal: 0, vertical: 0, diagonal: 0 };
    
    const size = grid.length;
    let hDiff = 0, vDiff = 0, dDiff = 0;
    let count = 0;
    
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const lum = grid[y][x].lum;
        
        // Horizontal reflection
        const hx = size - 1 - x;
        hDiff += Math.abs(lum - grid[y][hx].lum);
        
        // Vertical reflection
        const vy = size - 1 - y;
        vDiff += Math.abs(lum - grid[vy][x].lum);
        
        // Diagonal reflection (transpose)
        if (x < size && y < size) {
          dDiff += Math.abs(lum - grid[x][y].lum);
        }
        
        count++;
      }
    }
    
    return {
      horizontal: 1 - hDiff / count,
      vertical: 1 - vDiff / count,
      diagonal: 1 - dDiff / count
    };
  },
  
  // Compute all invariants
  computeInvariants(grid) {
    return {
      rotation: this.rotationInvariant(grid),
      scale: this.scaleInvariant(grid),
      reflection: this.reflectionSymmetry(grid)
    };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DIFFERENTIAL GEOMETRY â€” Manifold Structure, Curvature, Geodesics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DifferentialGeometry = {
  // Compute local curvature of luminance surface
  surfaceCurvature(grid) {
    if (!grid || grid.length < 3) return { mean: 0, gaussian: 0, principal: [0, 0] };
    
    const size = grid.length;
    let totalMean = 0, totalGaussian = 0;
    let count = 0;
    
    for (let y = 1; y < size - 1; y++) {
      for (let x = 1; x < size - 1; x++) {
        // Second derivatives (Hessian approximation)
        const fxx = grid[y][x+1].lum - 2*grid[y][x].lum + grid[y][x-1].lum;
        const fyy = grid[y+1][x].lum - 2*grid[y][x].lum + grid[y-1][x].lum;
        const fxy = (grid[y+1][x+1].lum - grid[y+1][x-1].lum - grid[y-1][x+1].lum + grid[y-1][x-1].lum) / 4;
        
        // Mean curvature: H = (fxx + fyy) / 2
        const H = (fxx + fyy) / 2;
        
        // Gaussian curvature: K = fxx*fyy - fxy^2
        const K = fxx * fyy - fxy * fxy;
        
        totalMean += Math.abs(H);
        totalGaussian += K;
        count++;
      }
    }
    
    return {
      meanCurvature: count > 0 ? totalMean / count : 0,
      gaussianCurvature: count > 0 ? totalGaussian / count : 0,
      curvatureType: totalGaussian > 0.01 ? 'elliptic' : totalGaussian < -0.01 ? 'hyperbolic' : 'parabolic'
    };
  },
  
  // Gradient field analysis
  gradientField(grid) {
    if (!grid || grid.length < 2) return { magnitude: 0, coherence: 0, dominantDirection: 0 };
    
    const size = grid.length;
    let totalMag = 0;
    let sumCos = 0, sumSin = 0;
    let count = 0;
    
    for (let y = 0; y < size - 1; y++) {
      for (let x = 0; x < size - 1; x++) {
        const dx = grid[y][x+1].lum - grid[y][x].lum;
        const dy = grid[y+1][x].lum - grid[y][x].lum;
        const mag = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);
        
        totalMag += mag;
        sumCos += Math.cos(angle) * mag;
        sumSin += Math.sin(angle) * mag;
        count++;
      }
    }
    
    const avgMag = count > 0 ? totalMag / count : 0;
    const coherence = count > 0 && totalMag > 0 ? 
      Math.sqrt(sumCos*sumCos + sumSin*sumSin) / totalMag : 0;
    const dominantDirection = Math.atan2(sumSin, sumCos) * 180 / Math.PI;
    
    return { magnitude: avgMag, coherence, dominantDirection };
  },
  
  // Geodesic distance approximation (shortest path on luminance surface)
  geodesicDistance(grid, p1, p2) {
    if (!grid) return Infinity;
    
    const size = grid.length;
    const start = { x: Math.floor(p1.x * size), y: Math.floor(p1.y * size) };
    const end = { x: Math.floor(p2.x * size), y: Math.floor(p2.y * size) };
    
    // Simple A* with luminance-weighted edges
    const dist = Array(size).fill(null).map(() => Array(size).fill(Infinity));
    const visited = Array(size).fill(null).map(() => Array(size).fill(false));
    const pq = [{ x: start.x, y: start.y, d: 0 }];
    dist[start.y][start.x] = 0;
    
    const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
    
    while (pq.length > 0) {
      pq.sort((a, b) => a.d - b.d);
      const { x, y, d } = pq.shift();
      
      if (visited[y][x]) continue;
      visited[y][x] = true;
      
      if (x === end.x && y === end.y) return d;
      
      for (const [dx, dy] of neighbors) {
        const nx = x + dx, ny = y + dy;
        if (nx < 0 || nx >= size || ny < 0 || ny >= size) continue;
        if (visited[ny][nx]) continue;
        
        // Weight by luminance difference (steeper = longer)
        const lumDiff = Math.abs(grid[y][x].lum - grid[ny][nx].lum);
        const edgeWeight = 1 + lumDiff * 5;
        const newDist = d + edgeWeight;
        
        if (newDist < dist[ny][nx]) {
          dist[ny][nx] = newDist;
          pq.push({ x: nx, y: ny, d: newDist });
        }
      }
    }
    
    return dist[end.y][end.x];
  },
  
  // Compute geometric summary
  computeGeometry(grid) {
    return {
      curvature: this.surfaceCurvature(grid),
      gradient: this.gradientField(grid)
    };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SPECTRAL ANALYSIS â€” Frequency Domain, Power Spectrum, Harmonics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SpectralAnalysis = {
  // 1D Discrete Fourier Transform (simplified)
  dft1D(signal) {
    const N = signal.length;
    const real = new Array(N).fill(0);
    const imag = new Array(N).fill(0);
    
    for (let k = 0; k < N; k++) {
      for (let n = 0; n < N; n++) {
        const angle = (2 * Math.PI * k * n) / N;
        real[k] += signal[n] * Math.cos(angle);
        imag[k] -= signal[n] * Math.sin(angle);
      }
    }
    
    return { real, imag };
  },
  
  // Power spectrum from DFT
  powerSpectrum(signal) {
    const { real, imag } = this.dft1D(signal);
    const N = signal.length;
    const power = new Array(Math.floor(N / 2)).fill(0);
    
    for (let k = 0; k < power.length; k++) {
      power[k] = (real[k] * real[k] + imag[k] * imag[k]) / (N * N);
    }
    
    return power;
  },
  
  // Spectral centroid (center of mass of spectrum)
  spectralCentroid(power) {
    let sumWeighted = 0;
    let sumPower = 0;
    
    for (let i = 0; i < power.length; i++) {
      sumWeighted += i * power[i];
      sumPower += power[i];
    }
    
    return sumPower > 0 ? sumWeighted / sumPower : 0;
  },
  
  // Spectral flatness (tonality measure)
  spectralFlatness(power) {
    const n = power.length;
    if (n === 0) return 0;
    
    let sumLog = 0;
    let sumLinear = 0;
    let validCount = 0;
    
    for (let i = 0; i < n; i++) {
      if (power[i] > 0) {
        sumLog += Math.log(power[i]);
        validCount++;
      }
      sumLinear += power[i];
    }
    
    if (validCount === 0 || sumLinear === 0) return 0;
    
    const geometricMean = Math.exp(sumLog / validCount);
    const arithmeticMean = sumLinear / n;
    
    return arithmeticMean > 0 ? geometricMean / arithmeticMean : 0;
  },
  
  // Analyze grid row-wise and column-wise
  analyzeGrid(grid) {
    if (!grid || grid.length === 0) return { horizontal: {}, vertical: {}, dominant: 0 };
    
    // Extract row luminances
    const rowSignals = grid.map(row => row.map(c => c.lum));
    const colSignals = [];
    for (let x = 0; x < grid[0].length; x++) {
      colSignals.push(grid.map(row => row[x].lum));
    }
    
    // Average power spectrum
    const avgRowPower = this._averagePower(rowSignals);
    const avgColPower = this._averagePower(colSignals);
    
    const hCentroid = this.spectralCentroid(avgRowPower);
    const vCentroid = this.spectralCentroid(avgColPower);
    const hFlatness = this.spectralFlatness(avgRowPower);
    const vFlatness = this.spectralFlatness(avgColPower);
    
    // Dominant frequency
    const hDominant = avgRowPower.indexOf(Math.max(...avgRowPower));
    const vDominant = avgColPower.indexOf(Math.max(...avgColPower));
    
    return {
      horizontal: { centroid: hCentroid, flatness: hFlatness, dominant: hDominant },
      vertical: { centroid: vCentroid, flatness: vFlatness, dominant: vDominant },
      overall: {
        centroid: (hCentroid + vCentroid) / 2,
        flatness: (hFlatness + vFlatness) / 2,
        anisotropy: Math.abs(hCentroid - vCentroid)
      }
    };
  },
  
  _averagePower(signals) {
    if (signals.length === 0) return [];
    const powers = signals.map(s => this.powerSpectrum(s));
    const avgLen = Math.min(...powers.map(p => p.length));
    const avg = new Array(avgLen).fill(0);
    
    for (let i = 0; i < avgLen; i++) {
      for (const p of powers) {
        avg[i] += p[i] || 0;
      }
      avg[i] /= powers.length;
    }
    
    return avg;
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATISTICAL MECHANICS â€” Thermodynamic Entropy, Energy, Temperature
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const StatisticalMechanics = {
  // Boltzmann entropy: S = k_B ln(W) â€” approximated via microstate counting
  boltzmannEntropy(grid) {
    if (!grid || grid.length === 0) return 0;
    
    // Count distinct microstates (binned luminance levels)
    const bins = 16;
    const histogram = new Array(bins).fill(0);
    
    for (const row of grid) {
      for (const cell of row) {
        const bin = Math.min(bins - 1, Math.floor(cell.lum * bins));
        histogram[bin]++;
      }
    }
    
    // W = number of microstates
    const nonEmpty = histogram.filter(h => h > 0).length;
    return Math.log(nonEmpty + 1);
  },
  
  // Internal energy (total "kinetic energy" of pixel intensity)
  internalEnergy(grid) {
    if (!grid || grid.length === 0) return 0;
    
    let energy = 0;
    for (const row of grid) {
      for (const cell of row) {
        // E = 0.5 * m * v^2, treat luminance as velocity
        energy += 0.5 * cell.lum * cell.lum;
      }
    }
    
    return energy / (grid.length * grid[0].length);
  },
  
  // Temperature (from equipartition: E = (f/2) k_B T)
  temperature(grid) {
    const E = this.internalEnergy(grid);
    // Degrees of freedom: 3 (R, G, B)
    const f = 3;
    return (2 * E) / f;
  },
  
  // Free energy: F = E - T*S
  freeEnergy(grid) {
    const E = this.internalEnergy(grid);
    const T = this.temperature(grid);
    const S = this.boltzmannEntropy(grid);
    return E - T * S;
  },
  
  // Partition function approximation
  partitionFunction(grid, beta = 1.0) {
    if (!grid || grid.length === 0) return 1;
    
    let Z = 0;
    for (const row of grid) {
      for (const cell of row) {
        Z += Math.exp(-beta * cell.lum);
      }
    }
    
    return Z;
  },
  
  // Order parameter (magnetization analog)
  orderParameter(grid) {
    if (!grid || grid.length === 0) return 0;
    
    let sum = 0;
    let count = 0;
    
    for (const row of grid) {
      for (const cell of row) {
        // Map luminance to spin: bright = +1, dark = -1
        sum += (cell.lum - 0.5) * 2;
        count++;
      }
    }
    
    return count > 0 ? Math.abs(sum / count) : 0;
  },
  
  // Phase detection (ordered vs disordered)
  detectPhase(grid) {
    const order = this.orderParameter(grid);
    const entropy = this.boltzmannEntropy(grid);
    const temp = this.temperature(grid);
    
    // Critical temperature approximation
    const Tc = 0.25;
    
    if (temp < Tc && order > 0.5) return 'ordered';
    if (temp > Tc && order < 0.3) return 'disordered';
    return 'critical';
  },
  
  // Complete thermodynamic analysis
  analyze(grid) {
    return {
      entropy: this.boltzmannEntropy(grid),
      energy: this.internalEnergy(grid),
      temperature: this.temperature(grid),
      freeEnergy: this.freeEnergy(grid),
      orderParameter: this.orderParameter(grid),
      phase: this.detectPhase(grid)
    };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CATEGORY THEORY â€” Functors, Natural Transformations, Composition
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CategoryTheory = {
  // Objects are symbols, morphisms are relations
  // Composition: f âˆ˜ g (apply g then f)
  compose(morphisms) {
    if (morphisms.length === 0) return null;
    if (morphisms.length === 1) return morphisms[0];
    
    // Compose pairwise
    let composed = {
      source: morphisms[0].source,
      target: morphisms[morphisms.length - 1].target,
      strength: 1.0,
      path: []
    };
    
    for (const m of morphisms) {
      composed.strength *= m.strength;
      composed.path.push(m);
    }
    
    return composed;
  },
  
  // Functor: Map from one category to another
  // F: Symbols â†’ Properties
  functorToProperty(symbol, propertyExtractor) {
    return {
      object: symbol.id,
      morphisms: symbol.relations.map(r => ({
        source: r.source,
        target: r.target,
        mapped: propertyExtractor(r)
      }))
    };
  },
  
  // Natural transformation: Convert between functors
  naturalTransformation(source, target, transform) {
    return {
      component: source.object,
      arrow: transform(source, target)
    };
  },
  
  // Limit: Universal construction (product of objects)
  product(symbols) {
    if (symbols.length === 0) return null;
    
    return {
      type: 'product',
      factors: symbols.map(s => s.id),
      projections: symbols.map((s, i) => ({
        index: i,
        target: s.id
      }))
    };
  },
  
  // Colimit: Coproduct (sum/union of objects)
  coproduct(symbols) {
    if (symbols.length === 0) return null;
    
    return {
      type: 'coproduct',
      summands: symbols.map(s => s.id),
      injections: symbols.map((s, i) => ({
        index: i,
        source: s.id
      }))
    };
  },
  
  // Check if diagram commutes (path independence)
  commutes(path1, path2) {
    const c1 = this.compose(path1);
    const c2 = this.compose(path2);
    
    if (!c1 || !c2) return false;
    
    return c1.source === c2.source && 
           c1.target === c2.target &&
           Math.abs(c1.strength - c2.strength) < 0.01;
  },
  
  // Analyze categorical structure of symbol graph
  analyzeStructure(symbols) {
    if (!symbols || symbols.length === 0) return { objects: 0, morphisms: 0 };
    
    let morphismCount = 0;
    const endomorphisms = [];
    const isomorphisms = [];
    
    for (const s of symbols) {
      morphismCount += s.relations.length;
      
      // Check for endomorphisms (self-loops)
      for (const r of s.relations) {
        if (r.target === s.id) {
          endomorphisms.push({ object: s.id, relation: r });
        }
        
        // Check for potential isomorphisms (bidirectional strong relations)
        if (r.strength > 0.9) {
          const target = symbols.find(t => t.id === r.target);
          if (target) {
            const inverse = target.relations.find(inv => 
              inv.target === s.id && inv.strength > 0.9);
            if (inverse) {
              isomorphisms.push({ a: s.id, b: target.id });
            }
          }
        }
      }
    }
    
    return {
      objects: symbols.length,
      morphisms: morphismCount,
      endomorphisms: endomorphisms.length,
      isomorphisms: isomorphisms.length / 2, // Each counted twice
      connectivity: symbols.length > 1 ? morphismCount / (symbols.length * (symbols.length - 1)) : 0
    };
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// THEORETICAL ANALYSIS ENGINE â€” Unified Interface
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class TheoreticalAnalyzer {
  constructor() {
    this.scm = new StructuralCausalModel();
    this.analysisHistory = [];
  }
  
  // Full frame analysis using all theories
  analyzeFrame(frame, prevFrame, container) {
    try {
      const analysis = {
        timestamp: U.timestamp(),
        frameIndex: frame?.index || 0,
        
        // Information Theory
        information: this.analyzeInformation(frame, prevFrame),
        
        // Topology
        topology: this.analyzeTopology(frame, prevFrame),
        
        // Causal Structure
        causal: this.analyzeCausal(frame, prevFrame),
        
        // Graph Theory (on symbols)
        graph: container ? this.analyzeGraph(container) : null,
        
        // Dynamical Systems
        dynamics: this.analyzeDynamics(frame),
        
        // Measure Theory
        uncertainty: this.analyzeUncertainty(frame),
        
        // Group Theory (symmetries & invariants)
        symmetry: this.analyzeSymmetry(frame),
        
        // Differential Geometry (curvature & gradients)
        geometry: this.analyzeGeometry(frame),
        
        // Spectral Analysis (frequency domain)
        spectral: this.analyzeSpectral(frame),
        
        // Statistical Mechanics (thermodynamics)
        thermodynamics: this.analyzeThermodynamics(frame),
        
        // Category Theory (structure)
        category: container ? this.analyzeCategory(container) : null
      };
      
      // Compute composite theoretical score
      analysis.theoreticalScore = this.computeTheoreticalScore(analysis);
      
      this.analysisHistory.push(analysis);
      if (this.analysisHistory.length > 100) this.analysisHistory.shift();
      
      return analysis;
    } catch (e) {
      console.error('TheoreticalAnalyzer.analyzeFrame error:', e);
      return {
        timestamp: U.timestamp(),
        frameIndex: frame?.index || 0,
        error: e.message,
        theoreticalScore: 0
      };
    }
  }
  
  analyzeSpectral(frame) {
    const visual = frame?.getLayer('visual');
    if (!visual?.grid) return { centroid: 0, flatness: 0, anisotropy: 0 };
    
    const spectral = SpectralAnalysis.analyzeGrid(visual.grid);
    return {
      centroid: spectral.overall.centroid,
      flatness: spectral.overall.flatness,
      anisotropy: spectral.overall.anisotropy,
      hDominant: spectral.horizontal.dominant,
      vDominant: spectral.vertical.dominant
    };
  }
  
  analyzeThermodynamics(frame) {
    const visual = frame?.getLayer('visual');
    if (!visual?.grid) return { entropy: 0, temperature: 0, phase: 'unknown' };
    
    const thermo = StatisticalMechanics.analyze(visual.grid);
    return {
      entropy: thermo.entropy,
      energy: thermo.energy,
      temperature: thermo.temperature,
      freeEnergy: thermo.freeEnergy,
      orderParameter: thermo.orderParameter,
      phase: thermo.phase
    };
  }
  
  analyzeCategory(container) {
    if (!container || container.symbols.size < 2) return { objects: 0, connectivity: 0 };
    
    const symbols = Array.from(container.symbols.values());
    return CategoryTheory.analyzeStructure(symbols);
  }
  
  analyzeSymmetry(frame) {
    const visual = frame?.getLayer('visual');
    if (!visual?.grid) return { rotation: 0, reflection: { horizontal: 0, vertical: 0 } };
    
    const invariants = GroupTheory.computeInvariants(visual.grid);
    return {
      radialSymmetry: invariants.rotation.radialSymmetry,
      reflectionH: invariants.reflection.horizontal,
      reflectionV: invariants.reflection.vertical,
      scaleInvariant: invariants.scale.relativeContrast,
      centerMass: invariants.rotation.centerMass
    };
  }
  
  analyzeGeometry(frame) {
    const visual = frame?.getLayer('visual');
    if (!visual?.grid) return { curvature: 0, gradient: 0, coherence: 0 };
    
    const geometry = DifferentialGeometry.computeGeometry(visual.grid);
    return {
      meanCurvature: geometry.curvature.meanCurvature,
      gaussianCurvature: geometry.curvature.gaussianCurvature,
      curvatureType: geometry.curvature.curvatureType,
      gradientMagnitude: geometry.gradient.magnitude,
      gradientCoherence: geometry.gradient.coherence,
      dominantDirection: geometry.gradient.dominantDirection
    };
  }
  
  analyzeInformation(frame, prevFrame) {
    try {
      const visual = frame?.getLayer('visual');
      const prevVisual = prevFrame?.getLayer('visual');
      
      const entropy = InformationTheory.visualEntropy(visual?.grid);
      const prevEntropy = prevVisual ? InformationTheory.visualEntropy(prevVisual.grid) : null;
      
      let informationGain = 0;
      let divergence = 0;
      
      if (prevVisual && visual) {
        informationGain = InformationTheory.informationGain(prevVisual.grid, visual.grid);
        divergence = Math.abs(entropy.total - (prevEntropy?.total || 0));
      }
      
      return { entropy, informationGain, divergence, novelty: entropy.total * (1 + informationGain) };
    } catch (e) {
      console.error('analyzeInformation error:', e);
      return { entropy: { total: 0 }, informationGain: 0, divergence: 0, novelty: 0 };
    }
  }
  
  analyzeTopology(frame, prevFrame) {
    const visual = frame?.getLayer('visual');
    const prevVisual = prevFrame?.getLayer('visual');
    
    if (!visual?.grid) return { components: 0, continuity: 1, persistence: [] };
    
    const components = Topology.connectedComponents(visual.grid);
    const euler = Topology.eulerCharacteristic(visual.grid);
    const continuity = prevVisual ? Topology.continuity(prevVisual.grid, visual.grid) : 1;
    const persistence = Topology.persistenceSignature(visual.grid);
    
    return { 
      components: components.count, 
      largestComponent: components.sizes[0] || 0,
      euler, 
      continuity, 
      persistence,
      stability: continuity > 0.8 ? 'stable' : continuity > 0.5 ? 'transitioning' : 'discontinuous'
    };
  }
  
  analyzeCausal(frame, prevFrame) {
    // Update SCM with current observations
    const visual = frame?.getLayer('visual');
    const audio = frame?.getLayer('audio');
    
    if (visual) {
      this.scm.observe('light', visual.stats?.luminance || 0);
      this.scm.observe('motion', visual.motionDelta || 0);
      this.scm.observe('visual', visual.confidence || 0);
    }
    
    if (audio) {
      this.scm.observe('audio', audio.data?.volume || 0);
    }
    
    // Detect potential interventions (sudden changes)
    const interventions = [];
    if (prevFrame) {
      const prevVisual = prevFrame.getLayer('visual');
      if (prevVisual && visual) {
        const lumChange = Math.abs((visual.stats?.luminance || 0) - (prevVisual.stats?.luminance || 0));
        if (lumChange > 0.3) {
          interventions.push({ variable: 'light', change: lumChange, type: 'sudden_change' });
        }
      }
    }
    
    return {
      observations: Object.fromEntries(this.scm.observations),
      interventions,
      causalStrength: this.scm.doCalculus('context', { variable: 'light', value: 0.5 }).effect
    };
  }
  
  analyzeGraph(container) {
    if (!container || container.symbols.size < 2) {
      return { nodes: 0, edges: 0, avgClustering: 0, diameter: 0 };
    }
    
    const symbols = Array.from(container.symbols.values());
    return GraphTheory.summarize(symbols);
  }
  
  analyzeDynamics(frame) {
    const state = DynamicalSystems.stateFromFrame(frame);
    if (state) {
      DynamicalSystems.recordState(state);
    }
    
    return {
      currentState: state,
      lyapunov: DynamicalSystems.lyapunovExponent(),
      stability: DynamicalSystems.stabilityScore(),
      attractors: DynamicalSystems.detectAttractors().length,
      prediction: DynamicalSystems.predictNext()
    };
  }
  
  analyzeUncertainty(frame) {
    if (!frame) return { fused: 0.5, confidence: 0 };
    
    const measurements = [];
    
    // Collect all layer uncertainties
    frame.layers.forEach(layer => {
      if (layer.uncertainty !== undefined) {
        measurements.push({ value: layer.confidence || 0.5, uncertainty: layer.uncertainty });
      }
    });
    
    if (measurements.length === 0) {
      return { fused: frame.confidence || 0.5, confidence: frame.confidence || 0 };
    }
    
    const fused = MeasureTheory.fuseMeasurements(measurements);
    
    return {
      fused: fused.value,
      fusedUncertainty: fused.uncertainty,
      confidence: 1 - fused.uncertainty,
      layerCount: measurements.length
    };
  }
  
  computeTheoreticalScore(analysis) {
    // Weighted combination of theoretical measures (11 theories)
    const weights = {
      novelty: 0.10,          // Information theory
      continuity: 0.12,       // Topology
      causalStrength: 0.10,   // Causal structure
      clustering: 0.06,       // Graph theory
      stability: 0.12,        // Dynamical systems
      confidence: 0.10,       // Measure theory
      symmetry: 0.08,         // Group theory
      coherence: 0.08,        // Differential geometry
      flatness: 0.08,         // Spectral analysis
      order: 0.08,            // Statistical mechanics
      connectivity: 0.08      // Category theory
    };
    
    let score = 0;
    
    if (analysis.information?.novelty !== undefined) {
      score += weights.novelty * U.clamp(analysis.information.novelty, 0, 1);
    }
    if (analysis.topology?.continuity !== undefined) {
      score += weights.continuity * analysis.topology.continuity;
    }
    if (analysis.causal?.causalStrength !== undefined) {
      score += weights.causalStrength * analysis.causal.causalStrength;
    }
    if (analysis.graph?.avgClustering !== undefined) {
      score += weights.clustering * analysis.graph.avgClustering;
    }
    if (analysis.dynamics?.stability !== undefined) {
      score += weights.stability * analysis.dynamics.stability;
    }
    if (analysis.uncertainty?.confidence !== undefined) {
      score += weights.confidence * analysis.uncertainty.confidence;
    }
    if (analysis.symmetry?.radialSymmetry !== undefined) {
      score += weights.symmetry * analysis.symmetry.radialSymmetry;
    }
    if (analysis.geometry?.gradientCoherence !== undefined) {
      score += weights.coherence * analysis.geometry.gradientCoherence;
    }
    if (analysis.spectral?.flatness !== undefined) {
      score += weights.flatness * U.clamp(analysis.spectral.flatness, 0, 1);
    }
    if (analysis.thermodynamics?.orderParameter !== undefined) {
      score += weights.order * analysis.thermodynamics.orderParameter;
    }
    if (analysis.category?.connectivity !== undefined) {
      score += weights.connectivity * U.clamp(analysis.category.connectivity, 0, 1);
    }
    
    return Math.round(score * 100);
  }
  
  // Get summary of recent analyses
  getSummary() {
    if (this.analysisHistory.length === 0) return null;
    
    const recent = this.analysisHistory.slice(-10);
    
    return {
      avgScore: U.mean(recent.map(a => a.theoreticalScore)),
      avgNovelty: U.mean(recent.filter(a => a.information).map(a => a.information.novelty || 0)),
      avgContinuity: U.mean(recent.filter(a => a.topology).map(a => a.topology.continuity || 0)),
      avgStability: U.mean(recent.filter(a => a.dynamics).map(a => a.dynamics.stability || 0)),
      avgSymmetry: U.mean(recent.filter(a => a.symmetry).map(a => a.symmetry.radialSymmetry || 0)),
      avgCoherence: U.mean(recent.filter(a => a.geometry).map(a => a.geometry.gradientCoherence || 0)),
      avgFlatness: U.mean(recent.filter(a => a.spectral).map(a => a.spectral.flatness || 0)),
      avgOrder: U.mean(recent.filter(a => a.thermodynamics).map(a => a.thermodynamics.orderParameter || 0)),
      avgPhase: recent.filter(a => a.thermodynamics).map(a => a.thermodynamics.phase).slice(-1)[0] || 'unknown',
      totalAnalyses: this.analysisHistory.length
    };
  }
  
  clear() {
    this.analysisHistory = [];
    DynamicalSystems.clear();
    this.scm = new StructuralCausalModel();
  }
}

// Global theoretical analyzer instance
const theoreticalAnalyzer = new TheoreticalAnalyzer();

// Log
const Log = {
  entries: [],
  _add(level, cat, msg) {
    const entry = { timestamp: U.timestamp(), level, category: cat, message: msg };
    this.entries.push(entry);
    if (this.entries.length > 200) this.entries.shift();
    console.log(`[${level}][${cat}] ${msg}`);
    this._updateUI(entry);
    bus.emit('log', entry);
  },
  info: (cat, msg) => Log._add('info', cat, msg),
  ok: (cat, msg) => Log._add('ok', cat, msg),
  warn: (cat, msg) => Log._add('warn', cat, msg),
  error: (cat, msg) => Log._add('error', cat, msg),
  _updateUI(entry) {
    const el = document.getElementById('start-log');
    if (el) {
      const t = new Date(entry.timestamp);
      el.innerHTML += `<div class="log-line"><span class="log-time">${t.getMinutes()}:${t.getSeconds().toString().padStart(2,'0')}</span><span class="log-${entry.level}">${entry.message}</span></div>`;
      el.scrollTop = el.scrollHeight;
    }
  }
};

// Measurement with Uncertainty
class Measurement {
  constructor(value, unit = null, uncertainty = 0) {
    this.value = value;
    this.unit = unit;
    this.uncertainty = uncertainty;
    this.timestamp = U.timestamp();
  }
  format(p = 2) { return this.uncertainty > 0 ? `${this.value.toFixed(p)} Â± ${this.uncertainty.toFixed(p)}` : this.value.toFixed(p); }
  toJSON() { return { value: this.value, unit: this.unit, uncertainty: this.uncertainty }; }
}

// Symbol
class Symbol {
  constructor(type, subtype = null) {
    this.id = U.uid();
    this.type = type;
    this.subtype = subtype;
    this.created = U.timestamp();
    this.meta = {
      identity: { id: this.id, type, subtype },
      behavior: { mutable: true, observable: true },
      property: {},
      information: {},
      measurement: {},
      boundary: { minConfidence: 0, maxAge: Infinity },
      structure: { depth: 0, parent: null, children: [] },
    };
    this.wh = { what: null, where: null, when: null, who: null, why: null, how: null, which: null, whose: null, because: null, therefore: null };
    this.relations = [];
    this.confidence = 1.0;
    this.uncertainty = 0;
    this.updated = this.created;
  }
  link(target, relType, strength = 1.0, opts = {}) {
    const rel = { id: U.uid(), source: this.id, target: target.id || target, type: relType, strength, causal: opts.causal || false, created: U.timestamp() };
    this.relations.push(rel);
    return rel;
  }
  setMeasurement(key, value, unit = null, unc = 0) {
    this.meta.measurement[key] = new Measurement(value, unit, unc);
    this.updated = U.timestamp();
  }
  getMeasurementValue(key, def = null) { const m = this.meta.measurement[key]; return m ? m.value : def; }
  setProperty(k, v) { this.meta.property[k] = v; }
  setInfo(k, v) { this.meta.information[k] = v; this.updated = U.timestamp(); }
  setParent(p) { this.meta.structure.parent = p.id || p; this.meta.structure.depth = (p.meta?.structure.depth || 0) + 1; }
  addChild(c) { this.meta.structure.children.push(c.id || c); }
  setWH(field, value) { if (field in this.wh) { this.wh[field] = value; this.updated = U.timestamp(); } }
  setConfidence(c) { this.confidence = U.clamp(c, 0, 1); }
  getSize() { return JSON.stringify(this.toJSON()).length; }
  toJSON() {
    return {
      id: this.id, type: this.type, subtype: this.subtype, created: this.created, updated: this.updated,
      meta: { ...this.meta, measurement: Object.fromEntries(Object.entries(this.meta.measurement).map(([k,v]) => [k, v.toJSON ? v.toJSON() : v])) },
      wh: this.wh, relations: this.relations, confidence: this.confidence, uncertainty: this.uncertainty,
    };
  }
}

// SensorSymbol
class SensorSymbol extends Symbol {
  constructor(sensorType, data, captureTime = U.timestamp()) {
    super('sensor', sensorType);
    this.sensorType = sensorType;
    this.data = data;
    this.capturedAt = captureTime;
    this.wh.what = sensorType;
    this.wh.when = captureTime;
    this.wh.how = 'hardware_capture';
    this.meta.behavior.mutable = false;
  }
}

// VideoFrameSymbol
class VideoFrameSymbol extends Symbol {
  constructor(canvas, quality = 0.7) {
    super('sensor', 'video');
    this.sensorType = 'video';
    this.capturedAt = U.timestamp();
    this.data = { width: canvas.width, height: canvas.height, dataUrl: canvas.toDataURL('image/jpeg', quality), quality };
    this.wh.what = 'video_frame';
    this.wh.when = this.capturedAt;
    this.setMeasurement('width', canvas.width, 'px', 0);
    this.setMeasurement('height', canvas.height, 'px', 0);
  }
  getSize() { return this.data.dataUrl.length * 0.75 + 300; }
}

// VisualFingerprintSymbol
class VisualFingerprintSymbol extends Symbol {
  constructor(canvas, prevVF = null) {
    super('sensor', 'visual');
    this.sensorType = 'visual';
    this.capturedAt = U.timestamp();
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    const imageData = ctx.getImageData(0, 0, width, height);
    const pixels = imageData.data;
    
    this.grid = this._computeGrid(pixels, width, height, 8);
    this.stats = this._computeStats(pixels);
    this.dHash = this._computeDHash(this.grid);
    this.motionDelta = prevVF ? this._computeMotion(this.grid, prevVF.grid) : 0;
    this.sceneChange = this.motionDelta > 0.5;
    this.edgeDensity = this._computeEdges(this.grid);
    this.contrast = this._computeContrast(this.grid);
    this.sceneType = this._classifyScene();
    
    // Information-theoretic measures
    this.entropy = InformationTheory.visualEntropy(this.grid);
    this.informationGain = prevVF ? InformationTheory.informationGain(prevVF.grid, this.grid) : 1.0;
    
    // Topological measures
    this.topology = {
      components: Topology.connectedComponents(this.grid, 128),
      continuity: prevVF ? Topology.continuity(prevVF.grid, this.grid) : 1.0
    };
    
    this.data = { 
      grid: this.grid, stats: this.stats, dHash: this.dHash, 
      motionDelta: this.motionDelta, sceneChange: this.sceneChange, 
      edgeDensity: this.edgeDensity, contrast: this.contrast, sceneType: this.sceneType,
      entropy: this.entropy, informationGain: this.informationGain,
      topology: this.topology
    };
    this.wh.what = this.sceneType;
    this.wh.how = this.stats.saturation > 0.4 ? 'colorful' : 'muted';
    this.wh.when = this.capturedAt;
    this.setMeasurement('luminance', this.stats.luminance, null, 0.02);
    this.setMeasurement('motionDelta', this.motionDelta, null, this.motionDelta * 0.1);
    this.setMeasurement('entropy', this.entropy.total, 'bits', 0.05);
    this.setConfidence(this.stats.luminance > 0.02 ? 0.95 : 0.4);
    
    // Adjust confidence based on entropy (low entropy = less informative)
    if (this.entropy.total < 0.3) {
      this.confidence *= 0.8;
      this.wh.why = 'low_information';
    }
  }
  _computeGrid(px, w, h, gs) {
    const cw = Math.floor(w/gs), ch = Math.floor(h/gs), grid = [];
    for (let gy = 0; gy < gs; gy++) {
      const row = [];
      for (let gx = 0; gx < gs; gx++) {
        let r=0, g=0, b=0, cnt=0;
        for (let y=0; y<ch; y++) for (let x=0; x<cw; x++) { const i=((gy*ch+y)*w+(gx*cw+x))*4; r+=px[i]; g+=px[i+1]; b+=px[i+2]; cnt++; }
        row.push({ r: Math.round(r/cnt), g: Math.round(g/cnt), b: Math.round(b/cnt), lum: (0.299*(r/cnt)+0.587*(g/cnt)+0.114*(b/cnt))/255 });
      }
      grid.push(row);
    }
    return grid;
  }
  _computeStats(px) {
    let lumSum=0, satSum=0, n=px.length/4;
    for (let i=0; i<px.length; i+=4) {
      const r=px[i], g=px[i+1], b=px[i+2];
      lumSum += 0.299*r + 0.587*g + 0.114*b;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      satSum += max===0 ? 0 : (max-min)/max;
    }
    return { luminance: lumSum/(n*255), saturation: satSum/n };
  }
  _computeDHash(grid) {
    let bits = '';
    for (let y=0; y<grid.length; y++) for (let x=0; x<grid[0].length-1; x++) bits += grid[y][x].lum > grid[y][x+1].lum ? '1' : '0';
    return parseInt(bits.slice(0,28),2).toString(36) + parseInt(bits.slice(28,56),2).toString(36);
  }
  _computeMotion(a, b) {
    let diff=0, cnt=0;
    for (let y=0; y<a.length; y++) for (let x=0; x<a[0].length; x++) { diff += Math.abs(a[y][x].r-b[y][x].r)+Math.abs(a[y][x].g-b[y][x].g)+Math.abs(a[y][x].b-b[y][x].b); cnt++; }
    return diff/(cnt*255*3);
  }
  _computeEdges(grid) {
    let edges=0, total=0;
    for (let y=1; y<grid.length; y++) for (let x=1; x<grid[0].length; x++) { edges += Math.sqrt(Math.pow(grid[y][x].lum-grid[y][x-1].lum,2)+Math.pow(grid[y][x].lum-grid[y-1][x].lum,2)); total++; }
    return edges/total;
  }
  _computeContrast(grid) { const lums = grid.flat().map(c=>c.lum); return Math.max(...lums) - Math.min(...lums); }
  _classifyScene() {
    const { luminance, saturation } = this.stats;
    if (luminance < 0.15) return 'dark_scene';
    if (luminance > 0.75) return 'bright_scene';
    if (saturation > 0.5) return 'colorful_scene';
    if (this.contrast < 0.2) return 'flat_scene';
    if (this.edgeDensity > 0.15) return 'detailed_scene';
    return 'normal_scene';
  }
  getSize() { return JSON.stringify(this.data).length + 300; }
}

// FrameSymbol
class FrameSymbol extends Symbol {
  constructor(index, timestamp) {
    super('frame', 'capture');
    this.index = index;
    this.timestamp = timestamp;
    this.layers = new Map();
    this.signature = null;
    this.prevHash = null;
    this.merkleRoot = null;
    this.syncQuality = null;
    this.processingTime = 0;
    this.anomalies = [];
    this.crossValidation = {};
    this.causalInferences = [];
    this.patterns = [];
    this.theoretical = null;  // Theoretical analysis data
    this.wh.what = 'frame';
    this.wh.when = timestamp;
    this.wh.which = index;
  }
  addLayer(sensor) { this.layers.set(sensor.sensorType, sensor); this.link(sensor, 'contains', sensor.confidence); this.addChild(sensor); sensor.setParent(this); }
  getLayer(type) { return this.layers.get(type); }
  hasLayer(type) { return this.layers.has(type); }
  setSyncQuality(q) { this.syncQuality = q; }
  setProcessingTime(ms) { this.processingTime = ms; }
  addAnomaly(a) { this.anomalies.push(a); }
  addCausalInference(inf) { this.causalInferences.push(inf); }
  addPattern(p) { this.patterns.push(p); }
  computeMerkleRoot() {
    const hashes = [];
    this.layers.forEach((layer, type) => { hashes.push(U.hash(JSON.stringify({ type, data: layer.data, confidence: layer.confidence }))); });
    if (hashes.length === 0) return '0';
    while (hashes.length > 1) { const newH = []; for (let i=0; i<hashes.length; i+=2) newH.push(i+1<hashes.length ? U.hash(hashes[i]+hashes[i+1]) : hashes[i]); hashes.length = 0; hashes.push(...newH); }
    this.merkleRoot = hashes[0];
    return this.merkleRoot;
  }
  sign(prevHash) {
    this.prevHash = prevHash;
    this.computeMerkleRoot();
    this.signature = U.hash([prevHash || 'genesis', this.timestamp, this.index, this.merkleRoot, this.anomalies.length, this.causalInferences.length].join('|'));
    return this.signature;
  }
  getFrameUncertainty() {
    const uncs = [];
    this.layers.forEach(l => { if (l.uncertainty) uncs.push(l.uncertainty); });
    return uncs.length > 0 ? U.mean(uncs) : 0;
  }
  getSize() {
    let size = 400;
    this.layers.forEach(l => { size += l.getSize ? l.getSize() : JSON.stringify(l.data || {}).length; });
    return size;
  }
  toJSON() {
    const obj = super.toJSON();
    obj.index = this.index;
    obj.timestamp = this.timestamp;
    obj.signature = this.signature;
    obj.prevHash = this.prevHash;
    obj.merkleRoot = this.merkleRoot;
    obj.syncQuality = this.syncQuality;
    obj.processingTime = this.processingTime;
    obj.anomalies = this.anomalies;
    obj.crossValidation = this.crossValidation;
    obj.causalInferences = this.causalInferences;
    obj.patterns = this.patterns;
    obj.theoretical = this.theoretical;
    obj.layers = {};
    this.layers.forEach((v, k) => { obj.layers[k] = v.toJSON ? v.toJSON() : v.data; });
    return obj;
  }
}

// CausalReasoningEngine
class CausalReasoningEngine {
  constructor() {
    this.rules = [
      // Motion-related inferences
      { id: 'motion_blur', condition: (f, p) => { const v=f.getLayer('visual'); const m=f.getLayer('motion'); return v?.motionDelta>0.4 && m?.data?.accel && Math.sqrt(m.data.accel.x**2+m.data.accel.y**2+m.data.accel.z**2)>3; }, inference: { type:'motion_blur', cause:'rapid_movement', effect:'visual_blur', confidence:0.75 } },
      
      // Light change - more sensitive threshold
      { id: 'light_change', condition: (f, p) => { const v=f.getLayer('visual'); const pv=p?.getLayer('visual'); if(!v||!pv)return false; return Math.abs(v.stats.luminance-pv.stats.luminance)>0.15; }, inference: { type:'lighting_change', cause:'environmental_change', effect:'luminance_shift', confidence:0.7 } },
      
      // Stationary device
      { id: 'stationary', condition: (f, p) => { const v=f.getLayer('visual'); const m=f.getLayer('motion'); return v?.motionDelta<0.05 && (!m?.data?.accel || Math.sqrt(m.data.accel.x**2+m.data.accel.y**2+m.data.accel.z**2)<2); }, inference: { type:'stationary', cause:'device_stable', effect:'stable_scene', confidence:0.85 } },
      
      // Scene change (new)
      { id: 'scene_change', condition: (f, p) => { const v=f.getLayer('visual'); return v?.sceneChange === true; }, inference: { type:'scene_change', cause:'camera_movement', effect:'new_scene', confidence:0.8 } },
      
      // High entropy (complex scene)
      { id: 'complex_scene', condition: (f, p) => { const v=f.getLayer('visual'); return v?.entropy?.total > 0.7; }, inference: { type:'complex_scene', cause:'high_detail', effect:'information_rich', confidence:0.65 } },
      
      // Low entropy (simple/uniform scene)
      { id: 'simple_scene', condition: (f, p) => { const v=f.getLayer('visual'); return v?.entropy?.total < 0.3; }, inference: { type:'simple_scene', cause:'low_detail', effect:'uniform_area', confidence:0.65 } },
      
      // Visual motion without device motion
      { id: 'object_motion', condition: (f, p) => { const v=f.getLayer('visual'); const m=f.getLayer('motion'); const hasDeviceMotion = m?.data?.accel && Math.sqrt(m.data.accel.x**2+m.data.accel.y**2+m.data.accel.z**2) > 1.5; return v?.motionDelta > 0.2 && !hasDeviceMotion; }, inference: { type:'object_motion', cause:'moving_object', effect:'scene_dynamics', confidence:0.6 } },
      
      // Continuous capture (always true as fallback)
      { id: 'capture', condition: (f, p) => true, inference: { type:'continuous_capture', cause:'recording', effect:'data_acquisition', confidence:0.9 } },
    ];
    this.patternTemplates = [
      { id: 'repeated_motion', detect: (frames) => { const mds = frames.map(f=>f.getLayer('visual')?.motionDelta||0); return mds.filter(m=>m>0.3).length > frames.length*0.6; }, pattern: { type:'consistent_motion' } },
      { id: 'scene_stability', detect: (frames) => { const mds = frames.map(f=>f.getLayer('visual')?.motionDelta||0); return mds.filter(m=>m<0.1).length > frames.length*0.8; }, pattern: { type:'stable_scene' } },
      { id: 'entropy_variation', detect: (frames) => { const ents = frames.map(f=>f.getLayer('visual')?.entropy?.total||0.5); const avg = ents.reduce((a,b)=>a+b,0)/ents.length; const variance = ents.reduce((a,e)=>a+Math.pow(e-avg,2),0)/ents.length; return variance > 0.02; }, pattern: { type:'dynamic_complexity' } },
    ];
    this.inferences = [];
    this.patterns = [];
    this.recentFrames = [];
  }
  reason(frame, prevFrame) {
    const results = { inferences: [], patterns: [] };
    this.recentFrames.push(frame);
    if (this.recentFrames.length > 20) this.recentFrames.shift();
    
    // Track if any meaningful rule matched
    let meaningfulMatch = false;
    
    for (const rule of this.rules) {
      try {
        // Skip the fallback 'capture' rule if we already have a meaningful inference
        if (rule.id === 'capture' && meaningfulMatch) continue;
        
        if (rule.condition(frame, prevFrame)) {
          const inf = { ...rule.inference, frameIndex: frame.index, ruleId: rule.id, timestamp: U.timestamp() };
          results.inferences.push(inf);
          
          // Don't store fallback inferences in history to avoid inflation
          if (rule.id !== 'capture') {
            this.inferences.push(inf);
            meaningfulMatch = true;
          }
          
          frame.addCausalInference(inf);
          bus.emit('causal:inference', inf);
        }
      } catch (e) {
        DEBUG.log('Causal rule error:', rule.id, e.message);
      }
    }
    
    if (this.recentFrames.length >= 5 && frame.index % 5 === 0) {
      for (const t of this.patternTemplates) {
        try {
          if (t.detect(this.recentFrames.slice(-10))) {
            const pat = { ...t.pattern, detectedAt: frame.index, confidence: 0.7 };
            results.patterns.push(pat);
            this.patterns.push(pat);
            frame.addPattern(pat);
            bus.emit('causal:pattern', pat);
          }
        } catch (e) {}
      }
    }
    
    // Set WHY based on most meaningful inference (not fallback)
    const meaningfulInf = results.inferences.find(i => i.ruleId !== 'capture') || results.inferences[0];
    frame.setWH('why', meaningfulInf?.type || 'capture');
    frame.setWH('because', meaningfulInf?.cause || 'normal_sequence');
    
    return results;
  }
  getSummary() {
    return {
      totalInferences: this.inferences.length,
      totalPatterns: this.patterns.length,
      recentInferences: this.inferences.slice(-10),
      recentPatterns: this.patterns.slice(-5),
    };
  }
  clear() { this.inferences = []; this.patterns = []; this.recentFrames = []; }
}

// SensorCoordinator
class SensorCoordinator {
  constructor() {
    this.sensors = new Map();
    this.readings = new Map();
    this.readingTimes = new Map();
    this.health = new Map();
    this.uncertainties = new Map();
  }
  register(name, config) {
    this.sensors.set(name, { name, priority: config.priority || 'optional', updateRate: config.updateRate || 100, timeout: config.timeout || 1000, baseUncertainty: config.baseUncertainty || 0.05, enabled: true, ...config });
    this.health.set(name, { status: 'init', lastUpdate: 0, errorCount: 0, consecutiveErrors: 0, updateCount: 0, quality: 1.0 });
    this.uncertainties.set(name, { current: config.baseUncertainty || 0.05 });
  }
  update(name, data, timestamp = U.timestamp(), uncertainty = null) {
    const health = this.health.get(name);
    const sensor = this.sensors.get(name);
    if (!health || !sensor) return;
    this.readings.set(name, data);
    this.readingTimes.set(name, timestamp);
    health.status = 'healthy';
    health.lastUpdate = timestamp;
    health.consecutiveErrors = 0;
    health.updateCount++;
    health.quality = 1.0;
    const unc = this.uncertainties.get(name);
    if (unc) unc.current = uncertainty !== null ? uncertainty : sensor.baseUncertainty;
    bus.emit('sensor:update', { name, data, timestamp });
  }
  error(name, err) {
    const health = this.health.get(name);
    if (!health) return;
    health.errorCount++;
    health.consecutiveErrors++;
    if (health.consecutiveErrors >= 5) health.status = 'failed';
    else if (health.consecutiveErrors >= 2) health.status = 'degraded';
    health.quality *= 0.8;
    bus.emit('sensor:error', { name, error: err });
    Log.warn('sensor', `${name} error: ${err}`);
  }
  get(name) { return this.readings.get(name); }
  getTime(name) { return this.readingTimes.get(name) || 0; }
  getUncertainty(name) { return this.uncertainties.get(name)?.current || 0; }
  getHealth(name) {
    const h = this.health.get(name);
    if (!h) return 'unknown';
    const sensor = this.sensors.get(name);
    const age = U.timestamp() - h.lastUpdate;
    if (h.status === 'failed') return 'failed';
    if (h.status === 'init') return 'init';
    if (age > (sensor?.timeout || 1000)) return 'stale';
    if (h.consecutiveErrors > 0) return 'degraded';
    return 'healthy';
  }
  getFullHealth(name) {
    const h = this.health.get(name);
    return { status: this.getHealth(name), quality: h?.quality || 0, uncertainty: this.getUncertainty(name), updateCount: h?.updateCount || 0, errorCount: h?.errorCount || 0 };
  }
  getAllHealth() { const r = {}; this.sensors.forEach((_, name) => { r[name] = this.getFullHealth(name); }); return r; }
  getCriticalStatus() { let ok = true; this.sensors.forEach((c, name) => { if (c.priority === 'critical' && this.getHealth(name) !== 'healthy') ok = false; }); return ok; }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SENSOR MONITOR â€” Real-Time Sensor Dashboard
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SensorMonitor {
  constructor() {
    this.history = new Map(); // sensor -> array of { timestamp, value }
    this.historyLength = 60; // Keep 60 samples (1 minute at 1Hz)
    this.isMonitoring = false;
    this.updateInterval = null;
    this.displayModes = new Map(); // sensor -> 'graph' | 'value' | 'both'
    this.calibration = new Map(); // sensor -> { offset, scale }
    
    // Initialize history for each sensor
    ['video', 'audio', 'visual', 'gps', 'motion', 'env'].forEach(s => {
      this.history.set(s, []);
      this.displayModes.set(s, 'both');
      this.calibration.set(s, { offset: 0, scale: 1 });
    });
  }
  
  start() {
    if (this.isMonitoring) return;
    this.isMonitoring = true;
    
    // Listen for sensor updates
    bus.on('sensor:update', this._handleUpdate.bind(this));
    
    // Start periodic UI refresh
    this.updateInterval = setInterval(() => this._refreshUI(), 500);
    
    Log.ok('monitor', 'Sensor monitoring started');
  }
  
  stop() {
    if (!this.isMonitoring) return;
    this.isMonitoring = false;
    
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    
    Log.info('monitor', 'Sensor monitoring stopped');
  }
  
  _handleUpdate({ name, data, timestamp }) {
    const history = this.history.get(name);
    if (!history) return;
    
    // Extract primary value based on sensor type
    let value = 0;
    switch (name) {
      case 'audio':
        value = data?.volume || 0;
        break;
      case 'visual':
        value = data?.entropy?.total || 0;
        break;
      case 'gps':
        value = data?.accuracy || 0;
        break;
      case 'motion':
        const accel = data?.accel;
        value = accel ? Math.sqrt(accel.x**2 + accel.y**2 + accel.z**2) : 0;
        break;
      case 'env':
        value = data?.light || data?.device ? 1 : 0;
        break;
      case 'video':
        value = data?.active ? 1 : 0;
        break;
      default:
        value = 0;
    }
    
    // Apply calibration
    const cal = this.calibration.get(name);
    if (cal) {
      value = (value + cal.offset) * cal.scale;
    }
    
    // Add to history
    history.push({ timestamp, value });
    
    // Trim to max length
    while (history.length > this.historyLength) {
      history.shift();
    }
  }
  
  _refreshUI() {
    const container = document.getElementById('sensor-details');
    if (!container || !container.offsetParent) return; // Skip if not visible
    
    this._renderDashboard(container);
  }
  
  _renderDashboard(container) {
    const sensors = ['video', 'audio', 'visual', 'gps', 'motion', 'env'];
    
    let html = `<div class="sensor-monitor-grid">`;
    
    sensors.forEach(name => {
      const state = SensorState.get(name);
      const coordHealth = orch?.coordinator?.getFullHealth(name) || {};
      const history = this.history.get(name) || [];
      const latest = history[history.length - 1];
      const displayMode = this.displayModes.get(name) || 'both';
      
      const statusClass = state.status === 'active' ? 'healthy' : 
                          state.status === 'stale' || state.status === 'degraded' ? 'degraded' :
                          state.status === 'denied' || state.status === 'failed' ? 'failed' : 'init';
      
      html += `
        <div class="sensor-monitor-card ${statusClass}" data-sensor="${name}">
          <div class="sensor-monitor-header">
            <span class="sensor-monitor-icon">${this._getIcon(name)}</span>
            <span class="sensor-monitor-name">${name}</span>
            <span class="sensor-monitor-status ${statusClass}">${state.status}</span>
          </div>
          <div class="sensor-monitor-body">
            ${displayMode !== 'value' ? this._renderMiniGraph(name, history) : ''}
            <div class="sensor-monitor-values">
              <div class="sensor-monitor-value">${this._formatValue(name, latest?.value)}</div>
              <div class="sensor-monitor-meta">
                ${state.hasData ? `Updated: ${this._formatAge(state.lastUpdate)}` : 'No data'}
              </div>
            </div>
          </div>
          <div class="sensor-monitor-stats">
            <span>Updates: ${coordHealth.updateCount || 0}</span>
            <span>Errors: ${coordHealth.errorCount || 0}</span>
            <span>Quality: ${((coordHealth.quality || 0) * 100).toFixed(0)}%</span>
          </div>
          <div class="sensor-monitor-controls">
            <button class="sensor-ctrl-btn" onclick="sensorMonitor.toggleDisplay('${name}')" title="Toggle view">ðŸ“Š</button>
            <button class="sensor-ctrl-btn" onclick="sensorMonitor.calibrate('${name}')" title="Calibrate">âš™ï¸</button>
            <button class="sensor-ctrl-btn" onclick="sensorMonitor.reset('${name}')" title="Reset">ðŸ”„</button>
          </div>
        </div>
      `;
    });
    
    html += `</div>`;
    
    // Summary bar
    const summary = SensorState.getSummary();
    html += `
      <div class="sensor-monitor-summary">
        <div class="summary-item good">Active: ${summary.active}</div>
        <div class="summary-item warn">Degraded: ${summary.degraded}</div>
        <div class="summary-item bad">Failed: ${summary.failed}</div>
        <div class="summary-item">Overall: ${summary.healthPercent}%</div>
      </div>
    `;
    
    // Calibration panel
    html += `
      <div class="sensor-calibration-panel" id="calibration-panel" style="display:none;">
        <div class="calibration-header">
          <span>Calibrating: <span id="cal-sensor-name">â€”</span></span>
          <button onclick="sensorMonitor.closeCalibration()">âœ•</button>
        </div>
        <div class="calibration-body">
          <label>Offset: <input type="number" id="cal-offset" step="0.01" value="0"></label>
          <label>Scale: <input type="number" id="cal-scale" step="0.1" value="1" min="0.1"></label>
          <button class="cal-apply-btn" onclick="sensorMonitor.applyCalibration()">Apply</button>
          <button class="cal-reset-btn" onclick="sensorMonitor.resetCalibration()">Reset</button>
        </div>
      </div>
    `;
    
    container.innerHTML = html;
  }
  
  _renderMiniGraph(name, history) {
    if (history.length < 2) {
      return '<div class="sensor-mini-graph empty">No data</div>';
    }
    
    const width = 100;
    const height = 30;
    const values = history.slice(-30).map(h => h.value);
    const max = Math.max(...values, 0.001);
    const min = Math.min(...values, 0);
    const range = max - min || 1;
    
    const points = values.map((v, i) => {
      const x = (i / (values.length - 1)) * width;
      const y = height - ((v - min) / range) * height;
      return `${x},${y}`;
    }).join(' ');
    
    const color = this._getColor(name);
    
    return `
      <div class="sensor-mini-graph">
        <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
          <polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5"/>
        </svg>
      </div>
    `;
  }
  
  _getIcon(name) {
    const icons = {
      video: 'ðŸŽ¥', audio: 'ðŸŽ¤', visual: 'ðŸ‘ï¸',
      gps: 'ðŸ“', motion: 'ðŸ“', env: 'ðŸ’¡'
    };
    return icons[name] || 'ðŸ“¡';
  }
  
  _getColor(name) {
    const colors = {
      video: '#22ddee', audio: '#ff8844', visual: '#8855ff',
      gps: '#22cc88', motion: '#ffcc44', env: '#ff6666'
    };
    return colors[name] || '#888888';
  }
  
  _formatValue(name, value) {
    if (value === undefined || value === null) return 'â€”';
    
    switch (name) {
      case 'audio':
        return `${(value * 100).toFixed(0)}%`;
      case 'visual':
        return value.toFixed(3);
      case 'gps':
        return `Â±${value.toFixed(0)}m`;
      case 'motion':
        return `${value.toFixed(2)}g`;
      case 'env':
        return value > 0 ? 'Active' : 'Idle';
      case 'video':
        return value > 0 ? 'Active' : 'Idle';
      default:
        return value.toFixed(2);
    }
  }
  
  _formatAge(timestamp) {
    const age = Date.now() - timestamp;
    if (age < 1000) return 'now';
    if (age < 60000) return `${Math.floor(age/1000)}s ago`;
    return `${Math.floor(age/60000)}m ago`;
  }
  
  toggleDisplay(sensor) {
    const current = this.displayModes.get(sensor) || 'both';
    const modes = ['value', 'graph', 'both'];
    const idx = (modes.indexOf(current) + 1) % modes.length;
    this.displayModes.set(sensor, modes[idx]);
    this._refreshUI();
  }
  
  calibrate(sensor) {
    const panel = document.getElementById('calibration-panel');
    const nameEl = document.getElementById('cal-sensor-name');
    const offsetEl = document.getElementById('cal-offset');
    const scaleEl = document.getElementById('cal-scale');
    
    if (panel && nameEl && offsetEl && scaleEl) {
      const cal = this.calibration.get(sensor) || { offset: 0, scale: 1 };
      nameEl.textContent = sensor;
      nameEl.dataset.sensor = sensor;
      offsetEl.value = cal.offset;
      scaleEl.value = cal.scale;
      panel.style.display = 'block';
    }
  }
  
  applyCalibration() {
    const nameEl = document.getElementById('cal-sensor-name');
    const offsetEl = document.getElementById('cal-offset');
    const scaleEl = document.getElementById('cal-scale');
    
    if (nameEl && offsetEl && scaleEl) {
      const sensor = nameEl.dataset.sensor;
      const offset = parseFloat(offsetEl.value) || 0;
      const scale = parseFloat(scaleEl.value) || 1;
      
      this.calibration.set(sensor, { offset, scale });
      Log.ok('calibration', `${sensor} calibrated: offset=${offset}, scale=${scale}`);
      this.closeCalibration();
    }
  }
  
  resetCalibration() {
    const nameEl = document.getElementById('cal-sensor-name');
    if (nameEl) {
      const sensor = nameEl.dataset.sensor;
      this.calibration.set(sensor, { offset: 0, scale: 1 });
      Log.info('calibration', `${sensor} calibration reset`);
      this.closeCalibration();
    }
  }
  
  closeCalibration() {
    const panel = document.getElementById('calibration-panel');
    if (panel) panel.style.display = 'none';
  }
  
  reset(sensor) {
    this.history.set(sensor, []);
    SensorState.retryInit(sensor);
    Log.info('monitor', `${sensor} reset and retry initiated`);
  }
  
  getStats(sensor) {
    const history = this.history.get(sensor) || [];
    if (history.length === 0) return null;
    
    const values = history.map(h => h.value);
    const min = Math.min(...values);
    const max = Math.max(...values);
    const avg = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((s, v) => s + Math.pow(v - avg, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    
    return {
      samples: history.length,
      min, max, avg, stdDev,
      first: history[0],
      last: history[history.length - 1],
      range: max - min
    };
  }
  
  getReport() {
    const report = {};
    this.history.forEach((history, sensor) => {
      report[sensor] = {
        ...this.getStats(sensor),
        calibration: this.calibration.get(sensor),
        displayMode: this.displayModes.get(sensor)
      };
    });
    return report;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SENSOR CONTROLLER â€” Advanced Sensor Management
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class SensorController {
  constructor() {
    this.profiles = new Map(); // name -> { sensors: Map<sensor, config> }
    this.activeProfile = 'default';
    this.sensorPolicies = new Map(); // sensor -> { minUpdateRate, maxLatency, requiredAccuracy }
    this.aggregators = new Map(); // sensor -> function(readings) => aggregatedValue
    
    // Initialize default profiles
    this._initProfiles();
    this._initPolicies();
  }
  
  _initProfiles() {
    // Full - all sensors enabled
    this.profiles.set('full', {
      name: 'Full',
      description: 'All sensors active',
      sensors: new Map([
        ['video', { enabled: true, rate: 30 }],
        ['audio', { enabled: true, rate: 30 }],
        ['visual', { enabled: true, rate: 30 }],
        ['gps', { enabled: true, rate: 1 }],
        ['motion', { enabled: true, rate: 60 }],
        ['env', { enabled: true, rate: 5 }]
      ])
    });
    
    // Lite - minimal sensors
    this.profiles.set('lite', {
      name: 'Lite',
      description: 'Video only, battery saver',
      sensors: new Map([
        ['video', { enabled: true, rate: 15 }],
        ['audio', { enabled: false }],
        ['visual', { enabled: true, rate: 15 }],
        ['gps', { enabled: false }],
        ['motion', { enabled: false }],
        ['env', { enabled: false }]
      ])
    });
    
    // Indoor - optimized for indoor use
    this.profiles.set('indoor', {
      name: 'Indoor',
      description: 'No GPS, enhanced audio',
      sensors: new Map([
        ['video', { enabled: true, rate: 30 }],
        ['audio', { enabled: true, rate: 60 }],
        ['visual', { enabled: true, rate: 30 }],
        ['gps', { enabled: false }],
        ['motion', { enabled: true, rate: 30 }],
        ['env', { enabled: true, rate: 10 }]
      ])
    });
    
    // Outdoor - optimized for outdoor use
    this.profiles.set('outdoor', {
      name: 'Outdoor',
      description: 'GPS enabled, motion tracking',
      sensors: new Map([
        ['video', { enabled: true, rate: 30 }],
        ['audio', { enabled: true, rate: 30 }],
        ['visual', { enabled: true, rate: 30 }],
        ['gps', { enabled: true, rate: 5 }],
        ['motion', { enabled: true, rate: 60 }],
        ['env', { enabled: true, rate: 5 }]
      ])
    });
  }
  
  _initPolicies() {
    this.sensorPolicies.set('video', {
      minUpdateRate: 10,
      maxLatency: 100,
      requiredAccuracy: null,
      priority: 'critical'
    });
    
    this.sensorPolicies.set('audio', {
      minUpdateRate: 20,
      maxLatency: 50,
      requiredAccuracy: null,
      priority: 'optional'
    });
    
    this.sensorPolicies.set('gps', {
      minUpdateRate: 0.1,
      maxLatency: 5000,
      requiredAccuracy: 100, // meters
      priority: 'optional'
    });
    
    this.sensorPolicies.set('motion', {
      minUpdateRate: 30,
      maxLatency: 100,
      requiredAccuracy: null,
      priority: 'optional'
    });
  }
  
  applyProfile(profileName) {
    const profile = this.profiles.get(profileName);
    if (!profile) {
      Log.warn('controller', `Profile "${profileName}" not found`);
      return false;
    }
    
    profile.sensors.forEach((config, sensor) => {
      SensorState.toggle(sensor, config.enabled);
      
      const coordConfig = orch?.coordinator?.sensors.get(sensor);
      if (coordConfig && config.rate) {
        coordConfig.updateRate = 1000 / config.rate; // Convert Hz to ms
      }
    });
    
    this.activeProfile = profileName;
    Log.ok('controller', `Applied profile: ${profile.name}`);
    return true;
  }
  
  getActiveProfile() {
    return this.profiles.get(this.activeProfile);
  }
  
  getProfiles() {
    return Array.from(this.profiles.entries()).map(([id, p]) => ({
      id, name: p.name, description: p.description
    }));
  }
  
  checkPolicy(sensor) {
    const policy = this.sensorPolicies.get(sensor);
    if (!policy) return { compliant: true };
    
    const coordHealth = orch?.coordinator?.getFullHealth(sensor);
    const state = SensorState.get(sensor);
    
    const issues = [];
    
    // Check update rate
    if (policy.minUpdateRate && coordHealth?.updateCount) {
      const history = sensorMonitor.history.get(sensor);
      if (history && history.length >= 2) {
        const dt = history[history.length - 1].timestamp - history[history.length - 2].timestamp;
        const actualRate = 1000 / dt;
        if (actualRate < policy.minUpdateRate * 0.8) {
          issues.push(`Update rate ${actualRate.toFixed(1)}Hz < required ${policy.minUpdateRate}Hz`);
        }
      }
    }
    
    // Check latency
    if (policy.maxLatency && state.lastUpdate) {
      const latency = Date.now() - state.lastUpdate;
      if (latency > policy.maxLatency) {
        issues.push(`Latency ${latency}ms > max ${policy.maxLatency}ms`);
      }
    }
    
    // Check accuracy (for GPS)
    if (policy.requiredAccuracy && sensor === 'gps') {
      const gpsData = orch?.coordinator?.get('gps');
      if (gpsData?.accuracy > policy.requiredAccuracy) {
        issues.push(`Accuracy ${gpsData.accuracy}m > required ${policy.requiredAccuracy}m`);
      }
    }
    
    return {
      compliant: issues.length === 0,
      issues,
      policy
    };
  }
  
  optimizeForBattery() {
    // Reduce update rates for non-critical sensors
    ['audio', 'gps', 'motion', 'env'].forEach(sensor => {
      const coordConfig = orch?.coordinator?.sensors.get(sensor);
      if (coordConfig) {
        coordConfig.updateRate *= 2; // Halve update frequency
      }
    });
    
    Log.info('controller', 'Optimized for battery life');
  }
  
  optimizeForQuality() {
    // Increase update rates for all sensors
    orch?.coordinator?.sensors.forEach((config, name) => {
      config.updateRate = Math.max(16, config.updateRate / 2); // Double frequency, min 60fps
    });
    
    Log.info('controller', 'Optimized for quality');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.11 â€” SYMBOL MESH NETWORK VISUALIZER
// "mesh network of symbol metadata linked to one another"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SymbolMeshNetwork {
  constructor(containerId) {
    this.containerId = containerId;
    this.nodes = []; // { id, type, label, data, x, y }
    this.edges = []; // { source, target, type, strength }
    this.width = 320;
    this.height = 250;
    this.simulation = null;
    this.selectedNode = null;
    
    // Relationship types with colors
    this.edgeTypes = {
      'causes': { color: '#ff6644', label: 'causes' },
      'precedes': { color: '#22ddee', label: 'precedes' },
      'contains': { color: '#8855ff', label: 'contains' },
      'resembles': { color: '#88cc44', label: 'resembles' },
      'cooccurs': { color: '#ffcc44', label: 'co-occurs' },
      'triggers': { color: '#ff88aa', label: 'triggers' }
    };
    
    // Node types with colors
    this.nodeTypes = {
      'visual': { color: '#22ddee', icon: 'ðŸ‘ï¸' },
      'motion': { color: '#ff8844', icon: 'ðŸ’¨' },
      'audio': { color: '#88cc44', icon: 'ðŸ”Š' },
      'scene': { color: '#8855ff', icon: 'ðŸŽ¬' },
      'causal': { color: '#ff6666', icon: 'âš¡' },
      'spatial': { color: '#ffcc44', icon: 'ðŸ“' },
      'temporal': { color: '#44aaff', icon: 'â±ï¸' }
    };
  }
  
  buildFromContainer(container) {
    if (!container || container.frames.length === 0) return;
    
    this.nodes = [];
    this.edges = [];
    
    const symbolMap = new Map(); // symbol_id -> node_index
    
    // Collect symbols from frames
    container.frames.forEach((frame, frameIdx) => {
      // Visual symbols
      const visual = frame.getLayer('visual');
      if (visual) {
        if (visual.sceneType && !symbolMap.has(`scene_${visual.sceneType}`)) {
          const id = `scene_${visual.sceneType}`;
          symbolMap.set(id, this.nodes.length);
          this.nodes.push({
            id, type: 'scene', label: visual.sceneType,
            data: { frameIndex: frameIdx, entropy: visual.entropy?.total },
            x: Math.random() * this.width,
            y: Math.random() * this.height
          });
        }
        
        if (visual.motionDelta > 0.2 && !symbolMap.has(`motion_f${frameIdx}`)) {
          const id = `motion_f${frameIdx}`;
          symbolMap.set(id, this.nodes.length);
          this.nodes.push({
            id, type: 'motion', label: `motion@${frameIdx}`,
            data: { frameIndex: frameIdx, delta: visual.motionDelta },
            x: Math.random() * this.width,
            y: Math.random() * this.height
          });
        }
      }
      
      // Causal symbols
      const causalInfs = frame.causalInferences || [];
      causalInfs.forEach((inf, i) => {
        const causeId = `cause_${inf.type}_f${frameIdx}`;
        const effectId = `effect_${inf.effect}_f${frameIdx}`;
        
        if (!symbolMap.has(causeId)) {
          symbolMap.set(causeId, this.nodes.length);
          this.nodes.push({
            id: causeId, type: 'causal', label: inf.type,
            data: { frameIndex: frameIdx, confidence: inf.confidence },
            x: Math.random() * this.width,
            y: Math.random() * this.height
          });
        }
        
        if (inf.effect && !symbolMap.has(effectId)) {
          symbolMap.set(effectId, this.nodes.length);
          this.nodes.push({
            id: effectId, type: 'causal', label: inf.effect,
            data: { frameIndex: frameIdx, confidence: inf.confidence },
            x: Math.random() * this.width,
            y: Math.random() * this.height
          });
          
          // Add causal edge
          this.edges.push({
            source: symbolMap.get(causeId),
            target: symbolMap.get(effectId),
            type: 'causes',
            strength: inf.confidence || 0.5
          });
        }
      });
    });
    
    // Add temporal edges (precedes)
    const motionNodes = this.nodes.filter(n => n.type === 'motion');
    for (let i = 0; i < motionNodes.length - 1; i++) {
      const curr = motionNodes[i];
      const next = motionNodes[i + 1];
      if (next.data.frameIndex - curr.data.frameIndex < 10) {
        this.edges.push({
          source: this.nodes.indexOf(curr),
          target: this.nodes.indexOf(next),
          type: 'precedes',
          strength: 0.3
        });
      }
    }
    
    // Add scene co-occurrence edges
    const sceneNodes = this.nodes.filter(n => n.type === 'scene');
    for (let i = 0; i < sceneNodes.length; i++) {
      for (let j = i + 1; j < sceneNodes.length; j++) {
        this.edges.push({
          source: this.nodes.indexOf(sceneNodes[i]),
          target: this.nodes.indexOf(sceneNodes[j]),
          type: 'cooccurs',
          strength: 0.2
        });
      }
    }
    
    // Limit nodes for performance
    if (this.nodes.length > 50) {
      this.nodes = this.nodes.slice(0, 50);
      this.edges = this.edges.filter(e => e.source < 50 && e.target < 50);
    }
    
    this._runSimulation();
  }
  
  _runSimulation() {
    // Simple force simulation (no D3 dependency)
    const iterations = 100;
    const repulsion = 500;
    const attraction = 0.05;
    const damping = 0.9;
    
    // Initialize velocities
    this.nodes.forEach(n => { n.vx = 0; n.vy = 0; });
    
    for (let iter = 0; iter < iterations; iter++) {
      // Repulsion between all nodes
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const dx = this.nodes[j].x - this.nodes[i].x;
          const dy = this.nodes[j].y - this.nodes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = repulsion / (dist * dist);
          
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          
          this.nodes[i].vx -= fx;
          this.nodes[i].vy -= fy;
          this.nodes[j].vx += fx;
          this.nodes[j].vy += fy;
        }
      }
      
      // Attraction along edges
      this.edges.forEach(e => {
        const source = this.nodes[e.source];
        const target = this.nodes[e.target];
        if (!source || !target) return;
        
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        const force = dist * attraction * e.strength;
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        
        source.vx += fx;
        source.vy += fy;
        target.vx -= fx;
        target.vy -= fy;
      });
      
      // Center gravity
      this.nodes.forEach(n => {
        n.vx += (this.width / 2 - n.x) * 0.01;
        n.vy += (this.height / 2 - n.y) * 0.01;
      });
      
      // Apply velocities with damping
      this.nodes.forEach(n => {
        n.vx *= damping;
        n.vy *= damping;
        n.x += n.vx;
        n.y += n.vy;
        
        // Bounds
        n.x = Math.max(20, Math.min(this.width - 20, n.x));
        n.y = Math.max(20, Math.min(this.height - 20, n.y));
      });
    }
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (this.nodes.length === 0) {
      container.innerHTML = '<div class="mesh-empty">No symbols to visualize. Record some content first.</div>';
      return;
    }
    
    let svg = `<svg viewBox="0 0 ${this.width} ${this.height}" class="mesh-svg">`;
    
    // Render edges
    this.edges.forEach(e => {
      const source = this.nodes[e.source];
      const target = this.nodes[e.target];
      if (!source || !target) return;
      
      const edgeStyle = this.edgeTypes[e.type] || this.edgeTypes.cooccurs;
      const opacity = 0.3 + e.strength * 0.5;
      
      svg += `<line x1="${source.x}" y1="${source.y}" x2="${target.x}" y2="${target.y}" 
                    stroke="${edgeStyle.color}" stroke-width="1.5" opacity="${opacity}"
                    class="mesh-edge" data-type="${e.type}"/>`;
    });
    
    // Render nodes
    this.nodes.forEach((n, i) => {
      const nodeStyle = this.nodeTypes[n.type] || this.nodeTypes.visual;
      const isSelected = this.selectedNode === i;
      const radius = isSelected ? 12 : 8;
      
      svg += `<circle cx="${n.x}" cy="${n.y}" r="${radius}" 
                      fill="${nodeStyle.color}" stroke="#fff" stroke-width="1"
                      class="mesh-node ${isSelected ? 'selected' : ''}" 
                      data-index="${i}" data-type="${n.type}"/>`;
      
      if (isSelected || this.nodes.length < 20) {
        svg += `<text x="${n.x}" y="${n.y + 18}" text-anchor="middle" 
                      class="mesh-label">${n.label}</text>`;
      }
    });
    
    svg += '</svg>';
    
    // Legend
    let legend = '<div class="mesh-legend">';
    Object.entries(this.nodeTypes).slice(0, 4).forEach(([type, style]) => {
      legend += `<span class="mesh-legend-item"><span style="color:${style.color}">â—</span>${type}</span>`;
    });
    legend += '</div>';
    
    // Stats
    const stats = `<div class="mesh-stats">Nodes: ${this.nodes.length} | Edges: ${this.edges.length}</div>`;
    
    container.innerHTML = legend + svg + stats;
    
    // Add click handlers
    container.querySelectorAll('.mesh-node').forEach(node => {
      node.onclick = (e) => {
        this.selectedNode = parseInt(e.target.dataset.index);
        this.render();
        this._showNodeDetails(this.selectedNode);
      };
    });
  }
  
  _showNodeDetails(index) {
    const node = this.nodes[index];
    if (!node) return;
    
    const edges = this.edges.filter(e => e.source === index || e.target === index);
    const connections = edges.map(e => {
      const other = e.source === index ? this.nodes[e.target] : this.nodes[e.source];
      return `${this.edgeTypes[e.type]?.label || e.type} â†’ ${other?.label || '?'}`;
    });
    
    const detail = document.getElementById('mesh-node-detail');
    if (detail) {
      detail.innerHTML = `
        <div class="node-detail-header">${this.nodeTypes[node.type]?.icon || 'â—‹'} ${node.label}</div>
        <div class="node-detail-type">Type: ${node.type}</div>
        <div class="node-detail-data">Frame: ${node.data?.frameIndex ?? 'â€”'}</div>
        <div class="node-detail-connections">
          <strong>Connections (${edges.length}):</strong><br>
          ${connections.slice(0, 5).join('<br>') || 'None'}
        </div>
      `;
    }
  }
  
  getStats() {
    const byType = {};
    this.nodes.forEach(n => byType[n.type] = (byType[n.type] || 0) + 1);
    
    const edgesByType = {};
    this.edges.forEach(e => edgesByType[e.type] = (edgesByType[e.type] || 0) + 1);
    
    return {
      totalNodes: this.nodes.length,
      totalEdges: this.edges.length,
      nodesByType: byType,
      edgesByType,
      density: this.nodes.length > 1 ? 
        (2 * this.edges.length) / (this.nodes.length * (this.nodes.length - 1)) : 0
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.11 â€” CAUSAL CHAIN TIMELINE
// "symbolic causal chain intelligence"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CausalChainVisualizer {
  constructor(containerId) {
    this.containerId = containerId;
    this.chains = []; // Array of chains: [{ frames, causes, effects, confidence }]
    this.selectedChain = null;
  }
  
  buildFromContainer(container) {
    if (!container || container.frames.length === 0) return;
    
    this.chains = [];
    
    // Collect all causal inferences
    const allInferences = [];
    container.frames.forEach((frame, idx) => {
      const infs = frame.causalInferences || [];
      infs.forEach(inf => {
        allInferences.push({
          frameIndex: idx,
          timestamp: frame.timestamp,
          type: inf.type,
          cause: inf.cause,
          effect: inf.effect,
          confidence: inf.confidence || 0.5
        });
      });
    });
    
    // Build chains by linking cause â†’ effect
    const used = new Set();
    
    allInferences.forEach((inf, i) => {
      if (used.has(i)) return;
      
      // Start a new chain
      const chain = {
        id: this.chains.length,
        events: [inf],
        startFrame: inf.frameIndex,
        endFrame: inf.frameIndex,
        avgConfidence: inf.confidence
      };
      
      used.add(i);
      
      // Find subsequent linked events
      let current = inf;
      for (let j = i + 1; j < allInferences.length; j++) {
        if (used.has(j)) continue;
        
        const next = allInferences[j];
        
        // Link if effect matches next cause, or within temporal window
        const isLinked = (current.effect === next.cause) ||
                         (next.frameIndex - current.frameIndex <= 5 && 
                          next.type !== current.type);
        
        if (isLinked) {
          chain.events.push(next);
          chain.endFrame = next.frameIndex;
          chain.avgConfidence = chain.events.reduce((s, e) => s + e.confidence, 0) / chain.events.length;
          used.add(j);
          current = next;
        }
      }
      
      // Only keep chains with multiple events
      if (chain.events.length >= 2) {
        this.chains.push(chain);
      }
    });
    
    // Sort by start frame
    this.chains.sort((a, b) => a.startFrame - b.startFrame);
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (this.chains.length === 0) {
      container.innerHTML = '<div class="chain-empty">No causal chains detected. Record varied content with motion.</div>';
      return;
    }
    
    let html = '<div class="chain-list">';
    
    this.chains.forEach((chain, i) => {
      const isSelected = this.selectedChain === i;
      const confidenceClass = chain.avgConfidence > 0.7 ? 'high' : 
                              chain.avgConfidence > 0.4 ? 'medium' : 'low';
      
      html += `
        <div class="chain-item ${isSelected ? 'selected' : ''}" data-chain="${i}">
          <div class="chain-header">
            <span class="chain-id">Chain ${i + 1}</span>
            <span class="chain-confidence ${confidenceClass}">${(chain.avgConfidence * 100).toFixed(0)}%</span>
          </div>
          <div class="chain-timeline">
            ${chain.events.map((e, j) => `
              <div class="chain-event" title="F${e.frameIndex}: ${e.type}">
                <div class="chain-event-dot"></div>
                <div class="chain-event-label">${e.type}</div>
                ${j < chain.events.length - 1 ? '<div class="chain-arrow">â†’</div>' : ''}
              </div>
            `).join('')}
          </div>
          <div class="chain-meta">
            F${chain.startFrame} â†’ F${chain.endFrame} (${chain.events.length} events)
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    
    // Summary
    html += `
      <div class="chain-summary">
        <div class="chain-stat">Chains: ${this.chains.length}</div>
        <div class="chain-stat">Events: ${this.chains.reduce((s, c) => s + c.events.length, 0)}</div>
        <div class="chain-stat">Avg Length: ${(this.chains.reduce((s, c) => s + c.events.length, 0) / this.chains.length).toFixed(1)}</div>
      </div>
    `;
    
    container.innerHTML = html;
    
    // Add click handlers
    container.querySelectorAll('.chain-item').forEach(item => {
      item.onclick = () => {
        this.selectedChain = parseInt(item.dataset.chain);
        this.render();
        this._showChainDetails(this.selectedChain);
      };
    });
  }
  
  _showChainDetails(index) {
    const chain = this.chains[index];
    if (!chain) return;
    
    const detail = document.getElementById('chain-detail');
    if (detail) {
      detail.innerHTML = `
        <div class="chain-detail-header">Chain ${index + 1} Analysis</div>
        <div class="chain-detail-flow">
          ${chain.events.map((e, i) => `
            <div class="chain-detail-event">
              <div class="chain-detail-frame">F${e.frameIndex}</div>
              <div class="chain-detail-type">${e.type}</div>
              <div class="chain-detail-cause">${e.cause || 'â€”'}</div>
              ${i < chain.events.length - 1 ? '<div class="chain-detail-arrow">â†“ causes</div>' : ''}
            </div>
          `).join('')}
        </div>
        <div class="chain-detail-meta">
          Confidence: ${(chain.avgConfidence * 100).toFixed(0)}% | 
          Duration: ${chain.endFrame - chain.startFrame} frames
        </div>
      `;
    }
  }
  
  getChainAt(frameIndex) {
    return this.chains.filter(c => 
      frameIndex >= c.startFrame && frameIndex <= c.endFrame
    );
  }
  
  getLongestChain() {
    return this.chains.reduce((max, c) => 
      c.events.length > (max?.events?.length || 0) ? c : max, null);
  }
  
  getStats() {
    if (this.chains.length === 0) return { total: 0 };
    
    const lengths = this.chains.map(c => c.events.length);
    const confidences = this.chains.map(c => c.avgConfidence);
    
    return {
      total: this.chains.length,
      totalEvents: lengths.reduce((a, b) => a + b, 0),
      avgLength: U.mean(lengths),
      maxLength: Math.max(...lengths),
      avgConfidence: U.mean(confidences)
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.11 â€” MFIDEL MAPPER (Ge'ez Script Symbolic Encoding)
// "Ethiopian Ge'ez script as atomic symbolic units"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MfidelMapper {
  constructor() {
    // Core Ge'ez fidel characters mapped to symbolic meanings
    // Using a subset of 272 fidel for key concepts
    this.fidelMap = {
      // Visual states (áˆ€ family - h)
      'high_entropy': 'áˆ€',    // ha
      'medium_entropy': 'áˆ',  // hu
      'low_entropy': 'áˆ‚',     // hi
      'entropy_spike': 'áˆƒ',   // haa
      'entropy_drop': 'áˆ„',    // hee
      
      // Motion states (áˆˆ family - l)
      'motion_start': 'áˆˆ',    // la
      'motion_active': 'áˆ‰',   // lu
      'motion_end': 'áˆŠ',      // li
      'motion_high': 'áˆ‹',     // laa
      'motion_low': 'áˆŒ',      // lee
      
      // Scene types (áˆ family - h')
      'scene_bright': 'áˆ',    // h'a
      'scene_dark': 'áˆ‘',      // h'u
      'scene_colorful': 'áˆ’',  // h'i
      'scene_flat': 'áˆ“',      // h'aa
      'scene_detailed': 'áˆ”',  // h'ee
      
      // Causal markers (áˆ˜ family - m)
      'cause': 'áˆ˜',           // ma
      'effect': 'áˆ™',          // mu
      'chain_start': 'áˆš',     // mi
      'chain_end': 'áˆ›',       // maa
      'inference': 'áˆœ',       // mee
      
      // Temporal markers (áˆ  family - s)
      'frame_start': 'áˆ ',     // sa
      'frame_end': 'áˆ¡',       // su
      'transition': 'áˆ¢',      // si
      'stable': 'áˆ£',          // saa
      'volatile': 'áˆ¤',        // see
      
      // Spatial markers (áˆ¨ family - r)
      'center': 'áˆ¨',          // ra
      'edge': 'áˆ©',            // ru
      'corner': 'áˆª',          // ri
      'distributed': 'áˆ«',     // raa
      'clustered': 'áˆ¬',       // ree
      
      // Audio markers (áˆ° family - s)
      'audio_loud': 'áˆ°',      // sa
      'audio_quiet': 'áˆ±',     // su
      'audio_spike': 'áˆ²',     // si
      'audio_silence': 'áˆ³',   // saa
      
      // Device markers (áˆ¸ family - sh)
      'device_still': 'áˆ¸',    // sha
      'device_shake': 'áˆ¹',    // shu
      'device_tilt': 'áˆº',     // shi
      
      // Special markers
      'boundary': 'á¢',        // sentence marker
      'separator': 'á£',       // comma
      'section': 'á¤',         // semicolon
      'keyframe': 'á¡',        // word separator
    };
    
    // Reverse map for decoding
    this.reverseFidel = {};
    Object.entries(this.fidelMap).forEach(([key, fidel]) => {
      this.reverseFidel[fidel] = key;
    });
  }
  
  encodeFrame(frame) {
    if (!frame) return '';
    
    let encoding = '';
    const visual = frame.getLayer('visual');
    
    if (visual) {
      // Entropy state
      const entropy = visual.entropy?.total || 0;
      if (entropy > 0.7) encoding += this.fidelMap.high_entropy;
      else if (entropy > 0.4) encoding += this.fidelMap.medium_entropy;
      else encoding += this.fidelMap.low_entropy;
      
      // Motion state
      const motion = visual.motionDelta || 0;
      if (motion > 0.3) encoding += this.fidelMap.motion_high;
      else if (motion > 0.1) encoding += this.fidelMap.motion_active;
      else encoding += this.fidelMap.motion_low;
      
      // Scene type
      const sceneType = visual.sceneType;
      if (sceneType) {
        const sceneKey = `scene_${sceneType}`;
        if (this.fidelMap[sceneKey]) {
          encoding += this.fidelMap[sceneKey];
        }
      }
    }
    
    // Causal markers
    const causalInfs = frame.causalInferences || [];
    if (causalInfs.length > 0) {
      encoding += this.fidelMap.cause;
      causalInfs.forEach(inf => {
        if (inf.effect) encoding += this.fidelMap.effect;
      });
    }
    
    // Add keyframe marker
    encoding += this.fidelMap.keyframe;
    
    return encoding;
  }
  
  encodeContainer(container) {
    if (!container || container.frames.length === 0) return '';
    
    let fullEncoding = '';
    let lastSceneId = -1;
    
    container.frames.forEach((frame, i) => {
      // Add scene boundary marker
      const currentScene = container.scenes.find(s => 
        i >= s.startFrame && i <= (s.endFrame || container.frames.length)
      );
      
      if (currentScene && currentScene.id !== lastSceneId) {
        fullEncoding += this.fidelMap.boundary;
        lastSceneId = currentScene.id;
      }
      
      fullEncoding += this.encodeFrame(frame);
      
      // Add separators every 10 frames
      if (i > 0 && i % 10 === 0) {
        fullEncoding += this.fidelMap.separator;
      }
    });
    
    return fullEncoding;
  }
  
  decode(encoding) {
    const result = [];
    let current = '';
    
    for (const char of encoding) {
      const meaning = this.reverseFidel[char];
      if (meaning) {
        if (meaning === 'keyframe' || meaning === 'separator' || meaning === 'boundary') {
          if (current) {
            result.push({ symbols: current, type: 'frame' });
            current = '';
          }
          if (meaning === 'boundary') {
            result.push({ symbols: char, type: 'boundary' });
          }
        } else {
          current += `${meaning} `;
        }
      }
    }
    
    if (current) {
      result.push({ symbols: current, type: 'frame' });
    }
    
    return result;
  }
  
  getSignature(container) {
    // Generate a short signature for the entire recording
    if (!container || container.frames.length === 0) return '';
    
    const samples = [];
    const step = Math.max(1, Math.floor(container.frames.length / 10));
    
    for (let i = 0; i < container.frames.length; i += step) {
      const enc = this.encodeFrame(container.frames[i]);
      samples.push(enc.slice(0, 3)); // First 3 fidel of each sample
    }
    
    return samples.join('');
  }
  
  compare(sig1, sig2) {
    // Simple similarity between two fidel signatures
    let matches = 0;
    const len = Math.min(sig1.length, sig2.length);
    
    for (let i = 0; i < len; i++) {
      if (sig1[i] === sig2[i]) matches++;
    }
    
    return len > 0 ? matches / Math.max(sig1.length, sig2.length) : 0;
  }
  
  getStats(encoding) {
    const counts = {};
    
    for (const char of encoding) {
      const meaning = this.reverseFidel[char];
      if (meaning && !['keyframe', 'separator', 'boundary', 'section'].includes(meaning)) {
        counts[meaning] = (counts[meaning] || 0) + 1;
      }
    }
    
    return counts;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.11 â€” NARRATIVE GENERATOR
// Auto-generate text description of recording
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NarrativeGenerator {
  constructor() {
    this.templates = {
      opening: [
        'The recording begins with a {sceneType} scene.',
        'The capture starts in a {sceneType} environment.',
        'Initially, we observe a {sceneType} setting.'
      ],
      motion: [
        'At {time}, significant motion is detected.',
        'Motion activity occurs at {time}.',
        'Movement is captured at {time}.'
      ],
      sceneChange: [
        'A scene transition happens at {time}, shifting to {newScene}.',
        'At {time}, the scene changes to {newScene}.',
        'The environment transitions to {newScene} at {time}.'
      ],
      causal: [
        '{cause} leads to {effect}.',
        'Due to {cause}, we observe {effect}.',
        '{cause} triggers {effect}.'
      ],
      closing: [
        'The recording concludes with {finalScene} and {finalState}.',
        'Finally, the capture ends showing {finalScene}.',
        'The sequence completes in a {finalScene} state.'
      ]
    };
  }
  
  generate(container) {
    if (!container || container.frames.length === 0) {
      return 'No content to narrate.';
    }
    
    const frames = container.frames;
    const scenes = container.getSceneSummary();
    const narrative = [];
    
    // Opening
    const firstFrame = frames[0];
    const firstVisual = firstFrame.getLayer('visual');
    const openingScene = firstVisual?.sceneType || 'neutral';
    narrative.push(this._pick(this.templates.opening).replace('{sceneType}', openingScene));
    
    // Key moments
    const keyMoments = [];
    
    // Find motion peaks
    const motions = frames.map((f, i) => ({ 
      index: i, 
      motion: f.getLayer('visual')?.motionDelta || 0,
      time: f.timestamp
    }));
    const avgMotion = motions.reduce((s, m) => s + m.motion, 0) / motions.length;
    const motionPeaks = motions.filter(m => m.motion > avgMotion * 2 && m.motion > 0.2);
    
    motionPeaks.slice(0, 3).forEach(peak => {
      keyMoments.push({
        time: peak.time,
        type: 'motion',
        text: this._pick(this.templates.motion).replace('{time}', U.formatTime(peak.time))
      });
    });
    
    // Scene changes
    scenes.forEach((scene, i) => {
      if (i > 0) {
        const prevScene = scenes[i - 1];
        keyMoments.push({
          time: scene.startTime || 0,
          type: 'scene',
          text: this._pick(this.templates.sceneChange)
            .replace('{time}', U.formatTime(scene.startTime || 0))
            .replace('{newScene}', scene.dominantType || 'different')
        });
      }
    });
    
    // Causal events
    const causalEvents = [];
    frames.forEach(f => {
      (f.causalInferences || []).forEach(inf => {
        if (inf.confidence > 0.6) {
          causalEvents.push({
            time: f.timestamp,
            cause: inf.cause || inf.type,
            effect: inf.effect
          });
        }
      });
    });
    
    causalEvents.slice(0, 2).forEach(event => {
      keyMoments.push({
        time: event.time,
        type: 'causal',
        text: this._pick(this.templates.causal)
          .replace('{cause}', event.cause)
          .replace('{effect}', event.effect || 'a response')
      });
    });
    
    // Sort by time and add to narrative
    keyMoments.sort((a, b) => a.time - b.time);
    keyMoments.forEach(m => narrative.push(m.text));
    
    // Closing
    const lastFrame = frames[frames.length - 1];
    const lastVisual = lastFrame.getLayer('visual');
    const finalScene = lastVisual?.sceneType || 'calm';
    const entropy = lastVisual?.entropy?.total || 0;
    const finalState = entropy > 0.6 ? 'high visual complexity' : 
                       entropy > 0.3 ? 'moderate activity' : 'quiet simplicity';
    
    narrative.push(this._pick(this.templates.closing)
      .replace('{finalScene}', finalScene)
      .replace('{finalState}', finalState));
    
    // Add statistics
    narrative.push('');
    narrative.push(`Key Statistics: ${frames.length} frames, ${scenes.length} scenes, ${causalEvents.length} causal events detected.`);
    
    return narrative.join(' ');
  }
  
  _pick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }
  
  generateKeyMoments(container) {
    if (!container || container.frames.length === 0) return [];
    
    const moments = [];
    const frames = container.frames;
    
    // First frame
    moments.push({
      frame: 0,
      time: 0,
      label: 'Recording start',
      type: 'start'
    });
    
    // High motion frames
    frames.forEach((f, i) => {
      const motion = f.getLayer('visual')?.motionDelta || 0;
      if (motion > 0.4) {
        moments.push({
          frame: i,
          time: f.timestamp,
          label: `High motion (${(motion * 100).toFixed(0)}%)`,
          type: 'motion'
        });
      }
    });
    
    // Scene boundaries
    container.scenes.forEach(scene => {
      moments.push({
        frame: scene.startFrame,
        time: frames[scene.startFrame]?.timestamp || 0,
        label: `Scene: ${scene.dominantType || 'new'}`,
        type: 'scene'
      });
    });
    
    // Last frame
    moments.push({
      frame: frames.length - 1,
      time: frames[frames.length - 1].timestamp,
      label: 'Recording end',
      type: 'end'
    });
    
    // Sort and deduplicate
    moments.sort((a, b) => a.frame - b.frame);
    
    return moments.filter((m, i, arr) => 
      i === 0 || m.frame !== arr[i - 1].frame
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.12 â€” INCEPTADIVE DEEP EXPLORER
// "Inception dive to Words/ideas meanings using all connected wh words!
//  Diagonal, circular, rectangular, horizontal, vertical, zigzag, jump"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class InceptaDive {
  constructor(containerId) {
    this.containerId = containerId;
    this.currentFrame = null;
    this.diveHistory = [];
    this.diveDepth = 0;
    this.maxDepth = 7;
    
    // WH dimensions for exploration
    this.whDimensions = {
      WHAT: { icon: 'ðŸ“¦', color: '#22ddee', questions: ['what is', 'what type', 'what contains'] },
      WHERE: { icon: 'ðŸ“', color: '#88cc44', questions: ['where is', 'where located', 'spatial position'] },
      WHEN: { icon: 'â±ï¸', color: '#ffcc44', questions: ['when occurred', 'temporal position', 'duration'] },
      WHO: { icon: 'ðŸ‘¤', color: '#ff88aa', questions: ['who/what agent', 'source', 'actor'] },
      WHY: { icon: 'ðŸŽ¯', color: '#ff6644', questions: ['why happened', 'cause', 'reason'] },
      HOW: { icon: 'âš™ï¸', color: '#8855ff', questions: ['how happened', 'mechanism', 'process'] },
      WHICH: { icon: 'ðŸ”€', color: '#44aaff', questions: ['which one', 'selection', 'choice'] }
    };
    
    // Navigation patterns
    this.patterns = {
      horizontal: { dx: 1, dy: 0, name: 'Horizontal', desc: 'Same depth, adjacent concepts' },
      vertical: { dx: 0, dy: 1, name: 'Vertical', desc: 'Deeper into current concept' },
      diagonal: { dx: 1, dy: 1, name: 'Diagonal', desc: 'Adjacent + deeper' },
      circular: { pattern: 'circular', name: 'Circular', desc: 'Cycle through WH dimensions' },
      zigzag: { pattern: 'zigzag', name: 'Zigzag', desc: 'Alternate horizontal/vertical' },
      jump: { pattern: 'jump', name: 'Jump', desc: 'Skip to related concept' },
      rectangular: { pattern: 'rectangular', name: 'Rectangular', desc: 'Explore boundary' }
    };
    
    this.currentPattern = 'vertical';
    this.whIndex = 0; // For circular navigation
  }
  
  setFrame(frame) {
    this.currentFrame = frame;
    this.diveHistory = [];
    this.diveDepth = 0;
    
    if (frame) {
      // Initial dive point
      this.diveHistory.push({
        depth: 0,
        dimension: 'WHAT',
        concept: 'frame',
        data: this._extractFrameData(frame),
        timestamp: Date.now()
      });
    }
  }
  
  _extractFrameData(frame) {
    const visual = frame.getLayer('visual');
    const wh = frame.getLayer('wh');
    
    return {
      index: frame.index,
      timestamp: frame.timestamp,
      entropy: visual?.entropy?.total || 0,
      motion: visual?.motionDelta || 0,
      sceneType: visual?.sceneType || 'unknown',
      luminance: visual?.avgLuminance || 0,
      wh: wh || {},
      causal: frame.causalInferences || [],
      symbols: this._extractSymbols(frame)
    };
  }
  
  _extractSymbols(frame) {
    const symbols = [];
    const visual = frame.getLayer('visual');
    
    if (visual) {
      if (visual.entropy?.total > 0.7) symbols.push({ type: 'high_entropy', value: visual.entropy.total });
      if (visual.motionDelta > 0.2) symbols.push({ type: 'motion', value: visual.motionDelta });
      if (visual.sceneType) symbols.push({ type: 'scene', value: visual.sceneType });
    }
    
    (frame.causalInferences || []).forEach(inf => {
      symbols.push({ type: 'causal', value: inf.type, confidence: inf.confidence });
    });
    
    return symbols;
  }
  
  dive(dimension, pattern = null) {
    if (!this.currentFrame) return null;
    if (this.diveDepth >= this.maxDepth) return { error: 'Maximum depth reached' };
    
    const usedPattern = pattern || this.currentPattern;
    const current = this.diveHistory[this.diveHistory.length - 1];
    
    // Get exploration result based on dimension
    const exploration = this._explore(dimension, current, usedPattern);
    
    if (exploration) {
      this.diveDepth++;
      this.diveHistory.push({
        depth: this.diveDepth,
        dimension,
        concept: exploration.concept,
        data: exploration.data,
        pattern: usedPattern,
        parent: current.concept,
        timestamp: Date.now()
      });
      
      return exploration;
    }
    
    return null;
  }
  
  _explore(dimension, current, pattern) {
    const frameData = current.data;
    const dim = this.whDimensions[dimension];
    
    switch (dimension) {
      case 'WHAT':
        return this._exploreWhat(frameData, current);
      case 'WHERE':
        return this._exploreWhere(frameData, current);
      case 'WHEN':
        return this._exploreWhen(frameData, current);
      case 'WHO':
        return this._exploreWho(frameData, current);
      case 'WHY':
        return this._exploreWhy(frameData, current);
      case 'HOW':
        return this._exploreHow(frameData, current);
      case 'WHICH':
        return this._exploreWhich(frameData, current);
      default:
        return null;
    }
  }
  
  _exploreWhat(data, current) {
    // WHAT: Explore content/entities
    const findings = [];
    
    if (data.sceneType) {
      findings.push({ label: 'Scene Type', value: data.sceneType, type: 'classification' });
    }
    if (data.entropy > 0) {
      findings.push({ 
        label: 'Visual Complexity', 
        value: data.entropy > 0.7 ? 'High' : data.entropy > 0.4 ? 'Medium' : 'Low',
        raw: data.entropy,
        type: 'measurement'
      });
    }
    if (data.symbols.length > 0) {
      findings.push({ 
        label: 'Detected Symbols', 
        value: data.symbols.map(s => s.type).join(', '),
        count: data.symbols.length,
        type: 'symbols'
      });
    }
    
    return {
      concept: 'content_analysis',
      question: 'What is in this frame?',
      findings,
      data: { ...data, whatFindings: findings }
    };
  }
  
  _exploreWhere(data, current) {
    // WHERE: Spatial analysis
    const findings = [];
    
    findings.push({ 
      label: 'Frame Position', 
      value: `Frame ${data.index}`,
      type: 'position'
    });
    
    if (data.wh?.where) {
      findings.push({
        label: 'Spatial Context',
        value: data.wh.where.description || 'Visual field',
        type: 'context'
      });
    }
    
    // Derive spatial info from luminance distribution
    const luminanceZone = data.luminance > 0.6 ? 'bright area' :
                          data.luminance < 0.3 ? 'dark area' : 'balanced lighting';
    findings.push({
      label: 'Lighting Zone',
      value: luminanceZone,
      raw: data.luminance,
      type: 'zone'
    });
    
    return {
      concept: 'spatial_analysis',
      question: 'Where does this occur?',
      findings,
      data: { ...data, whereFindings: findings }
    };
  }
  
  _exploreWhen(data, current) {
    // WHEN: Temporal analysis
    const findings = [];
    
    findings.push({
      label: 'Timestamp',
      value: U.formatTime(data.timestamp),
      raw: data.timestamp,
      type: 'time'
    });
    
    findings.push({
      label: 'Frame Sequence',
      value: `#${data.index}`,
      type: 'sequence'
    });
    
    // Temporal phase based on motion
    const phase = data.motion > 0.3 ? 'active/dynamic' :
                  data.motion > 0.1 ? 'transitional' : 'stable/static';
    findings.push({
      label: 'Temporal Phase',
      value: phase,
      type: 'phase'
    });
    
    return {
      concept: 'temporal_analysis',
      question: 'When does this occur?',
      findings,
      data: { ...data, whenFindings: findings }
    };
  }
  
  _exploreWho(data, current) {
    // WHO: Agency/source analysis
    const findings = [];
    
    // Infer agent from causal data
    const agents = data.causal
      .filter(c => c.cause)
      .map(c => ({ label: 'Causal Agent', value: c.cause, confidence: c.confidence }));
    
    if (agents.length > 0) {
      findings.push(...agents);
    } else {
      findings.push({
        label: 'Primary Agent',
        value: data.motion > 0.2 ? 'Camera/Subject motion' : 'Static observer',
        type: 'inferred'
      });
    }
    
    return {
      concept: 'agency_analysis',
      question: 'Who/what is the agent?',
      findings,
      data: { ...data, whoFindings: findings }
    };
  }
  
  _exploreWhy(data, current) {
    // WHY: Causal reasoning
    const findings = [];
    
    data.causal.forEach(inf => {
      findings.push({
        label: 'Causal Inference',
        value: `${inf.type} â†’ ${inf.effect || 'observed'}`,
        confidence: inf.confidence,
        type: 'causal'
      });
    });
    
    if (findings.length === 0) {
      // Infer reasons from state
      if (data.motion > 0.3) {
        findings.push({
          label: 'Motion Reason',
          value: 'Activity detected (camera or subject movement)',
          type: 'inferred'
        });
      }
      if (data.entropy > 0.7) {
        findings.push({
          label: 'Complexity Reason',
          value: 'High visual information density',
          type: 'inferred'
        });
      }
    }
    
    return {
      concept: 'causal_analysis',
      question: 'Why did this happen?',
      findings,
      data: { ...data, whyFindings: findings }
    };
  }
  
  _exploreHow(data, current) {
    // HOW: Mechanism/process analysis
    const findings = [];
    
    findings.push({
      label: 'Capture Method',
      value: 'Video frame extraction',
      type: 'mechanism'
    });
    
    findings.push({
      label: 'Analysis Pipeline',
      value: 'Sense â†’ Sync â†’ Symbol â†’ Reason',
      type: 'process'
    });
    
    if (data.motion > 0) {
      findings.push({
        label: 'Motion Mechanism',
        value: `Delta: ${(data.motion * 100).toFixed(1)}% change`,
        type: 'measurement'
      });
    }
    
    return {
      concept: 'mechanism_analysis',
      question: 'How did this occur?',
      findings,
      data: { ...data, howFindings: findings }
    };
  }
  
  _exploreWhich(data, current) {
    // WHICH: Selection/alternatives
    const findings = [];
    
    // List available exploration paths
    const paths = Object.keys(this.whDimensions).filter(d => 
      !this.diveHistory.some(h => h.depth === this.diveDepth && h.dimension === d)
    );
    
    findings.push({
      label: 'Available Paths',
      value: paths.join(', '),
      type: 'options'
    });
    
    findings.push({
      label: 'Current Depth',
      value: `${this.diveDepth}/${this.maxDepth}`,
      type: 'status'
    });
    
    findings.push({
      label: 'Symbols Present',
      value: data.symbols.length,
      type: 'count'
    });
    
    return {
      concept: 'selection_analysis',
      question: 'Which path to explore?',
      findings,
      data: { ...data, whichFindings: findings }
    };
  }
  
  navigateCircular() {
    const dims = Object.keys(this.whDimensions);
    this.whIndex = (this.whIndex + 1) % dims.length;
    return this.dive(dims[this.whIndex], 'circular');
  }
  
  navigateZigzag() {
    // Alternate between horizontal (WHAT/WHERE) and vertical (WHY/HOW)
    const horizontal = ['WHAT', 'WHERE', 'WHEN'];
    const vertical = ['WHY', 'HOW', 'WHO'];
    
    const lastDim = this.diveHistory.length > 0 ? 
      this.diveHistory[this.diveHistory.length - 1].dimension : 'WHAT';
    
    const isHorizontal = horizontal.includes(lastDim);
    const nextPool = isHorizontal ? vertical : horizontal;
    const nextDim = nextPool[Math.floor(Math.random() * nextPool.length)];
    
    return this.dive(nextDim, 'zigzag');
  }
  
  navigateJump(targetConcept) {
    // Jump to a related concept
    const relatedDimension = this._findRelatedDimension(targetConcept);
    return this.dive(relatedDimension, 'jump');
  }
  
  _findRelatedDimension(concept) {
    const conceptMap = {
      'motion': 'HOW',
      'scene': 'WHAT',
      'time': 'WHEN',
      'location': 'WHERE',
      'cause': 'WHY',
      'agent': 'WHO',
      'choice': 'WHICH'
    };
    return conceptMap[concept] || 'WHAT';
  }
  
  ascend() {
    if (this.diveHistory.length > 1) {
      this.diveHistory.pop();
      this.diveDepth--;
      return this.diveHistory[this.diveHistory.length - 1];
    }
    return null;
  }
  
  reset() {
    if (this.currentFrame) {
      this.setFrame(this.currentFrame);
    }
  }
  
  getPath() {
    return this.diveHistory.map(h => ({
      depth: h.depth,
      dimension: h.dimension,
      concept: h.concept,
      pattern: h.pattern
    }));
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (!this.currentFrame) {
      container.innerHTML = '<div class="dive-empty">Select a frame to begin exploration.</div>';
      return;
    }
    
    const current = this.diveHistory[this.diveHistory.length - 1];
    
    let html = `
      <div class="dive-header">
        <div class="dive-depth">Depth: ${this.diveDepth}/${this.maxDepth}</div>
        <div class="dive-frame">Frame ${this.currentFrame.index}</div>
      </div>
      
      <div class="dive-current">
        <div class="dive-dimension">${this.whDimensions[current.dimension]?.icon || 'â—‹'} ${current.dimension}</div>
        <div class="dive-question">${current.concept}</div>
      </div>
      
      <div class="dive-findings">
        ${(current.data?.whatFindings || current.data?.whereFindings || 
           current.data?.whenFindings || current.data?.whoFindings ||
           current.data?.whyFindings || current.data?.howFindings ||
           current.data?.whichFindings || []).map(f => `
          <div class="dive-finding">
            <span class="dive-finding-label">${f.label}:</span>
            <span class="dive-finding-value">${f.value}</span>
            ${f.confidence ? `<span class="dive-finding-conf">${(f.confidence * 100).toFixed(0)}%</span>` : ''}
          </div>
        `).join('')}
      </div>
      
      <div class="dive-nav-grid">
        ${Object.entries(this.whDimensions).map(([dim, info]) => `
          <button class="dive-nav-btn" style="--dim-color: ${info.color}" 
                  onclick="inceptaDive.dive('${dim}')" 
                  ${this.diveDepth >= this.maxDepth ? 'disabled' : ''}>
            <span class="dive-nav-icon">${info.icon}</span>
            <span class="dive-nav-label">${dim}</span>
          </button>
        `).join('')}
      </div>
      
      <div class="dive-patterns">
        <button class="dive-pattern-btn" onclick="inceptaDive.navigateCircular()">ðŸ”„ Circular</button>
        <button class="dive-pattern-btn" onclick="inceptaDive.navigateZigzag()">âš¡ Zigzag</button>
        <button class="dive-pattern-btn" onclick="inceptaDive.ascend()" ${this.diveDepth === 0 ? 'disabled' : ''}>â¬†ï¸ Ascend</button>
        <button class="dive-pattern-btn" onclick="inceptaDive.reset()">ðŸ”„ Reset</button>
      </div>
      
      <div class="dive-path">
        <div class="dive-path-title">Exploration Path</div>
        <div class="dive-path-trail">
          ${this.diveHistory.map((h, i) => `
            <span class="dive-path-node" style="--node-color: ${this.whDimensions[h.dimension]?.color || '#888'}">
              ${h.dimension.slice(0, 2)}
            </span>
            ${i < this.diveHistory.length - 1 ? '<span class="dive-path-arrow">â†’</span>' : ''}
          `).join('')}
        </div>
      </div>
    `;
    
    container.innerHTML = html;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.12 â€” SYMBOL ONTOLOGY BROWSER
// Hierarchical view of all symbol types
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SymbolOntology {
  constructor(containerId) {
    this.containerId = containerId;
    this.expanded = new Set(['root', 'visual', 'causal']);
    
    // Symbol type hierarchy
    this.ontology = {
      id: 'root',
      label: 'SYMBOLS',
      icon: 'ðŸŒ³',
      children: [
        {
          id: 'visual',
          label: 'Visual',
          icon: 'ðŸ‘ï¸',
          color: '#22ddee',
          children: [
            {
              id: 'spatial',
              label: 'Spatial',
              icon: 'ðŸ“',
              children: [
                { id: 'bright_region', label: 'Bright Region', icon: 'â˜€ï¸' },
                { id: 'dark_region', label: 'Dark Region', icon: 'ðŸŒ™' },
                { id: 'edge_cluster', label: 'Edge Cluster', icon: 'ðŸ“' },
                { id: 'center_focus', label: 'Center Focus', icon: 'ðŸŽ¯' }
              ]
            },
            {
              id: 'temporal',
              label: 'Temporal',
              icon: 'â±ï¸',
              children: [
                { id: 'motion_start', label: 'Motion Start', icon: 'â–¶ï¸' },
                { id: 'motion_end', label: 'Motion End', icon: 'â¹ï¸' },
                { id: 'scene_change', label: 'Scene Change', icon: 'ðŸŽ¬' },
                { id: 'stabilization', label: 'Stabilization', icon: 'âš–ï¸' }
              ]
            },
            {
              id: 'information',
              label: 'Information',
              icon: 'ðŸ“Š',
              children: [
                { id: 'high_entropy', label: 'High Entropy', icon: 'ðŸ”¥' },
                { id: 'low_entropy', label: 'Low Entropy', icon: 'â„ï¸' },
                { id: 'novelty', label: 'Novelty', icon: 'âœ¨' }
              ]
            }
          ]
        },
        {
          id: 'audio',
          label: 'Audio',
          icon: 'ðŸ”Š',
          color: '#88cc44',
          children: [
            { id: 'volume_spike', label: 'Volume Spike', icon: 'ðŸ“ˆ' },
            { id: 'silence', label: 'Silence', icon: 'ðŸ”‡' },
            { id: 'frequency_shift', label: 'Frequency Shift', icon: 'ã€°ï¸' }
          ]
        },
        {
          id: 'motion',
          label: 'Motion',
          icon: 'ðŸ’¨',
          color: '#ff8844',
          children: [
            { id: 'camera_pan', label: 'Camera Pan', icon: 'â†”ï¸' },
            { id: 'camera_shake', label: 'Camera Shake', icon: 'ðŸ“³' },
            { id: 'object_motion', label: 'Object Motion', icon: 'ðŸƒ' },
            { id: 'device_tilt', label: 'Device Tilt', icon: 'ðŸ“±' }
          ]
        },
        {
          id: 'causal',
          label: 'Causal',
          icon: 'âš¡',
          color: '#ff6666',
          children: [
            { id: 'cause', label: 'Cause', icon: 'ðŸŽ¯' },
            { id: 'effect', label: 'Effect', icon: 'ðŸ’¥' },
            { id: 'chain_link', label: 'Chain Link', icon: 'ðŸ”—' },
            { id: 'inference', label: 'Inference', icon: 'ðŸ’¡' }
          ]
        },
        {
          id: 'scene',
          label: 'Scene',
          icon: 'ðŸŽ¬',
          color: '#8855ff',
          children: [
            { id: 'scene_bright', label: 'Bright Scene', icon: 'â˜€ï¸' },
            { id: 'scene_dark', label: 'Dark Scene', icon: 'ðŸŒ™' },
            { id: 'scene_colorful', label: 'Colorful Scene', icon: 'ðŸŒˆ' },
            { id: 'scene_flat', label: 'Flat Scene', icon: 'â¬œ' },
            { id: 'scene_detailed', label: 'Detailed Scene', icon: 'ðŸ”' }
          ]
        },
        {
          id: 'wh',
          label: 'WH Semantic',
          icon: 'â“',
          color: '#ffcc44',
          children: [
            { id: 'wh_what', label: 'WHAT', icon: 'ðŸ“¦' },
            { id: 'wh_where', label: 'WHERE', icon: 'ðŸ“' },
            { id: 'wh_when', label: 'WHEN', icon: 'â°' },
            { id: 'wh_who', label: 'WHO', icon: 'ðŸ‘¤' },
            { id: 'wh_why', label: 'WHY', icon: 'ðŸŽ¯' },
            { id: 'wh_how', label: 'HOW', icon: 'âš™ï¸' }
          ]
        }
      ]
    };
    
    this.symbolCounts = new Map();
  }
  
  countFromContainer(container) {
    this.symbolCounts.clear();
    
    if (!container || container.frames.length === 0) return;
    
    container.frames.forEach(frame => {
      const visual = frame.getLayer('visual');
      
      if (visual) {
        // Entropy symbols
        if (visual.entropy?.total > 0.7) this._increment('high_entropy');
        else if (visual.entropy?.total < 0.3) this._increment('low_entropy');
        
        // Motion symbols
        if (visual.motionDelta > 0.3) this._increment('motion_start');
        if (visual.motionDelta < 0.05 && frame.index > 0) this._increment('stabilization');
        
        // Scene symbols
        if (visual.sceneType) {
          this._increment(`scene_${visual.sceneType}`);
        }
      }
      
      // Causal symbols
      (frame.causalInferences || []).forEach(inf => {
        this._increment('cause');
        if (inf.effect) this._increment('effect');
        this._increment('inference');
      });
    });
    
    // Update parent counts
    this._aggregateCounts(this.ontology);
  }
  
  _increment(symbolId) {
    this.symbolCounts.set(symbolId, (this.symbolCounts.get(symbolId) || 0) + 1);
  }
  
  _aggregateCounts(node) {
    if (!node.children) {
      return this.symbolCounts.get(node.id) || 0;
    }
    
    let total = this.symbolCounts.get(node.id) || 0;
    node.children.forEach(child => {
      total += this._aggregateCounts(child);
    });
    
    this.symbolCounts.set(node.id, total);
    return total;
  }
  
  toggle(nodeId) {
    if (this.expanded.has(nodeId)) {
      this.expanded.delete(nodeId);
    } else {
      this.expanded.add(nodeId);
    }
    this.render();
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    const html = this._renderNode(this.ontology, 0);
    container.innerHTML = `<div class="ontology-tree">${html}</div>`;
  }
  
  _renderNode(node, depth) {
    const hasChildren = node.children && node.children.length > 0;
    const isExpanded = this.expanded.has(node.id);
    const count = this.symbolCounts.get(node.id) || 0;
    const indent = depth * 16;
    
    let html = `
      <div class="ontology-node" style="padding-left: ${indent}px" data-id="${node.id}">
        <span class="ontology-toggle" onclick="symbolOntology.toggle('${node.id}')">
          ${hasChildren ? (isExpanded ? 'â–¼' : 'â–¶') : 'â—‹'}
        </span>
        <span class="ontology-icon">${node.icon || 'â—‹'}</span>
        <span class="ontology-label" style="color: ${node.color || 'inherit'}">${node.label}</span>
        ${count > 0 ? `<span class="ontology-count">${count}</span>` : ''}
      </div>
    `;
    
    if (hasChildren && isExpanded) {
      node.children.forEach(child => {
        html += this._renderNode(child, depth + 1);
      });
    }
    
    return html;
  }
  
  getSymbolInfo(symbolId) {
    return this._findNode(this.ontology, symbolId);
  }
  
  _findNode(node, id) {
    if (node.id === id) return node;
    if (node.children) {
      for (const child of node.children) {
        const found = this._findNode(child, id);
        if (found) return found;
      }
    }
    return null;
  }
  
  getPath(symbolId) {
    const path = [];
    this._buildPath(this.ontology, symbolId, path);
    return path;
  }
  
  _buildPath(node, targetId, path) {
    path.push(node.id);
    
    if (node.id === targetId) return true;
    
    if (node.children) {
      for (const child of node.children) {
        if (this._buildPath(child, targetId, path)) return true;
      }
    }
    
    path.pop();
    return false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.12 â€” SYMBOLIC QUERY LANGUAGE
// Natural language â†’ symbolic operations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SymbolicQueryLanguage {
  constructor() {
    this.patterns = [
      // Find patterns
      { regex: /^find\s+(frames?\s+)?where\s+(.+)$/i, handler: 'findWhere' },
      { regex: /^find\s+(frames?\s+)?with\s+(.+)$/i, handler: 'findWith' },
      { regex: /^show\s+(.+)\s+frames?$/i, handler: 'showType' },
      
      // Causal patterns
      { regex: /^what\s+caused\s+(.+)$/i, handler: 'whatCaused' },
      { regex: /^why\s+did\s+(.+)$/i, handler: 'whyDid' },
      { regex: /^(.+)\s+leads?\s+to\s+(.+)$/i, handler: 'leadsTo' },
      
      // WH patterns
      { regex: /^what\s+is\s+in\s+frame\s+(\d+)$/i, handler: 'whatInFrame' },
      { regex: /^when\s+does?\s+(.+)\s+happen$/i, handler: 'whenHappen' },
      { regex: /^where\s+is\s+(.+)$/i, handler: 'whereIs' },
      { regex: /^how\s+many\s+(.+)$/i, handler: 'howMany' },
      
      // Comparison patterns
      { regex: /^compare\s+frame\s+(\d+)\s+(?:and|with|to)\s+(\d+)$/i, handler: 'compareFrames' },
      { regex: /^diff(?:erence)?\s+(\d+)\s+(\d+)$/i, handler: 'diffFrames' },
      
      // Chain patterns
      { regex: /^trace\s+(.+)\s+from\s+frame\s+(\d+)$/i, handler: 'traceFrom' },
      { regex: /^follow\s+(.+)$/i, handler: 'followChain' }
    ];
  }
  
  parse(query, container) {
    if (!container || container.frames.length === 0) {
      return { success: false, error: 'No data available' };
    }
    
    const normalized = query.trim().toLowerCase();
    
    for (const pattern of this.patterns) {
      const match = normalized.match(pattern.regex);
      if (match) {
        return this[pattern.handler](match, container);
      }
    }
    
    // Fallback: keyword search
    return this.keywordSearch(normalized, container);
  }
  
  findWhere(match, container) {
    const condition = match[2];
    const results = [];
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      
      // Parse conditions
      if (condition.includes('entropy') && condition.includes('high') && visual?.entropy?.total > 0.7) {
        results.push({ frame: i, reason: 'high entropy', value: visual.entropy.total });
      }
      if (condition.includes('motion') && visual?.motionDelta > 0.2) {
        results.push({ frame: i, reason: 'motion detected', value: visual.motionDelta });
      }
      if (condition.includes('bright') && visual?.avgLuminance > 0.6) {
        results.push({ frame: i, reason: 'bright scene', value: visual.avgLuminance });
      }
      if (condition.includes('dark') && visual?.avgLuminance < 0.3) {
        results.push({ frame: i, reason: 'dark scene', value: visual.avgLuminance });
      }
    });
    
    return {
      success: true,
      type: 'find',
      query: `FIND frames WHERE ${condition}`,
      results,
      count: results.length
    };
  }
  
  findWith(match, container) {
    const target = match[2];
    const results = [];
    
    container.frames.forEach((frame, i) => {
      const causal = frame.causalInferences || [];
      
      if (target.includes('causal') && causal.length > 0) {
        results.push({ frame: i, reason: 'has causal inference', count: causal.length });
      }
      
      if (target.includes('scene') && frame.getLayer('visual')?.sceneType) {
        results.push({ frame: i, reason: 'has scene type', value: frame.getLayer('visual').sceneType });
      }
    });
    
    return {
      success: true,
      type: 'find',
      query: `FIND frames WITH ${target}`,
      results,
      count: results.length
    };
  }
  
  showType(match, container) {
    const type = match[1];
    const results = [];
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      
      if (type.includes('bright') && visual?.sceneType === 'bright') {
        results.push({ frame: i, type: 'bright' });
      }
      if (type.includes('dark') && visual?.sceneType === 'dark') {
        results.push({ frame: i, type: 'dark' });
      }
      if (type.includes('motion') && visual?.motionDelta > 0.2) {
        results.push({ frame: i, type: 'motion', value: visual.motionDelta });
      }
    });
    
    return {
      success: true,
      type: 'show',
      query: `SHOW ${type} frames`,
      results,
      count: results.length
    };
  }
  
  whatCaused(match, container) {
    const effect = match[1];
    const causes = [];
    
    container.frames.forEach((frame, i) => {
      (frame.causalInferences || []).forEach(inf => {
        if (inf.effect?.toLowerCase().includes(effect) || inf.type?.toLowerCase().includes(effect)) {
          causes.push({
            frame: i,
            cause: inf.cause || inf.type,
            effect: inf.effect,
            confidence: inf.confidence
          });
        }
      });
    });
    
    return {
      success: true,
      type: 'causal',
      query: `WHAT CAUSED ${effect}`,
      results: causes,
      count: causes.length
    };
  }
  
  whyDid(match, container) {
    return this.whatCaused(match, container);
  }
  
  leadsTo(match, container) {
    const cause = match[1];
    const effect = match[2];
    const chains = [];
    
    container.frames.forEach((frame, i) => {
      (frame.causalInferences || []).forEach(inf => {
        if ((inf.type?.toLowerCase().includes(cause) || inf.cause?.toLowerCase().includes(cause)) &&
            inf.effect?.toLowerCase().includes(effect)) {
          chains.push({
            frame: i,
            cause: inf.cause || inf.type,
            effect: inf.effect,
            confidence: inf.confidence
          });
        }
      });
    });
    
    return {
      success: true,
      type: 'chain',
      query: `${cause} LEADS TO ${effect}`,
      results: chains,
      count: chains.length
    };
  }
  
  whatInFrame(match, container) {
    const frameIdx = parseInt(match[1]);
    const frame = container.frames[frameIdx];
    
    if (!frame) {
      return { success: false, error: `Frame ${frameIdx} not found` };
    }
    
    const visual = frame.getLayer('visual');
    const contents = {
      sceneType: visual?.sceneType || 'unknown',
      entropy: visual?.entropy?.total || 0,
      motion: visual?.motionDelta || 0,
      luminance: visual?.avgLuminance || 0,
      causal: frame.causalInferences?.length || 0
    };
    
    return {
      success: true,
      type: 'inspect',
      query: `WHAT IS IN frame ${frameIdx}`,
      frame: frameIdx,
      contents
    };
  }
  
  whenHappen(match, container) {
    const event = match[1];
    const occurrences = [];
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      
      if (event.includes('motion') && visual?.motionDelta > 0.2) {
        occurrences.push({ frame: i, time: frame.timestamp, event: 'motion' });
      }
      if (event.includes('scene') && visual?.sceneType) {
        occurrences.push({ frame: i, time: frame.timestamp, event: 'scene change' });
      }
    });
    
    return {
      success: true,
      type: 'temporal',
      query: `WHEN DOES ${event} HAPPEN`,
      results: occurrences,
      count: occurrences.length
    };
  }
  
  howMany(match, container) {
    const target = match[1];
    let count = 0;
    
    if (target.includes('frame')) {
      count = container.frames.length;
    } else if (target.includes('scene')) {
      count = container.scenes?.length || 0;
    } else if (target.includes('causal') || target.includes('inference')) {
      container.frames.forEach(f => {
        count += (f.causalInferences || []).length;
      });
    } else if (target.includes('motion')) {
      container.frames.forEach(f => {
        if (f.getLayer('visual')?.motionDelta > 0.2) count++;
      });
    }
    
    return {
      success: true,
      type: 'count',
      query: `HOW MANY ${target}`,
      count
    };
  }
  
  compareFrames(match, container) {
    const idx1 = parseInt(match[1]);
    const idx2 = parseInt(match[2]);
    
    const f1 = container.frames[idx1];
    const f2 = container.frames[idx2];
    
    if (!f1 || !f2) {
      return { success: false, error: 'Frame not found' };
    }
    
    const v1 = f1.getLayer('visual');
    const v2 = f2.getLayer('visual');
    
    return {
      success: true,
      type: 'compare',
      query: `COMPARE frame ${idx1} AND ${idx2}`,
      comparison: {
        entropy: { f1: v1?.entropy?.total || 0, f2: v2?.entropy?.total || 0 },
        motion: { f1: v1?.motionDelta || 0, f2: v2?.motionDelta || 0 },
        luminance: { f1: v1?.avgLuminance || 0, f2: v2?.avgLuminance || 0 },
        sceneType: { f1: v1?.sceneType || '?', f2: v2?.sceneType || '?' }
      }
    };
  }
  
  diffFrames(match, container) {
    return this.compareFrames(match, container);
  }
  
  keywordSearch(query, container) {
    // Simple keyword matching
    const results = [];
    const keywords = query.split(/\s+/);
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      const text = JSON.stringify({
        scene: visual?.sceneType,
        causal: frame.causalInferences
      }).toLowerCase();
      
      const matches = keywords.filter(k => text.includes(k));
      if (matches.length > 0) {
        results.push({ frame: i, matches });
      }
    });
    
    return {
      success: true,
      type: 'search',
      query: `SEARCH ${query}`,
      results,
      count: results.length
    };
  }
  
  formatResult(result) {
    if (!result.success) {
      return `Error: ${result.error}`;
    }
    
    let output = `${result.query}\n${'â•'.repeat(35)}\n`;
    
    switch (result.type) {
      case 'find':
      case 'show':
      case 'temporal':
      case 'search':
        output += `Found: ${result.count} results\n\n`;
        result.results.slice(0, 10).forEach(r => {
          output += `  F${r.frame}: ${r.reason || r.event || r.type || r.matches?.join(', ') || ''}`;
          if (r.value !== undefined) output += ` (${typeof r.value === 'number' ? r.value.toFixed(3) : r.value})`;
          output += '\n';
        });
        if (result.count > 10) output += `  ... and ${result.count - 10} more\n`;
        break;
        
      case 'causal':
      case 'chain':
        output += `Found: ${result.count} causal relationships\n\n`;
        result.results.slice(0, 10).forEach(r => {
          output += `  F${r.frame}: ${r.cause} â†’ ${r.effect} (${(r.confidence * 100).toFixed(0)}%)\n`;
        });
        break;
        
      case 'inspect':
        output += `Frame ${result.frame} contents:\n`;
        output += `  Scene: ${result.contents.sceneType}\n`;
        output += `  Entropy: ${result.contents.entropy.toFixed(3)}\n`;
        output += `  Motion: ${result.contents.motion.toFixed(3)}\n`;
        output += `  Luminance: ${result.contents.luminance.toFixed(3)}\n`;
        output += `  Causal Events: ${result.contents.causal}\n`;
        break;
        
      case 'count':
        output += `Count: ${result.count}\n`;
        break;
        
      case 'compare':
        output += `Comparison:\n`;
        Object.entries(result.comparison).forEach(([key, vals]) => {
          output += `  ${key}: ${typeof vals.f1 === 'number' ? vals.f1.toFixed(3) : vals.f1} vs ${typeof vals.f2 === 'number' ? vals.f2.toFixed(3) : vals.f2}\n`;
        });
        break;
    }
    
    return output;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.13 â€” AUDIO WAVEFORM VISUALIZER
// Visualize audio with video sync, detect audio-visual correlation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AudioWaveformVisualizer {
  constructor(containerId) {
    this.containerId = containerId;
    this.audioData = [];
    this.peaks = [];
    this.correlations = [];
    this.width = 320;
    this.height = 80;
    this.currentTime = 0;
  }
  
  extractFromContainer(container) {
    if (!container || container.frames.length === 0) return;
    
    this.audioData = [];
    this.peaks = [];
    this.correlations = [];
    
    container.frames.forEach((frame, i) => {
      const audio = frame.getLayer('audio');
      const visual = frame.getLayer('visual');
      
      // Extract audio metrics
      const volume = audio?.volume || Math.random() * 0.5; // Simulated if no real audio
      const frequency = audio?.dominantFreq || 440;
      const isSilent = volume < 0.1;
      
      this.audioData.push({
        frame: i,
        timestamp: frame.timestamp,
        volume,
        frequency,
        isSilent,
        // Audio-visual correlation
        visualMotion: visual?.motionDelta || 0,
        visualEntropy: visual?.entropy?.total || 0
      });
      
      // Detect peaks (significant volume spikes)
      if (i > 0 && volume > 0.5 && volume > this.audioData[i-1].volume * 1.5) {
        this.peaks.push({
          frame: i,
          timestamp: frame.timestamp,
          volume,
          type: 'spike'
        });
      }
    });
    
    // Calculate audio-visual correlations
    this._calculateCorrelations();
  }
  
  _calculateCorrelations() {
    if (this.audioData.length < 10) return;
    
    // Window-based correlation between volume and motion
    const windowSize = 10;
    for (let i = windowSize; i < this.audioData.length; i++) {
      const window = this.audioData.slice(i - windowSize, i);
      
      const volumes = window.map(d => d.volume);
      const motions = window.map(d => d.visualMotion);
      
      const correlation = this._pearsonCorrelation(volumes, motions);
      
      if (Math.abs(correlation) > 0.5) {
        this.correlations.push({
          frame: i,
          timestamp: this.audioData[i].timestamp,
          correlation,
          type: correlation > 0 ? 'sync' : 'anti-sync'
        });
      }
    }
  }
  
  _pearsonCorrelation(x, y) {
    const n = x.length;
    if (n === 0) return 0;
    
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
    const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
    const sumY2 = y.reduce((acc, yi) => acc + yi * yi, 0);
    
    const num = n * sumXY - sumX * sumY;
    const den = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
    
    return den === 0 ? 0 : num / den;
  }
  
  setCurrentTime(time) {
    this.currentTime = time;
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (this.audioData.length === 0) {
      container.innerHTML = '<div class="audio-empty">No audio data. Record with microphone enabled.</div>';
      return;
    }
    
    const maxTime = this.audioData[this.audioData.length - 1]?.timestamp || 1;
    const currentX = (this.currentTime / maxTime) * this.width;
    
    // Build waveform SVG
    let svg = `<svg viewBox="0 0 ${this.width} ${this.height}" class="audio-waveform-svg">`;
    
    // Background grid
    svg += `<rect x="0" y="0" width="${this.width}" height="${this.height}" fill="#0a0a14"/>`;
    for (let i = 0; i <= 4; i++) {
      const y = (i / 4) * this.height;
      svg += `<line x1="0" y1="${y}" x2="${this.width}" y2="${y}" stroke="#222" stroke-width="0.5"/>`;
    }
    
    // Waveform path
    const centerY = this.height / 2;
    let pathD = `M 0 ${centerY}`;
    
    this.audioData.forEach((d, i) => {
      const x = (i / this.audioData.length) * this.width;
      const amplitude = d.volume * (this.height / 2 - 5);
      pathD += ` L ${x} ${centerY - amplitude}`;
    });
    
    // Mirror path for full waveform
    for (let i = this.audioData.length - 1; i >= 0; i--) {
      const d = this.audioData[i];
      const x = (i / this.audioData.length) * this.width;
      const amplitude = d.volume * (this.height / 2 - 5);
      pathD += ` L ${x} ${centerY + amplitude}`;
    }
    pathD += ' Z';
    
    svg += `<path d="${pathD}" fill="url(#audioGradient)" opacity="0.7"/>`;
    
    // Gradient definition
    svg += `<defs>
      <linearGradient id="audioGradient" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%" stop-color="#88cc44"/>
        <stop offset="50%" stop-color="#22ddee"/>
        <stop offset="100%" stop-color="#88cc44"/>
      </linearGradient>
    </defs>`;
    
    // Peak markers
    this.peaks.forEach(p => {
      const x = (p.frame / this.audioData.length) * this.width;
      svg += `<line x1="${x}" y1="0" x2="${x}" y2="${this.height}" stroke="#ff6644" stroke-width="1" opacity="0.6"/>`;
      svg += `<circle cx="${x}" cy="5" r="3" fill="#ff6644"/>`;
    });
    
    // Correlation markers
    this.correlations.forEach(c => {
      const x = (c.frame / this.audioData.length) * this.width;
      const color = c.type === 'sync' ? '#88cc44' : '#ff88aa';
      svg += `<rect x="${x-2}" y="${this.height-8}" width="4" height="6" fill="${color}" rx="1"/>`;
    });
    
    // Playhead
    svg += `<line x1="${currentX}" y1="0" x2="${currentX}" y2="${this.height}" stroke="#fff" stroke-width="2"/>`;
    
    svg += '</svg>';
    
    // Stats
    const avgVolume = this.audioData.reduce((s, d) => s + d.volume, 0) / this.audioData.length;
    const silentFrames = this.audioData.filter(d => d.isSilent).length;
    
    const stats = `
      <div class="audio-stats">
        <div class="audio-stat"><span>Avg Volume:</span><span>${(avgVolume * 100).toFixed(0)}%</span></div>
        <div class="audio-stat"><span>Peaks:</span><span>${this.peaks.length}</span></div>
        <div class="audio-stat"><span>Silent:</span><span>${silentFrames}</span></div>
        <div class="audio-stat"><span>Sync Events:</span><span>${this.correlations.length}</span></div>
      </div>
    `;
    
    container.innerHTML = svg + stats;
  }
  
  getStats() {
    return {
      frameCount: this.audioData.length,
      peakCount: this.peaks.length,
      correlationCount: this.correlations.length,
      avgVolume: this.audioData.length > 0 ? 
        this.audioData.reduce((s, d) => s + d.volume, 0) / this.audioData.length : 0,
      silentPercent: this.audioData.length > 0 ?
        (this.audioData.filter(d => d.isSilent).length / this.audioData.length) * 100 : 0
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.13 â€” MOTION TRAJECTORY OVERLAY
// Draw motion paths on playback, show velocity/acceleration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MotionTrajectoryOverlay {
  constructor(containerId) {
    this.containerId = containerId;
    this.trajectories = [];
    this.currentFrame = 0;
    this.showVectors = true;
    this.showPath = true;
    this.trailLength = 30;
    this.width = 320;
    this.height = 180;
  }
  
  buildFromContainer(container) {
    if (!container || container.frames.length === 0) return;
    
    this.trajectories = [];
    
    // Extract motion vectors from frames
    let lastCentroid = { x: this.width / 2, y: this.height / 2 };
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      const motion = visual?.motionDelta || 0;
      
      // Simulate centroid movement based on motion
      // In real implementation, this would come from optical flow
      const angle = (i * 0.3) + Math.sin(i * 0.1) * Math.PI;
      const displacement = motion * 50;
      
      const centroid = {
        x: Math.max(20, Math.min(this.width - 20, lastCentroid.x + Math.cos(angle) * displacement)),
        y: Math.max(20, Math.min(this.height - 20, lastCentroid.y + Math.sin(angle) * displacement))
      };
      
      // Calculate velocity and acceleration
      const velocity = i > 0 ? {
        x: centroid.x - lastCentroid.x,
        y: centroid.y - lastCentroid.y,
        magnitude: Math.sqrt(Math.pow(centroid.x - lastCentroid.x, 2) + Math.pow(centroid.y - lastCentroid.y, 2))
      } : { x: 0, y: 0, magnitude: 0 };
      
      const acceleration = i > 1 ? {
        magnitude: velocity.magnitude - (this.trajectories[i-1]?.velocity?.magnitude || 0)
      } : { magnitude: 0 };
      
      this.trajectories.push({
        frame: i,
        timestamp: frame.timestamp,
        centroid,
        velocity,
        acceleration,
        motionDelta: motion,
        // Classify motion type
        type: this._classifyMotion(velocity, acceleration)
      });
      
      lastCentroid = centroid;
    });
  }
  
  _classifyMotion(velocity, acceleration) {
    if (velocity.magnitude < 2) return 'static';
    if (acceleration.magnitude > 3) return 'accelerating';
    if (acceleration.magnitude < -3) return 'decelerating';
    if (velocity.magnitude > 10) return 'fast';
    return 'steady';
  }
  
  setCurrentFrame(frame) {
    this.currentFrame = Math.min(frame, this.trajectories.length - 1);
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (this.trajectories.length === 0) {
      container.innerHTML = '<div class="motion-empty">No motion data. Record some content first.</div>';
      return;
    }
    
    let svg = `<svg viewBox="0 0 ${this.width} ${this.height}" class="motion-trajectory-svg">`;
    
    // Background
    svg += `<rect x="0" y="0" width="${this.width}" height="${this.height}" fill="#0a0a14"/>`;
    
    // Grid
    for (let i = 0; i <= 4; i++) {
      const x = (i / 4) * this.width;
      const y = (i / 4) * this.height;
      svg += `<line x1="${x}" y1="0" x2="${x}" y2="${this.height}" stroke="#1a1a2e" stroke-width="0.5"/>`;
      svg += `<line x1="0" y1="${y}" x2="${this.width}" y2="${y}" stroke="#1a1a2e" stroke-width="0.5"/>`;
    }
    
    // Trail path
    if (this.showPath) {
      const startIdx = Math.max(0, this.currentFrame - this.trailLength);
      const trailPoints = this.trajectories.slice(startIdx, this.currentFrame + 1);
      
      if (trailPoints.length > 1) {
        let pathD = `M ${trailPoints[0].centroid.x} ${trailPoints[0].centroid.y}`;
        trailPoints.slice(1).forEach(t => {
          pathD += ` L ${t.centroid.x} ${t.centroid.y}`;
        });
        
        svg += `<path d="${pathD}" fill="none" stroke="url(#trailGradient)" stroke-width="2" stroke-linecap="round"/>`;
      }
      
      // Trail gradient
      svg += `<defs>
        <linearGradient id="trailGradient" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="#22ddee" stop-opacity="0.1"/>
          <stop offset="100%" stop-color="#22ddee" stop-opacity="1"/>
        </linearGradient>
      </defs>`;
    }
    
    // Velocity vectors
    if (this.showVectors && this.currentFrame < this.trajectories.length) {
      const current = this.trajectories[this.currentFrame];
      const vel = current.velocity;
      
      if (vel.magnitude > 1) {
        const scale = 3;
        svg += `<line x1="${current.centroid.x}" y1="${current.centroid.y}" 
                      x2="${current.centroid.x + vel.x * scale}" y2="${current.centroid.y + vel.y * scale}" 
                      stroke="#ff8844" stroke-width="2" marker-end="url(#arrowhead)"/>`;
      }
      
      // Arrowhead marker
      svg += `<defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#ff8844"/>
        </marker>
      </defs>`;
    }
    
    // Current position
    if (this.currentFrame < this.trajectories.length) {
      const current = this.trajectories[this.currentFrame];
      const typeColors = {
        'static': '#666',
        'accelerating': '#ff6644',
        'decelerating': '#44aaff',
        'fast': '#ff88aa',
        'steady': '#88cc44'
      };
      const color = typeColors[current.type] || '#22ddee';
      
      svg += `<circle cx="${current.centroid.x}" cy="${current.centroid.y}" r="8" fill="${color}" stroke="#fff" stroke-width="2"/>`;
      svg += `<circle cx="${current.centroid.x}" cy="${current.centroid.y}" r="12" fill="none" stroke="${color}" stroke-width="1" opacity="0.5"/>`;
    }
    
    svg += '</svg>';
    
    // Controls and stats
    const current = this.trajectories[this.currentFrame] || {};
    const controls = `
      <div class="motion-controls">
        <label><input type="checkbox" ${this.showPath ? 'checked' : ''} onchange="motionOverlay.showPath=this.checked;motionOverlay.render()"> Trail</label>
        <label><input type="checkbox" ${this.showVectors ? 'checked' : ''} onchange="motionOverlay.showVectors=this.checked;motionOverlay.render()"> Vectors</label>
        <span class="motion-frame">F${this.currentFrame}</span>
      </div>
      <div class="motion-stats">
        <div class="motion-stat"><span>Type:</span><span class="motion-type-${current.type || 'static'}">${current.type || 'static'}</span></div>
        <div class="motion-stat"><span>Velocity:</span><span>${(current.velocity?.magnitude || 0).toFixed(1)} px/f</span></div>
        <div class="motion-stat"><span>Accel:</span><span>${(current.acceleration?.magnitude || 0).toFixed(2)}</span></div>
      </div>
    `;
    
    container.innerHTML = svg + controls;
  }
  
  getStats() {
    if (this.trajectories.length === 0) return {};
    
    const velocities = this.trajectories.map(t => t.velocity.magnitude);
    const types = {};
    this.trajectories.forEach(t => types[t.type] = (types[t.type] || 0) + 1);
    
    return {
      totalFrames: this.trajectories.length,
      avgVelocity: U.mean(velocities),
      maxVelocity: Math.max(...velocities),
      motionTypes: types,
      totalDistance: velocities.reduce((a, b) => a + b, 0)
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.13 â€” MULLU ECOSYSTEM EXPORTER
// Export to .mullu format for Mullu Inspect, MulluSI integration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MulluExporter {
  constructor() {
    this.version = '1.0';
    this.format = 'mullu-symbolic';
  }
  
  export(container, options = {}) {
    if (!container || container.frames.length === 0) {
      return { error: 'No data to export' };
    }
    
    const mulluData = {
      // Header
      mullu: {
        version: this.version,
        format: this.format,
        generator: 'VIRECAI v2.27',
        timestamp: new Date().toISOString()
      },
      
      // Recording metadata
      meta: {
        id: container.id,
        startTime: container.startTime,
        duration: container.getDuration(),
        frameCount: container.frames.length,
        sceneCount: container.scenes?.length || 0
      },
      
      // Symbol mesh (graph structure)
      symbolMesh: this._exportSymbolMesh(container),
      
      // Causal chains
      causalChains: this._exportCausalChains(container),
      
      // Mfidel encoding
      mfidel: {
        signature: mfidelMapper.getSignature(container),
        fullEncoding: mfidelMapper.encodeContainer(container),
        stats: mfidelMapper.getStats(mfidelMapper.encodeContainer(container))
      },
      
      // Frame summaries (compact)
      frames: container.frames.map((frame, i) => this._exportFrame(frame, i)),
      
      // Scene hierarchy
      scenes: container.scenes?.map(s => ({
        id: s.id,
        startFrame: s.startFrame,
        endFrame: s.endFrame,
        type: s.dominantType,
        entropy: s.avgEntropy
      })) || [],
      
      // WH semantic layer
      whSemantics: this._exportWHSemantics(container),
      
      // Ontology summary
      ontology: this._exportOntology(container)
    };
    
    return mulluData;
  }
  
  _exportSymbolMesh(container) {
    symbolMesh.buildFromContainer(container);
    return {
      nodes: symbolMesh.nodes.map(n => ({
        id: n.id,
        type: n.type,
        label: n.label,
        frame: n.data?.frameIndex
      })),
      edges: symbolMesh.edges.map(e => ({
        source: e.source,
        target: e.target,
        type: e.type,
        strength: e.strength
      })),
      stats: symbolMesh.getStats()
    };
  }
  
  _exportCausalChains(container) {
    causalChain.buildFromContainer(container);
    return {
      chains: causalChain.chains.map(c => ({
        id: c.id,
        events: c.events.map(e => ({
          frame: e.frameIndex,
          type: e.type,
          cause: e.cause,
          effect: e.effect,
          confidence: e.confidence
        })),
        confidence: c.avgConfidence
      })),
      stats: causalChain.getStats()
    };
  }
  
  _exportFrame(frame, index) {
    const visual = frame.getLayer('visual');
    return {
      i: index,
      t: Math.round(frame.timestamp),
      // Compact visual metrics
      v: {
        e: +(visual?.entropy?.total || 0).toFixed(3),
        m: +(visual?.motionDelta || 0).toFixed(3),
        l: +(visual?.avgLuminance || 0).toFixed(3),
        s: visual?.sceneType || null
      },
      // Causal inferences (compact)
      c: (frame.causalInferences || []).map(inf => ({
        t: inf.type,
        e: inf.effect,
        p: +(inf.confidence || 0).toFixed(2)
      })),
      // Mfidel signature for this frame
      f: mfidelMapper.encodeFrame(frame)
    };
  }
  
  _exportWHSemantics(container) {
    const whData = {
      what: [],
      where: [],
      when: [],
      who: [],
      why: [],
      how: []
    };
    
    container.frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      const causal = frame.causalInferences || [];
      
      // WHAT: content types
      if (visual?.sceneType) {
        whData.what.push({ frame: i, value: visual.sceneType });
      }
      
      // WHEN: temporal events
      if (visual?.motionDelta > 0.3) {
        whData.when.push({ frame: i, event: 'motion_peak', value: visual.motionDelta });
      }
      
      // WHY: causal events
      causal.forEach(inf => {
        whData.why.push({ frame: i, cause: inf.type, effect: inf.effect });
      });
    });
    
    return whData;
  }
  
  _exportOntology(container) {
    symbolOntology.countFromContainer(container);
    return {
      counts: Object.fromEntries(symbolOntology.symbolCounts),
      tree: this._flattenOntology(symbolOntology.ontology)
    };
  }
  
  _flattenOntology(node, path = []) {
    const result = [{
      id: node.id,
      path: [...path, node.id],
      label: node.label,
      count: symbolOntology.symbolCounts.get(node.id) || 0
    }];
    
    if (node.children) {
      node.children.forEach(child => {
        result.push(...this._flattenOntology(child, [...path, node.id]));
      });
    }
    
    return result;
  }
  
  toJSON(container) {
    return JSON.stringify(this.export(container), null, 2);
  }
  
  toCompact(container) {
    return JSON.stringify(this.export(container));
  }
  
  download(container, filename = 'recording.mullu') {
    const data = this.toJSON(container);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    
    URL.revokeObjectURL(url);
    
    return { success: true, size: data.length, filename };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.13 â€” PERFORMANCE MONITOR
// Real-time FPS, memory, and processing metrics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PerformanceMonitor {
  constructor() {
    this.fps = 0;
    this.memory = 0;
    this.frameTime = 0;
    this.history = [];
    this.maxHistory = 60;
    this.lastFrameTime = 0;
    this.frameCount = 0;
    this.lastFpsUpdate = 0;
    this.isRunning = false;
  }
  
  start() {
    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.lastFpsUpdate = this.lastFrameTime;
    this._tick();
  }
  
  stop() {
    this.isRunning = false;
  }
  
  _tick() {
    if (!this.isRunning) return;
    
    const now = performance.now();
    this.frameTime = now - this.lastFrameTime;
    this.lastFrameTime = now;
    this.frameCount++;
    
    // Update FPS every second
    if (now - this.lastFpsUpdate >= 1000) {
      this.fps = this.frameCount;
      this.frameCount = 0;
      this.lastFpsUpdate = now;
      
      // Get memory if available
      if (performance.memory) {
        this.memory = performance.memory.usedJSHeapSize / (1024 * 1024);
      }
      
      // Record history
      this.history.push({
        time: now,
        fps: this.fps,
        memory: this.memory,
        frameTime: this.frameTime
      });
      
      if (this.history.length > this.maxHistory) {
        this.history.shift();
      }
    }
    
    requestAnimationFrame(() => this._tick());
  }
  
  getMetrics() {
    return {
      fps: this.fps,
      memory: this.memory.toFixed(1),
      frameTime: this.frameTime.toFixed(1),
      avgFps: this.history.length > 0 ? 
        (this.history.reduce((s, h) => s + h.fps, 0) / this.history.length).toFixed(1) : 0
    };
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const metrics = this.getMetrics();
    const fpsClass = this.fps >= 30 ? 'good' : this.fps >= 15 ? 'medium' : 'poor';
    
    container.innerHTML = `
      <div class="perf-monitor">
        <div class="perf-metric">
          <span class="perf-label">FPS</span>
          <span class="perf-value perf-${fpsClass}">${metrics.fps}</span>
        </div>
        <div class="perf-metric">
          <span class="perf-label">Memory</span>
          <span class="perf-value">${metrics.memory} MB</span>
        </div>
        <div class="perf-metric">
          <span class="perf-label">Frame</span>
          <span class="perf-value">${metrics.frameTime} ms</span>
        </div>
      </div>
    `;
  }
  
  renderMiniGraph(containerId) {
    const container = document.getElementById(containerId);
    if (!container || this.history.length < 2) return;
    
    const width = 80;
    const height = 30;
    const maxFps = 60;
    
    let pathD = `M 0 ${height}`;
    this.history.forEach((h, i) => {
      const x = (i / this.history.length) * width;
      const y = height - (h.fps / maxFps) * height;
      pathD += ` L ${x} ${y}`;
    });
    pathD += ` L ${width} ${height} Z`;
    
    container.innerHTML = `
      <svg viewBox="0 0 ${width} ${height}" class="perf-mini-graph">
        <path d="${pathD}" fill="#22ddee" opacity="0.3"/>
        <text x="2" y="10" class="perf-mini-label">${this.fps} fps</text>
      </svg>
    `;
  }
}

// Global v2.26 instances
const symbolMesh = new SymbolMeshNetwork('mesh-container');
const causalChain = new CausalChainVisualizer('chain-container');
const mfidelMapper = new MfidelMapper();
const narrativeGen = new NarrativeGenerator();
const inceptaDive = new InceptaDive('dive-container');
const symbolOntology = new SymbolOntology('ontology-container');
const symbolicQuery = new SymbolicQueryLanguage();
const audioWaveform = new AudioWaveformVisualizer('audio-container');
const motionOverlay = new MotionTrajectoryOverlay('motion-container');
const mulluExporter = new MulluExporter();
const perfMonitor = new PerformanceMonitor();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 â€” AI PATTERN DETECTOR
// Automatic detection of patterns, anomalies, events, and highlights
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PatternDetector {
  constructor() {
    this.patterns = [];
    this.anomalies = [];
    this.highlights = [];
    this.thresholds = {
      entropySpike: 0.3,
      motionSpike: 0.25,
      sceneChange: 0.4,
      anomalyZScore: 2.0
    };
  }
  
  analyze(container) {
    if (!container || container.frames.length < 10) return;
    
    this.patterns = [];
    this.anomalies = [];
    this.highlights = [];
    
    const frames = container.frames;
    
    // Extract time series
    const entropies = frames.map(f => f.getLayer('visual')?.entropy?.total || 0);
    const motions = frames.map(f => f.getLayer('visual')?.motionDelta || 0);
    const luminances = frames.map(f => f.getLayer('visual')?.avgLuminance || 0);
    
    // Calculate statistics
    const stats = {
      entropy: this._getStats(entropies),
      motion: this._getStats(motions),
      luminance: this._getStats(luminances)
    };
    
    // Detect patterns
    this._detectSpikes(frames, entropies, 'entropy', stats.entropy);
    this._detectSpikes(frames, motions, 'motion', stats.motion);
    this._detectSceneChanges(frames);
    this._detectAnomalies(frames, stats);
    this._detectRepeatingPatterns(frames, entropies, motions);
    this._selectHighlights(frames);
    
    return {
      patterns: this.patterns,
      anomalies: this.anomalies,
      highlights: this.highlights,
      stats
    };
  }
  
  _getStats(arr) {
    const n = arr.length;
    if (n === 0) return { mean: 0, std: 0, min: 0, max: 0 };
    
    const mean = arr.reduce((a, b) => a + b, 0) / n;
    const variance = arr.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
    const std = Math.sqrt(variance);
    
    return {
      mean,
      std,
      min: Math.min(...arr),
      max: Math.max(...arr)
    };
  }
  
  _detectSpikes(frames, values, type, stats) {
    const threshold = stats.mean + stats.std * 1.5;
    
    for (let i = 1; i < values.length - 1; i++) {
      const prev = values[i - 1];
      const curr = values[i];
      const next = values[i + 1];
      
      // Local maximum above threshold
      if (curr > threshold && curr > prev && curr > next) {
        this.patterns.push({
          type: `${type}_spike`,
          frame: i,
          timestamp: frames[i].timestamp,
          value: curr,
          magnitude: (curr - stats.mean) / stats.std,
          confidence: Math.min(1, (curr - threshold) / (stats.max - threshold + 0.001))
        });
      }
    }
  }
  
  _detectSceneChanges(frames) {
    for (let i = 1; i < frames.length; i++) {
      const prev = frames[i - 1].getLayer('visual');
      const curr = frames[i].getLayer('visual');
      
      if (!prev || !curr) continue;
      
      // Detect scene type change
      if (prev.sceneType !== curr.sceneType) {
        this.patterns.push({
          type: 'scene_change',
          frame: i,
          timestamp: frames[i].timestamp,
          from: prev.sceneType,
          to: curr.sceneType,
          confidence: 0.9
        });
      }
      
      // Detect luminance shift
      const lumDiff = Math.abs((curr.avgLuminance || 0) - (prev.avgLuminance || 0));
      if (lumDiff > 0.3) {
        this.patterns.push({
          type: 'luminance_shift',
          frame: i,
          timestamp: frames[i].timestamp,
          delta: lumDiff,
          direction: curr.avgLuminance > prev.avgLuminance ? 'brighter' : 'darker',
          confidence: Math.min(1, lumDiff / 0.5)
        });
      }
    }
  }
  
  _detectAnomalies(frames, stats) {
    frames.forEach((frame, i) => {
      const visual = frame.getLayer('visual');
      if (!visual) return;
      
      const entropy = visual.entropy?.total || 0;
      const motion = visual.motionDelta || 0;
      
      // Z-score based anomaly detection
      const entropyZ = stats.entropy.std > 0 ? 
        Math.abs(entropy - stats.entropy.mean) / stats.entropy.std : 0;
      const motionZ = stats.motion.std > 0 ? 
        Math.abs(motion - stats.motion.mean) / stats.motion.std : 0;
      
      if (entropyZ > this.thresholds.anomalyZScore || motionZ > this.thresholds.anomalyZScore) {
        this.anomalies.push({
          frame: i,
          timestamp: frame.timestamp,
          type: entropyZ > motionZ ? 'entropy_anomaly' : 'motion_anomaly',
          zScore: Math.max(entropyZ, motionZ),
          values: { entropy, motion },
          severity: Math.max(entropyZ, motionZ) > 3 ? 'high' : 'medium'
        });
      }
    });
  }
  
  _detectRepeatingPatterns(frames, entropies, motions) {
    // Simple pattern: detect sustained high/low states
    let highMotionStart = -1;
    let lowMotionStart = -1;
    
    const motionStats = this._getStats(motions);
    const highThreshold = motionStats.mean + motionStats.std;
    const lowThreshold = motionStats.mean - motionStats.std * 0.5;
    
    for (let i = 0; i < motions.length; i++) {
      // High motion sustained
      if (motions[i] > highThreshold) {
        if (highMotionStart === -1) highMotionStart = i;
      } else {
        if (highMotionStart !== -1 && i - highMotionStart >= 5) {
          this.patterns.push({
            type: 'sustained_motion',
            startFrame: highMotionStart,
            endFrame: i - 1,
            duration: i - highMotionStart,
            timestamp: frames[highMotionStart].timestamp,
            confidence: 0.8
          });
        }
        highMotionStart = -1;
      }
      
      // Low motion (stillness)
      if (motions[i] < lowThreshold) {
        if (lowMotionStart === -1) lowMotionStart = i;
      } else {
        if (lowMotionStart !== -1 && i - lowMotionStart >= 10) {
          this.patterns.push({
            type: 'stillness',
            startFrame: lowMotionStart,
            endFrame: i - 1,
            duration: i - lowMotionStart,
            timestamp: frames[lowMotionStart].timestamp,
            confidence: 0.7
          });
        }
        lowMotionStart = -1;
      }
    }
  }
  
  _selectHighlights(frames) {
    // Select best moments based on combined scoring
    const scored = frames.map((frame, i) => {
      const visual = frame.getLayer('visual');
      const causal = frame.causalInferences?.length || 0;
      
      let score = 0;
      
      // Entropy contribution
      score += (visual?.entropy?.total || 0) * 2;
      
      // Motion contribution
      score += (visual?.motionDelta || 0) * 3;
      
      // Causal events boost
      score += causal * 5;
      
      // Pattern presence boost
      const hasPattern = this.patterns.some(p => p.frame === i || 
        (p.startFrame <= i && p.endFrame >= i));
      if (hasPattern) score += 3;
      
      return { frame: i, score, timestamp: frame.timestamp };
    });
    
    // Sort by score and take top moments
    scored.sort((a, b) => b.score - a.score);
    
    // Take top 5, ensuring they're spaced apart
    const selected = [];
    for (const item of scored) {
      if (selected.length >= 5) break;
      
      // Ensure at least 10 frames apart from existing highlights
      const tooClose = selected.some(s => Math.abs(s.frame - item.frame) < 10);
      if (!tooClose) {
        selected.push(item);
      }
    }
    
    this.highlights = selected.sort((a, b) => a.frame - b.frame);
  }
  
  getPatternsByType(type) {
    return this.patterns.filter(p => p.type === type);
  }
  
  getSummary() {
    const typeCounts = {};
    this.patterns.forEach(p => {
      typeCounts[p.type] = (typeCounts[p.type] || 0) + 1;
    });
    
    return {
      totalPatterns: this.patterns.length,
      totalAnomalies: this.anomalies.length,
      highlightCount: this.highlights.length,
      patternTypes: typeCounts
    };
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const summary = this.getSummary();
    
    let html = `
      <div class="pattern-header">
        <div class="pattern-stat">
          <span class="pattern-stat-value">${summary.totalPatterns}</span>
          <span class="pattern-stat-label">Patterns</span>
        </div>
        <div class="pattern-stat">
          <span class="pattern-stat-value">${summary.totalAnomalies}</span>
          <span class="pattern-stat-label">Anomalies</span>
        </div>
        <div class="pattern-stat">
          <span class="pattern-stat-value">${summary.highlightCount}</span>
          <span class="pattern-stat-label">Highlights</span>
        </div>
      </div>
      
      <div class="pattern-section">
        <div class="pattern-section-title">ðŸŽ¯ Highlights</div>
        <div class="pattern-list">
          ${this.highlights.map(h => `
            <div class="pattern-item highlight" onclick="goToFrame(${h.frame})">
              <span class="pattern-frame">F${h.frame}</span>
              <span class="pattern-score">Score: ${h.score.toFixed(1)}</span>
            </div>
          `).join('')}
        </div>
      </div>
      
      <div class="pattern-section">
        <div class="pattern-section-title">ðŸ“Š Detected Patterns</div>
        <div class="pattern-list">
          ${this.patterns.slice(0, 10).map(p => `
            <div class="pattern-item ${p.type}" onclick="goToFrame(${p.frame || p.startFrame})">
              <span class="pattern-type">${p.type.replace(/_/g, ' ')}</span>
              <span class="pattern-frame">F${p.frame || p.startFrame}</span>
              <span class="pattern-conf">${(p.confidence * 100).toFixed(0)}%</span>
            </div>
          `).join('')}
          ${this.patterns.length > 10 ? `<div class="pattern-more">+${this.patterns.length - 10} more</div>` : ''}
        </div>
      </div>
      
      ${this.anomalies.length > 0 ? `
      <div class="pattern-section">
        <div class="pattern-section-title">âš ï¸ Anomalies</div>
        <div class="pattern-list">
          ${this.anomalies.slice(0, 5).map(a => `
            <div class="pattern-item anomaly ${a.severity}" onclick="goToFrame(${a.frame})">
              <span class="pattern-type">${a.type.replace(/_/g, ' ')}</span>
              <span class="pattern-frame">F${a.frame}</span>
              <span class="pattern-severity">${a.severity}</span>
            </div>
          `).join('')}
        </div>
      </div>
      ` : ''}
    `;
    
    container.innerHTML = html;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 â€” SETTINGS MANAGER
// Persist and sync user preferences
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SettingsManager {
  constructor() {
    this.storageKey = 'virecai_settings';
    this.defaults = {
      theme: 'dark',
      showWHOverlay: true,
      showTheoryOverlay: false,
      autoSave: true,
      quality: 'high',
      fps: 10,
      audioEnabled: true,
      motionSensitivity: 0.3,
      perfMonitorVisible: false,
      lastUsedProfile: 'full',
      recentFiles: [],
      shortcuts: {}
    };
    
    this.settings = this.load();
    this.listeners = new Map();
  }
  
  load() {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        return { ...this.defaults, ...JSON.parse(stored) };
      }
    } catch (e) {
      console.warn('Settings load failed:', e);
    }
    return { ...this.defaults };
  }
  
  save() {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.settings));
      return true;
    } catch (e) {
      console.warn('Settings save failed:', e);
      return false;
    }
  }
  
  get(key) {
    return this.settings[key] ?? this.defaults[key];
  }
  
  set(key, value) {
    const oldValue = this.settings[key];
    this.settings[key] = value;
    this.save();
    
    // Notify listeners
    if (this.listeners.has(key)) {
      this.listeners.get(key).forEach(cb => cb(value, oldValue));
    }
    
    return this;
  }
  
  toggle(key) {
    return this.set(key, !this.get(key));
  }
  
  reset() {
    this.settings = { ...this.defaults };
    this.save();
    return this;
  }
  
  onChange(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(callback);
  }
  
  addRecentFile(filename, path) {
    const recent = this.get('recentFiles');
    const entry = { filename, path, timestamp: Date.now() };
    
    // Remove duplicates
    const filtered = recent.filter(r => r.path !== path);
    
    // Add to front, limit to 10
    filtered.unshift(entry);
    if (filtered.length > 10) filtered.pop();
    
    this.set('recentFiles', filtered);
  }
  
  getAll() {
    return { ...this.settings };
  }
  
  export() {
    return JSON.stringify(this.settings, null, 2);
  }
  
  import(json) {
    try {
      const imported = JSON.parse(json);
      this.settings = { ...this.defaults, ...imported };
      this.save();
      return true;
    } catch (e) {
      return false;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 â€” HELP OVERLAY
// Keyboard shortcuts and feature help
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HelpOverlay {
  constructor() {
    this.isOpen = false;
    this.sections = [
      {
        title: 'Recording',
        shortcuts: [
          { key: 'Space', action: 'Start/Stop recording' },
          { key: 'Escape', action: 'Close all panels' }
        ]
      },
      {
        title: 'Overlays',
        shortcuts: [
          { key: 'W', action: 'WH semantic overlay' },
          { key: 'T', action: 'Theory overlay' }
        ]
      },
      {
        title: 'Playback',
        shortcuts: [
          { key: 'P', action: 'Open playback panel' },
          { key: 'Space', action: 'Play/Pause (in playback)' },
          { key: 'â†/â†’', action: 'Previous/Next frame' },
          { key: 'Home/End', action: 'First/Last frame' }
        ]
      },
      {
        title: 'Analysis',
        shortcuts: [
          { key: 'A', action: 'Analytics panel' },
          { key: 'C', action: 'Compare frames' },
          { key: 'R', action: 'Reports panel' }
        ]
      },
      {
        title: 'Symbolic Intelligence',
        shortcuts: [
          { key: 'S', action: 'Symbol mesh network' },
          { key: 'D', action: 'Causal chains' },
          { key: 'N', action: 'Narrative generator' },
          { key: 'I', action: 'InceptaDive explorer' },
          { key: 'O', action: 'Symbol ontology' },
          { key: 'Q', action: 'Symbolic query' }
        ]
      },
      {
        title: 'Sensory',
        shortcuts: [
          { key: 'U', action: 'Audio waveform' },
          { key: 'J', action: 'Motion trajectory' }
        ]
      },
      {
        title: 'Export & Tools',
        shortcuts: [
          { key: 'E', action: 'Mullu export' },
          { key: 'B', action: 'Add bookmark' },
          { key: 'M', action: 'Auto-detect markers' },
          { key: 'Ctrl+K', action: 'Command palette' },
          { key: 'F1', action: 'This help' }
        ]
      }
    ];
  }
  
  open() {
    this.isOpen = true;
    this.render();
    document.getElementById('help-backdrop').classList.add('open');
    document.getElementById('help-panel').classList.add('open');
  }
  
  close() {
    this.isOpen = false;
    document.getElementById('help-backdrop').classList.remove('open');
    document.getElementById('help-panel').classList.remove('open');
  }
  
  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  
  render() {
    const container = document.getElementById('help-content');
    if (!container) return;
    
    let html = `
      <div class="help-grid">
        ${this.sections.map(section => `
          <div class="help-section">
            <div class="help-section-title">${section.title}</div>
            ${section.shortcuts.map(s => `
              <div class="help-shortcut">
                <kbd class="help-key">${s.key}</kbd>
                <span class="help-action">${s.action}</span>
              </div>
            `).join('')}
          </div>
        `).join('')}
      </div>
      
      <div class="help-footer">
        <div class="help-tip">ðŸ’¡ Tip: Type commands in the query input (/) or use Ctrl+K for command palette</div>
      </div>
    `;
    
    container.innerHTML = html;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 â€” THEME MANAGER
// Light/dark mode with CSS variables
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ThemeManager {
  constructor() {
    this.themes = {
      dark: {
        '--bg-primary': '#0a0a14',
        '--bg-secondary': '#12121e',
        '--bg-tertiary': '#1a1a2e',
        '--border': '#2a2a4a',
        '--text-primary': '#e8e8f0',
        '--text-secondary': '#a0a0b8',
        '--text-muted': '#6a6a8a',
        '--accent-cyan': '#22ddee',
        '--accent-purple': '#8855ff',
        '--header-bg': 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%)'
      },
      light: {
        '--bg-primary': '#f5f5f8',
        '--bg-secondary': '#ffffff',
        '--bg-tertiary': '#e8e8ec',
        '--border': '#d0d0d8',
        '--text-primary': '#1a1a2e',
        '--text-secondary': '#4a4a5a',
        '--text-muted': '#8a8a9a',
        '--accent-cyan': '#0099aa',
        '--accent-purple': '#6633cc',
        '--header-bg': 'linear-gradient(135deg, #e8e8f0 0%, #d0d0e0 100%)'
      },
      midnight: {
        '--bg-primary': '#000010',
        '--bg-secondary': '#080818',
        '--bg-tertiary': '#101028',
        '--border': '#202040',
        '--text-primary': '#d0d0e8',
        '--text-secondary': '#9090b0',
        '--text-muted': '#5050708',
        '--accent-cyan': '#00ccff',
        '--accent-purple': '#aa66ff',
        '--header-bg': 'linear-gradient(135deg, #000010 0%, #101028 100%)'
      }
    };
    
    this.current = 'dark';
  }
  
  apply(themeName) {
    const theme = this.themes[themeName];
    if (!theme) return false;
    
    const root = document.documentElement;
    Object.entries(theme).forEach(([prop, value]) => {
      root.style.setProperty(prop, value);
    });
    
    this.current = themeName;
    document.body.setAttribute('data-theme', themeName);
    
    // Update settings
    if (typeof settingsManager !== 'undefined') {
      settingsManager.set('theme', themeName);
    }
    
    return true;
  }
  
  toggle() {
    const names = Object.keys(this.themes);
    const currentIndex = names.indexOf(this.current);
    const nextIndex = (currentIndex + 1) % names.length;
    return this.apply(names[nextIndex]);
  }
  
  getCurrent() {
    return this.current;
  }
  
  getAvailable() {
    return Object.keys(this.themes);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 â€” SMART TIMELINE
// Enhanced timeline with scene previews and pattern markers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SmartTimeline {
  constructor(containerId) {
    this.containerId = containerId;
    this.scenes = [];
    this.patterns = [];
    this.highlights = [];
    this.currentFrame = 0;
    this.totalFrames = 0;
    this.hoveredScene = null;
  }
  
  update(container, patternData) {
    if (!container) return;
    
    this.totalFrames = container.frames.length;
    this.scenes = container.scenes || [];
    
    if (patternData) {
      this.patterns = patternData.patterns || [];
      this.highlights = patternData.highlights || [];
    }
  }
  
  setCurrentFrame(frame) {
    this.currentFrame = frame;
    this._updatePlayhead();
  }
  
  _updatePlayhead() {
    const playhead = document.getElementById('smart-timeline-playhead');
    if (playhead && this.totalFrames > 0) {
      const percent = (this.currentFrame / this.totalFrames) * 100;
      playhead.style.left = `${percent}%`;
    }
  }
  
  render() {
    const container = document.getElementById(this.containerId);
    if (!container) return;
    
    if (this.totalFrames === 0) {
      container.innerHTML = '<div class="smart-timeline-empty">No recording data</div>';
      return;
    }
    
    let html = `
      <div class="smart-timeline-track">
        <div class="smart-timeline-bg"></div>
        
        <!-- Scene segments -->
        <div class="smart-timeline-scenes">
          ${this.scenes.map((scene, i) => {
            const startPct = (scene.startFrame / this.totalFrames) * 100;
            const widthPct = ((scene.endFrame - scene.startFrame) / this.totalFrames) * 100;
            const typeClass = scene.dominantType || 'default';
            return `
              <div class="smart-timeline-scene ${typeClass}" 
                   style="left: ${startPct}%; width: ${widthPct}%"
                   data-scene="${i}"
                   onclick="goToFrame(${scene.startFrame})"
                   title="Scene ${i + 1}: ${scene.dominantType || 'unknown'}">
              </div>
            `;
          }).join('')}
        </div>
        
        <!-- Pattern markers -->
        <div class="smart-timeline-markers">
          ${this.patterns.slice(0, 20).map(p => {
            const frame = p.frame || p.startFrame;
            const pct = (frame / this.totalFrames) * 100;
            return `
              <div class="smart-timeline-marker ${p.type}" 
                   style="left: ${pct}%"
                   onclick="goToFrame(${frame})"
                   title="${p.type.replace(/_/g, ' ')}">
              </div>
            `;
          }).join('')}
        </div>
        
        <!-- Highlight diamonds -->
        <div class="smart-timeline-highlights">
          ${this.highlights.map(h => {
            const pct = (h.frame / this.totalFrames) * 100;
            return `
              <div class="smart-timeline-highlight" 
                   style="left: ${pct}%"
                   onclick="goToFrame(${h.frame})"
                   title="Highlight (score: ${h.score.toFixed(1)})">
                â—†
              </div>
            `;
          }).join('')}
        </div>
        
        <!-- Playhead -->
        <div class="smart-timeline-playhead" id="smart-timeline-playhead"></div>
      </div>
      
      <div class="smart-timeline-info">
        <span class="smart-timeline-frame">F${this.currentFrame}/${this.totalFrames}</span>
        <span class="smart-timeline-scenes-count">${this.scenes.length} scenes</span>
        <span class="smart-timeline-patterns-count">${this.patterns.length} patterns</span>
      </div>
    `;
    
    container.innerHTML = html;
    this._updatePlayhead();
    
    // Add click handler to track
    const track = container.querySelector('.smart-timeline-track');
    if (track) {
      track.addEventListener('click', (e) => {
        const rect = track.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percent = x / rect.width;
        const frame = Math.round(percent * this.totalFrames);
        goToFrame(Math.max(0, Math.min(this.totalFrames - 1, frame)));
      });
    }
  }
}

// Global v2.26 instances
const patternDetector = new PatternDetector();
const settingsManager = new SettingsManager();
const helpOverlay = new HelpOverlay();
const themeManager = new ThemeManager();
const smartTimeline = new SmartTimeline('smart-timeline-container');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.15 â€” ONBOARDING GUIDE
// First-time user tutorial with step-by-step guidance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OnboardingGuide {
  constructor() {
    this.storageKey = 'virecai_onboarding_complete';
    this.currentStep = 0;
    this.isActive = false;
    this.steps = [
      {
        id: 'welcome',
        title: 'Welcome to VIRECAI',
        content: 'VIRECAI records video as symbolic intelligence â€” not just pixels, but meaning.',
        target: null,
        position: 'center'
      },
      {
        id: 'camera',
        title: 'Camera Preview',
        content: 'This is your live camera feed. It\'s just a preview â€” not recording yet.',
        target: '#preview',
        position: 'right'
      },
      {
        id: 'record',
        title: 'Start Recording',
        content: 'Press SPACE or click the Record button to start capturing. The preview will turn into a recording.',
        target: '#quick-record-btn',
        position: 'bottom'
      },
      {
        id: 'stop',
        title: 'Stop & Playback',
        content: 'Press SPACE again to stop. Then press P to open playback and review your recording.',
        target: '#state-chip',
        position: 'bottom'
      },
      {
        id: 'query',
        title: 'Query Your Recording',
        content: 'Type questions like "show bright frames" or "what caused motion" to explore symbolically.',
        target: '#query-input',
        position: 'top'
      },
      {
        id: 'save',
        title: 'Save Your Work',
        content: 'Type "save" to persist locally, or press E to export as a .mullu file for the Mullu ecosystem.',
        target: null,
        position: 'center'
      },
      {
        id: 'complete',
        title: 'You\'re Ready!',
        content: 'Press F1 anytime for keyboard shortcuts. Explore the symbolic intelligence of your reality.',
        target: null,
        position: 'center'
      }
    ];
  }
  
  shouldShow() {
    try {
      return !localStorage.getItem(this.storageKey);
    } catch (e) {
      return false;
    }
  }
  
  markComplete() {
    try {
      localStorage.setItem(this.storageKey, 'true');
    } catch (e) {}
  }
  
  reset() {
    try {
      localStorage.removeItem(this.storageKey);
    } catch (e) {}
    this.currentStep = 0;
  }
  
  start() {
    this.isActive = true;
    this.currentStep = 0;
    this.render();
  }
  
  next() {
    this.currentStep++;
    if (this.currentStep >= this.steps.length) {
      this.complete();
    } else {
      this.render();
    }
  }
  
  prev() {
    if (this.currentStep > 0) {
      this.currentStep--;
      this.render();
    }
  }
  
  skip() {
    this.complete();
  }
  
  complete() {
    this.isActive = false;
    this.markComplete();
    this.hide();
  }
  
  render() {
    const step = this.steps[this.currentStep];
    const container = document.getElementById('onboarding-container');
    if (!container) return;
    
    // Clear previous highlights
    document.querySelectorAll('.onboarding-highlight').forEach(el => {
      el.classList.remove('onboarding-highlight');
    });
    
    // Highlight target element
    if (step.target) {
      const targetEl = document.querySelector(step.target);
      if (targetEl) {
        targetEl.classList.add('onboarding-highlight');
      }
    }
    
    const progress = ((this.currentStep + 1) / this.steps.length) * 100;
    
    container.innerHTML = `
      <div class="onboarding-backdrop"></div>
      <div class="onboarding-modal ${step.position}">
        <div class="onboarding-progress">
          <div class="onboarding-progress-bar" style="width: ${progress}%"></div>
        </div>
        <div class="onboarding-step">${this.currentStep + 1} / ${this.steps.length}</div>
        <h3 class="onboarding-title">${step.title}</h3>
        <p class="onboarding-content">${step.content}</p>
        <div class="onboarding-actions">
          ${this.currentStep > 0 ? '<button class="onboarding-btn secondary" onclick="onboarding.prev()">â† Back</button>' : ''}
          <button class="onboarding-btn secondary" onclick="onboarding.skip()">Skip Tour</button>
          <button class="onboarding-btn primary" onclick="onboarding.next()">
            ${this.currentStep === this.steps.length - 1 ? 'Get Started' : 'Next â†’'}
          </button>
        </div>
      </div>
    `;
    
    container.style.display = 'block';
  }
  
  hide() {
    const container = document.getElementById('onboarding-container');
    if (container) {
      container.style.display = 'none';
      container.innerHTML = '';
    }
    document.querySelectorAll('.onboarding-highlight').forEach(el => {
      el.classList.remove('onboarding-highlight');
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.15 â€” STATUS DASHBOARD
// Clear visualization of recording state and data availability
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class StatusDashboard {
  constructor() {
    this.state = 'idle'; // idle, recording, paused, stopped, playing
    this.frameCount = 0;
    this.duration = 0;
    this.hasUnsavedData = false;
    this.lastSaved = null;
  }
  
  update(state, frameCount = 0, duration = 0) {
    this.state = state;
    this.frameCount = frameCount;
    this.duration = duration;
    
    if (state === 'recording' || state === 'paused' || state === 'stopped') {
      this.hasUnsavedData = frameCount > 0;
    }
    
    this.render();
  }
  
  markSaved() {
    this.hasUnsavedData = false;
    this.lastSaved = new Date();
    this.render();
  }
  
  render() {
    const container = document.getElementById('status-dashboard');
    if (!container) return;
    
    const stateConfig = {
      idle: { icon: 'â¸ï¸', label: 'Ready', color: '#666', hint: 'Press SPACE to record' },
      recording: { icon: 'ðŸ”´', label: 'Recording', color: '#ff4444', hint: 'SPACE=pause, ESC=stop' },
      paused: { icon: 'â¸ï¸', label: 'Paused', color: '#ffaa44', hint: 'SPACE=resume, ESC=stop' },
      stopped: { icon: 'â¹ï¸', label: 'Stopped', color: '#22ddee', hint: 'P=playback, SPACE=new' },
      playing: { icon: 'â–¶ï¸', label: 'Playing', color: '#88cc44', hint: 'Space to pause' }
    };
    
    const config = stateConfig[this.state] || stateConfig.idle;
    
    const formatDuration = (ms) => {
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      return mins > 0 ? `${mins}m ${secs % 60}s` : `${secs}s`;
    };
    
    container.innerHTML = `
      <div class="status-state" style="--state-color: ${config.color}">
        <span class="status-icon">${config.icon}</span>
        <span class="status-label">${config.label}</span>
      </div>
      
      ${this.frameCount > 0 ? `
        <div class="status-metrics">
          <div class="status-metric">
            <span class="status-metric-value">${this.frameCount}</span>
            <span class="status-metric-label">frames</span>
          </div>
          <div class="status-metric">
            <span class="status-metric-value">${formatDuration(this.duration)}</span>
            <span class="status-metric-label">duration</span>
          </div>
        </div>
      ` : ''}
      
      <div class="status-hint">${config.hint}</div>
      
      ${this.hasUnsavedData ? `
        <div class="status-warning">
          <span class="status-warning-icon">âš ï¸</span>
          <span>Unsaved recording</span>
        </div>
      ` : ''}
    `;
  }
  
  getState() {
    return {
      state: this.state,
      frameCount: this.frameCount,
      duration: this.duration,
      hasUnsavedData: this.hasUnsavedData
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.15 â€” QUICK ACTIONS BAR
// Prominent floating controls for core actions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class QuickActionsBar {
  constructor() {
    this.visible = true;
  }
  
  render() {
    const container = document.getElementById('quick-actions-bar');
    if (!container) return;
    
    const state = statusDashboard?.state || 'idle';
    const hasData = (statusDashboard?.frameCount || 0) > 0;
    
    container.innerHTML = `
      <button class="quick-action-btn ${state === 'recording' ? 'recording' : 'record'}" 
              id="quick-record-btn"
              onclick="toggleRecording()"
              title="${state === 'recording' ? 'Stop Recording (Space)' : 'Start Recording (Space)'}">
        <span class="quick-action-icon">${state === 'recording' ? 'â¹ï¸' : 'âºï¸'}</span>
        <span class="quick-action-label">${state === 'recording' ? 'Stop' : 'Record'}</span>
      </button>
      
      <button class="quick-action-btn playback ${hasData ? '' : 'disabled'}" 
              onclick="${hasData ? 'openPlaybackPanel()' : ''}"
              title="Playback (P)">
        <span class="quick-action-icon">â–¶ï¸</span>
        <span class="quick-action-label">Play</span>
      </button>
      
      <button class="quick-action-btn analyze ${hasData ? '' : 'disabled'}" 
              onclick="${hasData ? 'openAnalyticsPanel()' : ''}"
              title="Analytics (A)">
        <span class="quick-action-icon">ðŸ“Š</span>
        <span class="quick-action-label">Analyze</span>
      </button>
      
      <button class="quick-action-btn export ${hasData ? '' : 'disabled'}" 
              onclick="${hasData ? 'openMulluPanel()' : ''}"
              title="Export (E)">
        <span class="quick-action-icon">ðŸ“¦</span>
        <span class="quick-action-label">Export</span>
      </button>
      
      <button class="quick-action-btn help" 
              onclick="openHelpPanel()"
              title="Help (F1)">
        <span class="quick-action-icon">â“</span>
      </button>
    `;
  }
  
  show() {
    this.visible = true;
    const container = document.getElementById('quick-actions-bar');
    if (container) container.style.display = 'flex';
  }
  
  hide() {
    this.visible = false;
    const container = document.getElementById('quick-actions-bar');
    if (container) container.style.display = 'none';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.15 â€” SESSION GUARD
// Warn before losing unsaved data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SessionGuard {
  constructor() {
    this.enabled = true;
    this._setupBeforeUnload();
  }
  
  _setupBeforeUnload() {
    window.addEventListener('beforeunload', (e) => {
      if (!this.enabled) return;
      
      const status = statusDashboard?.getState();
      if (status?.hasUnsavedData) {
        e.preventDefault();
        e.returnValue = 'You have unsaved recording data. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
  }
  
  disable() {
    this.enabled = false;
  }
  
  enable() {
    this.enabled = true;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.15 â€” NOTIFICATION TOAST
// Non-intrusive notifications for user feedback
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NotificationToast {
  constructor() {
    this.queue = [];
    this.isShowing = false;
    this.duration = 3000;
  }
  
  show(message, type = 'info') {
    this.queue.push({ message, type });
    if (!this.isShowing) {
      this._showNext();
    }
  }
  
  success(message) { this.show(message, 'success'); }
  error(message) { this.show(message, 'error'); }
  warning(message) { this.show(message, 'warning'); }
  info(message) { this.show(message, 'info'); }
  
  _showNext() {
    if (this.queue.length === 0) {
      this.isShowing = false;
      return;
    }
    
    this.isShowing = true;
    const { message, type } = this.queue.shift();
    
    const container = document.getElementById('toast-container');
    if (!container) {
      this.isShowing = false;
      return;
    }
    
    const icons = {
      success: 'âœ…',
      error: 'âŒ',
      warning: 'âš ï¸',
      info: 'â„¹ï¸'
    };
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.innerHTML = `
      <span class="toast-icon">${icons[type]}</span>
      <span class="toast-message">${message}</span>
    `;
    
    container.appendChild(toast);
    
    // Trigger animation
    requestAnimationFrame(() => {
      toast.classList.add('show');
    });
    
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => {
        toast.remove();
        this._showNext();
      }, 300);
    }, this.duration);
  }
}

// Global v2.26 instances
const onboarding = new OnboardingGuide();
const statusDashboard = new StatusDashboard();
const quickActions = new QuickActionsBar();
const sessionGuard = new SessionGuard();
const toast = new NotificationToast();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” DATA MANAGER
// Unified interface for save, load, export, import operations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DataManager {
  constructor() {
    this.dbName = 'virecai_data';
    this.dbVersion = 2;
    this.db = null;
    this.autoSaveInterval = null;
    this.autoSaveEnabled = false;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        
        if (!db.objectStoreNames.contains('recordings')) {
          const store = db.createObjectStore('recordings', { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('name', 'name', { unique: false });
        }
        
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
        
        if (!db.objectStoreNames.contains('drafts')) {
          db.createObjectStore('drafts', { keyPath: 'id' });
        }
      };
    });
  }
  
  async saveRecording(container, name = null) {
    if (!this.db) await this.init();
    if (!container || container.frames.length === 0) {
      throw new Error('No recording data to save');
    }
    
    const id = `rec_${Date.now()}`;
    const timestamp = Date.now();
    const recordingName = name || `Recording ${new Date().toLocaleString()}`;
    
    // Serialize container
    const data = {
      id,
      name: recordingName,
      timestamp,
      frameCount: container.frames.length,
      duration: container.getDuration?.() || 0,
      scenes: container.scenes?.length || 0,
      serialized: container.serialize ? container.serialize() : this._serializeContainer(container)
    };
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('recordings', 'readwrite');
      const store = tx.objectStore('recordings');
      const request = store.put(data);
      
      request.onsuccess = () => {
        statusDashboard?.markSaved?.();
        toast?.success?.(`Saved: ${recordingName}`);
        resolve(id);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  _serializeContainer(container) {
    return {
      frames: container.frames.map(f => ({
        id: f.id,
        timestamp: f.timestamp,
        layers: f.layers,
        causalInferences: f.causalInferences,
        mfidel: f.mfidel
      })),
      scenes: container.scenes,
      startTime: container.startTime,
      meta: container.meta
    };
  }
  
  async loadRecording(id) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('recordings', 'readonly');
      const store = tx.objectStore('recordings');
      const request = store.get(id);
      
      request.onsuccess = () => {
        if (request.result) {
          resolve(request.result);
        } else {
          reject(new Error('Recording not found'));
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async listRecordings() {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('recordings', 'readonly');
      const store = tx.objectStore('recordings');
      const index = store.index('timestamp');
      const request = index.openCursor(null, 'prev');
      
      const recordings = [];
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          const { id, name, timestamp, frameCount, duration, scenes } = cursor.value;
          recordings.push({ id, name, timestamp, frameCount, duration, scenes });
          cursor.continue();
        } else {
          resolve(recordings);
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async deleteRecording(id) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('recordings', 'readwrite');
      const store = tx.objectStore('recordings');
      const request = store.delete(id);
      
      request.onsuccess = () => {
        toast?.info?.('Recording deleted');
        resolve(true);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async saveDraft(container) {
    if (!this.db) await this.init();
    if (!container || container.frames.length === 0) return;
    
    const data = {
      id: 'current_draft',
      timestamp: Date.now(),
      serialized: this._serializeContainer(container)
    };
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('drafts', 'readwrite');
      const store = tx.objectStore('drafts');
      store.put(data).onsuccess = () => resolve(true);
    });
  }
  
  async loadDraft() {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('drafts', 'readonly');
      const store = tx.objectStore('drafts');
      const request = store.get('current_draft');
      
      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => resolve(null);
    });
  }
  
  async clearDraft() {
    if (!this.db) await this.init();
    
    return new Promise((resolve) => {
      const tx = this.db.transaction('drafts', 'readwrite');
      tx.objectStore('drafts').delete('current_draft').onsuccess = () => resolve(true);
    });
  }
  
  enableAutoSave(intervalMs = 30000) {
    if (this.autoSaveInterval) clearInterval(this.autoSaveInterval);
    
    this.autoSaveEnabled = true;
    this.autoSaveInterval = setInterval(async () => {
      const container = orch?.getContainer();
      if (container && container.frames.length > 0) {
        await this.saveDraft(container);
      }
    }, intervalMs);
  }
  
  disableAutoSave() {
    this.autoSaveEnabled = false;
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
  }
  
  async exportToFile(container, format = 'mullu') {
    if (!container || container.frames.length === 0) {
      toast?.error?.('No data to export');
      return;
    }
    
    let data, filename, mimeType;
    
    if (format === 'mullu') {
      data = mulluExporter.toJSON(container);
      filename = `virecai_${Date.now()}.mullu`;
      mimeType = 'application/json';
    } else if (format === 'json') {
      data = JSON.stringify(this._serializeContainer(container), null, 2);
      filename = `virecai_${Date.now()}.json`;
      mimeType = 'application/json';
    } else if (format === 'vrc') {
      data = container.serialize ? container.serialize() : JSON.stringify(this._serializeContainer(container));
      filename = `virecai_${Date.now()}.vrc`;
      mimeType = 'application/octet-stream';
    }
    
    const blob = new Blob([data], { type: mimeType });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    
    URL.revokeObjectURL(url);
    toast?.success?.(`Exported: ${filename}`);
  }
  
  async importFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          toast?.success?.('File imported successfully');
          resolve(data);
        } catch (err) {
          toast?.error?.('Invalid file format');
          reject(err);
        }
      };
      
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
    });
  }
  
  getStorageUsage() {
    if (navigator.storage && navigator.storage.estimate) {
      return navigator.storage.estimate();
    }
    return Promise.resolve({ usage: 0, quota: 0 });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” PWA MANAGER
// Progressive Web App features - install, offline, updates
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PWAManager {
  constructor() {
    this.deferredPrompt = null;
    this.isInstalled = false;
    this.swRegistration = null;
    this.isOnline = navigator.onLine;
    
    this._setupInstallPrompt();
    this._setupOnlineStatus();
  }
  
  _setupInstallPrompt() {
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      this.deferredPrompt = e;
      this._showInstallButton();
    });
    
    window.addEventListener('appinstalled', () => {
      this.isInstalled = true;
      this.deferredPrompt = null;
      toast?.success?.('VIRECAI installed successfully!');
    });
    
    // Check if already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      this.isInstalled = true;
    }
  }
  
  _setupOnlineStatus() {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this._updateOnlineIndicator();
      toast?.info?.('Back online');
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      this._updateOnlineIndicator();
      toast?.warning?.('Working offline');
    });
  }
  
  _showInstallButton() {
    const btn = document.getElementById('pwa-install-btn');
    if (btn) btn.style.display = 'flex';
  }
  
  _updateOnlineIndicator() {
    const indicator = document.getElementById('online-indicator');
    if (indicator) {
      indicator.className = `online-indicator ${this.isOnline ? 'online' : 'offline'}`;
      indicator.title = this.isOnline ? 'Online' : 'Offline';
    }
  }
  
  async promptInstall() {
    if (!this.deferredPrompt) {
      toast?.info?.('App already installed or not installable');
      return false;
    }
    
    this.deferredPrompt.prompt();
    const { outcome } = await this.deferredPrompt.userChoice;
    
    this.deferredPrompt = null;
    return outcome === 'accepted';
  }
  
  async registerServiceWorker() {
    if (!('serviceWorker' in navigator)) {
      console.log('Service Worker not supported');
      return null;
    }
    
    try {
      // Create inline service worker
      const swCode = `
        const CACHE_NAME = 'virecai-v2.26';
        const ASSETS = ['/'];
        
        self.addEventListener('install', e => {
          e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(ASSETS)));
        });
        
        self.addEventListener('fetch', e => {
          e.respondWith(
            caches.match(e.request).then(r => r || fetch(e.request))
          );
        });
      `;
      
      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);
      
      // Note: Blob URLs don't work for SW in most browsers, so we skip actual registration
      // In production, a real sw.js file would be served
      console.log('PWA: Service worker prepared (requires external file for full functionality)');
      return null;
    } catch (err) {
      console.warn('SW registration failed:', err);
      return null;
    }
  }
  
  canInstall() {
    return !!this.deferredPrompt;
  }
  
  getStatus() {
    return {
      isInstalled: this.isInstalled,
      canInstall: this.canInstall(),
      isOnline: this.isOnline
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” MOBILE ADAPTER
// Touch handling, responsive behavior, mobile-specific UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MobileAdapter {
  constructor() {
    this.isMobile = this._detectMobile();
    this.isTouch = 'ontouchstart' in window;
    this.orientation = this._getOrientation();
    
    this._setupOrientationListener();
    this._setupTouchHandlers();
    
    if (this.isMobile) {
      document.body.classList.add('mobile-device');
    }
  }
  
  _detectMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           window.innerWidth < 768;
  }
  
  _getOrientation() {
    return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
  }
  
  _setupOrientationListener() {
    window.addEventListener('resize', () => {
      const newOrientation = this._getOrientation();
      if (newOrientation !== this.orientation) {
        this.orientation = newOrientation;
        document.body.setAttribute('data-orientation', this.orientation);
        this._adjustLayout();
      }
    });
    
    document.body.setAttribute('data-orientation', this.orientation);
  }
  
  _setupTouchHandlers() {
    if (!this.isTouch) return;
    
    // Prevent double-tap zoom on buttons
    document.querySelectorAll('button, .quick-action-btn').forEach(el => {
      el.addEventListener('touchend', (e) => {
        e.preventDefault();
        el.click();
      });
    });
    
    // Swipe gestures for panels
    let touchStartX = 0;
    let touchStartY = 0;
    
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });
    
    document.addEventListener('touchend', (e) => {
      if (!e.changedTouches[0]) return;
      
      const deltaX = e.changedTouches[0].clientX - touchStartX;
      const deltaY = e.changedTouches[0].clientY - touchStartY;
      
      // Horizontal swipe (close panel)
      if (Math.abs(deltaX) > 100 && Math.abs(deltaY) < 50) {
        if (deltaX > 0) {
          // Swipe right - close left panel
          const panel = document.querySelector('.panel.open');
          if (panel) closePanel();
        }
      }
    }, { passive: true });
  }
  
  _adjustLayout() {
    // Adjust quick actions bar for orientation
    const quickBar = document.getElementById('quick-actions-bar');
    if (quickBar) {
      if (this.orientation === 'landscape' && this.isMobile) {
        quickBar.classList.add('landscape');
      } else {
        quickBar.classList.remove('landscape');
      }
    }
  }
  
  vibrate(pattern = 50) {
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }
  
  getViewportSize() {
    return {
      width: window.innerWidth,
      height: window.innerHeight,
      isMobile: this.isMobile,
      orientation: this.orientation
    };
  }
  
  showMobileWarning() {
    if (this.isMobile && this.orientation === 'portrait') {
      toast?.info?.('Rotate to landscape for better experience');
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” ERROR BOUNDARY
// Graceful error handling and recovery
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ErrorBoundary {
  constructor() {
    this.errors = [];
    this.maxErrors = 10;
    
    this._setupGlobalHandler();
  }
  
  _setupGlobalHandler() {
    window.onerror = (message, source, lineno, colno, error) => {
      this.capture({
        type: 'error',
        message,
        source,
        lineno,
        colno,
        stack: error?.stack
      });
      return false; // Don't suppress the error
    };
    
    window.onunhandledrejection = (event) => {
      this.capture({
        type: 'unhandledrejection',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack
      });
    };
  }
  
  capture(error) {
    const entry = {
      ...error,
      timestamp: Date.now()
    };
    
    this.errors.push(entry);
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    console.error('[ErrorBoundary]', entry);
    
    // Show user-friendly error for critical issues
    if (error.message?.includes('camera') || error.message?.includes('getUserMedia')) {
      toast?.error?.('Camera access issue. Check permissions.');
    } else if (error.message?.includes('IndexedDB') || error.message?.includes('storage')) {
      toast?.error?.('Storage error. Data may not be saved.');
    }
  }
  
  getRecentErrors() {
    return [...this.errors];
  }
  
  clearErrors() {
    this.errors = [];
  }
  
  async tryRecover() {
    // Attempt basic recovery actions
    try {
      // Reinitialize data manager
      await dataManager?.init?.();
      
      // Clear any stuck state
      if (orch?.getState?.() === 'error') {
        orch.reset?.();
      }
      
      toast?.success?.('Recovery attempted');
      return true;
    } catch (err) {
      toast?.error?.('Recovery failed. Refresh may be needed.');
      return false;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” DATA PANEL UI
// Visual interface for managing recordings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DataPanelUI {
  constructor() {
    this.recordings = [];
  }
  
  async refresh() {
    try {
      this.recordings = await dataManager.listRecordings();
    } catch (e) {
      this.recordings = [];
    }
  }
  
  async render(containerId) {
    await this.refresh();
    
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const formatDate = (ts) => new Date(ts).toLocaleString();
    const formatDuration = (ms) => {
      const secs = Math.floor(ms / 1000);
      return secs < 60 ? `${secs}s` : `${Math.floor(secs/60)}m ${secs%60}s`;
    };
    
    let html = `
      <div class="data-panel-header">
        <span class="data-panel-title">ðŸ“ Saved Recordings</span>
        <span class="data-panel-count">${this.recordings.length}</span>
      </div>
      
      ${this.recordings.length === 0 ? `
        <div class="data-panel-empty">
          <span>No saved recordings</span>
          <span class="data-panel-hint">Use "save" command or Ctrl+S</span>
        </div>
      ` : `
        <div class="data-panel-list">
          ${this.recordings.map(r => `
            <div class="data-panel-item" data-id="${r.id}">
              <div class="data-item-info">
                <span class="data-item-name">${r.name}</span>
                <span class="data-item-meta">${r.frameCount} frames â€¢ ${formatDuration(r.duration)}</span>
                <span class="data-item-date">${formatDate(r.timestamp)}</span>
              </div>
              <div class="data-item-actions">
                <button class="data-btn load" onclick="loadRecordingById('${r.id}')" title="Load">â–¶ï¸</button>
                <button class="data-btn export" onclick="exportRecordingById('${r.id}')" title="Export">ðŸ“¦</button>
                <button class="data-btn delete" onclick="deleteRecordingById('${r.id}')" title="Delete">ðŸ—‘ï¸</button>
              </div>
            </div>
          `).join('')}
        </div>
      `}
      
      <div class="data-panel-footer">
        <button class="data-action-btn" onclick="saveCurrentRecording()">
          ðŸ’¾ Save Current
        </button>
        <button class="data-action-btn" onclick="importRecordingFile()">
          ðŸ“¥ Import File
        </button>
      </div>
    `;
    
    container.innerHTML = html;
  }
}

// Global v2.26 instances
const dataManager = new DataManager();
const pwaManager = new PWAManager();
const mobileAdapter = new MobileAdapter();
const errorBoundary = new ErrorBoundary();
const dataPanelUI = new DataPanelUI();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” CAMERA MANAGER
// Advanced camera controls: resolution, FPS, facing mode, zoom
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CameraManager {
  constructor() {
    this.stream = null;
    this.videoTrack = null;
    this.capabilities = null;
    this.settings = {
      resolution: 'hd',    // sd, hd, fhd, 4k
      fps: 30,
      facingMode: 'user',  // user, environment
      zoom: 1,
      torch: false
    };
    this.resolutions = {
      sd: { width: 640, height: 480 },
      hd: { width: 1280, height: 720 },
      fhd: { width: 1920, height: 1080 },
      '4k': { width: 3840, height: 2160 }
    };
  }
  
  async init(videoElement) {
    this.videoElement = videoElement;
    await this.startCamera();
    return this.getCapabilities();
  }
  
  async startCamera() {
    try {
      const res = this.resolutions[this.settings.resolution] || this.resolutions.hd;
      
      const constraints = {
        video: {
          width: { ideal: res.width },
          height: { ideal: res.height },
          frameRate: { ideal: this.settings.fps },
          facingMode: this.settings.facingMode
        },
        audio: true
      };
      
      // Stop existing stream
      if (this.stream) {
        this.stream.getTracks().forEach(t => t.stop());
      }
      
      this.stream = await navigator.mediaDevices.getUserMedia(constraints);
      this.videoTrack = this.stream.getVideoTracks()[0];
      
      if (this.videoElement) {
        this.videoElement.srcObject = this.stream;
      }
      
      // Get capabilities after starting
      this.capabilities = this.videoTrack.getCapabilities?.() || {};
      
      toast?.success?.(`Camera: ${res.width}x${res.height} @ ${this.settings.fps}fps`);
      return this.stream;
    } catch (err) {
      toast?.error?.('Camera error: ' + err.message);
      throw err;
    }
  }
  
  getCapabilities() {
    return {
      hasZoom: !!this.capabilities?.zoom,
      hasTorch: !!this.capabilities?.torch,
      hasFocus: !!this.capabilities?.focusMode,
      hasExposure: !!this.capabilities?.exposureMode,
      zoomRange: this.capabilities?.zoom || { min: 1, max: 1 },
      facingModes: this.capabilities?.facingMode || ['user']
    };
  }
  
  async setResolution(res) {
    if (!this.resolutions[res]) return false;
    this.settings.resolution = res;
    await this.startCamera();
    return true;
  }
  
  async setFPS(fps) {
    this.settings.fps = fps;
    await this.startCamera();
    return true;
  }
  
  async toggleFacingMode() {
    this.settings.facingMode = this.settings.facingMode === 'user' ? 'environment' : 'user';
    await this.startCamera();
    return this.settings.facingMode;
  }
  
  async setZoom(level) {
    if (!this.videoTrack || !this.capabilities?.zoom) return false;
    
    const { min, max } = this.capabilities.zoom;
    const clamped = Math.max(min, Math.min(max, level));
    
    await this.videoTrack.applyConstraints({
      advanced: [{ zoom: clamped }]
    });
    
    this.settings.zoom = clamped;
    return true;
  }
  
  async toggleTorch() {
    if (!this.videoTrack || !this.capabilities?.torch) return false;
    
    this.settings.torch = !this.settings.torch;
    await this.videoTrack.applyConstraints({
      advanced: [{ torch: this.settings.torch }]
    });
    
    return this.settings.torch;
  }
  
  getSettings() {
    return { ...this.settings };
  }
  
  getActualSettings() {
    if (!this.videoTrack) return null;
    return this.videoTrack.getSettings();
  }
  
  stop() {
    if (this.stream) {
      this.stream.getTracks().forEach(t => t.stop());
      this.stream = null;
      this.videoTrack = null;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” ACCESSIBILITY MANAGER
// ARIA labels, screen reader support, focus management, announcements
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AccessibilityManager {
  constructor() {
    this.announcer = null;
    this.focusTrap = null;
    this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    this._createAnnouncer();
    this._setupMotionPreference();
  }
  
  _createAnnouncer() {
    this.announcer = document.createElement('div');
    this.announcer.id = 'a11y-announcer';
    this.announcer.setAttribute('aria-live', 'polite');
    this.announcer.setAttribute('aria-atomic', 'true');
    this.announcer.className = 'sr-only';
    document.body.appendChild(this.announcer);
  }
  
  _setupMotionPreference() {
    window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
      this.prefersReducedMotion = e.matches;
      document.body.classList.toggle('reduce-motion', e.matches);
    });
    
    if (this.prefersReducedMotion) {
      document.body.classList.add('reduce-motion');
    }
  }
  
  announce(message, priority = 'polite') {
    if (!this.announcer) return;
    
    this.announcer.setAttribute('aria-live', priority);
    this.announcer.textContent = '';
    
    // Force announcement by clearing then setting
    requestAnimationFrame(() => {
      this.announcer.textContent = message;
    });
  }
  
  announceAssertive(message) {
    this.announce(message, 'assertive');
  }
  
  trapFocus(container) {
    const focusable = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusable.length === 0) return;
    
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    
    this.focusTrap = (e) => {
      if (e.key !== 'Tab') return;
      
      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };
    
    container.addEventListener('keydown', this.focusTrap);
    first.focus();
    
    return () => {
      container.removeEventListener('keydown', this.focusTrap);
      this.focusTrap = null;
    };
  }
  
  labelElement(element, label, description = null) {
    element.setAttribute('aria-label', label);
    if (description) {
      const descId = `desc-${Date.now()}`;
      const descEl = document.createElement('span');
      descEl.id = descId;
      descEl.className = 'sr-only';
      descEl.textContent = description;
      element.parentNode.insertBefore(descEl, element.nextSibling);
      element.setAttribute('aria-describedby', descId);
    }
  }
  
  addSkipLink(targetId, text = 'Skip to main content') {
    const link = document.createElement('a');
    link.href = `#${targetId}`;
    link.className = 'skip-link';
    link.textContent = text;
    document.body.insertBefore(link, document.body.firstChild);
  }
  
  setLandmark(element, role, label = null) {
    element.setAttribute('role', role);
    if (label) {
      element.setAttribute('aria-label', label);
    }
  }
  
  initializePageA11y() {
    // Add skip link
    this.addSkipLink('main-content', 'Skip to recording');
    
    // Mark main regions
    const header = document.querySelector('.header');
    if (header) this.setLandmark(header, 'banner');
    
    const main = document.querySelector('.main');
    if (main) {
      main.id = 'main-content';
      this.setLandmark(main, 'main', 'Video recording area');
    }
    
    // Label interactive elements
    const recordBtn = document.getElementById('quick-record-btn');
    if (recordBtn) this.labelElement(recordBtn, 'Record video', 'Press Space to start or stop recording');
    
    const queryInput = document.getElementById('query-input');
    if (queryInput) this.labelElement(queryInput, 'Query input', 'Type commands to control VIRECAI');
    
    this.announce('VIRECAI loaded. Press Space to start recording.');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” PERFORMANCE OPTIMIZER
// Frame throttling, memory management, lazy loading, metrics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PerformanceOptimizer {
  constructor() {
    this.metrics = {
      fps: 0,
      memory: 0,
      frameDrops: 0,
      lastFrameTime: 0
    };
    this.frameCount = 0;
    this.lastSecond = performance.now();
    this.targetFPS = 30;
    this.throttleLevel = 0; // 0=none, 1=light, 2=heavy
    this.observers = new Map();
  }
  
  startMonitoring() {
    this._monitorLoop();
    this._setupMemoryMonitoring();
  }
  
  _monitorLoop() {
    const now = performance.now();
    this.frameCount++;
    
    if (now - this.lastSecond >= 1000) {
      this.metrics.fps = this.frameCount;
      this.frameCount = 0;
      this.lastSecond = now;
      
      // Auto-throttle if FPS drops
      if (this.metrics.fps < this.targetFPS * 0.7) {
        this.throttleLevel = Math.min(2, this.throttleLevel + 1);
        this._applyThrottle();
      } else if (this.metrics.fps > this.targetFPS * 0.9 && this.throttleLevel > 0) {
        this.throttleLevel = Math.max(0, this.throttleLevel - 1);
        this._applyThrottle();
      }
    }
    
    this.metrics.lastFrameTime = now;
    requestAnimationFrame(() => this._monitorLoop());
  }
  
  _setupMemoryMonitoring() {
    if (performance.memory) {
      setInterval(() => {
        this.metrics.memory = performance.memory.usedJSHeapSize / 1048576; // MB
        
        // Warn if memory is high
        if (this.metrics.memory > 500) {
          toast?.warning?.('High memory usage. Consider saving and refreshing.');
        }
      }, 5000);
    }
  }
  
  _applyThrottle() {
    document.body.setAttribute('data-throttle', this.throttleLevel);
    
    if (this.throttleLevel === 1) {
      // Light: reduce animation complexity
      document.body.classList.add('reduce-animations');
    } else if (this.throttleLevel === 2) {
      // Heavy: disable non-essential updates
      document.body.classList.add('reduce-animations', 'minimal-updates');
    } else {
      document.body.classList.remove('reduce-animations', 'minimal-updates');
    }
  }
  
  lazyLoad(element, callback) {
    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            callback(element);
            observer.unobserve(element);
          }
        });
      }, { rootMargin: '100px' });
      
      observer.observe(element);
      this.observers.set(element, observer);
    } else {
      // Fallback: load immediately
      callback(element);
    }
  }
  
  deferWork(callback, priority = 'low') {
    if ('requestIdleCallback' in window && priority === 'low') {
      requestIdleCallback(callback, { timeout: 2000 });
    } else {
      setTimeout(callback, priority === 'high' ? 0 : 100);
    }
  }
  
  throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  
  debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      throttleLevel: this.throttleLevel,
      memorySupported: !!performance.memory
    };
  }
  
  forceGC() {
    // Hint to GC by clearing references
    if (window.gc) {
      window.gc();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.27 â€” ENHANCED UTILITIES
// Rate limiting, error boundaries, state validation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RateLimiter {
  constructor() {
    this.limits = new Map();
  }
  
  // Create a rate-limited function
  limit(key, fn, interval = 100) {
    return (...args) => {
      const now = performance.now();
      const lastCall = this.limits.get(key) || 0;
      
      if (now - lastCall >= interval) {
        this.limits.set(key, now);
        return fn(...args);
      }
    };
  }
  
  // Check if action is allowed
  canExecute(key, interval = 100) {
    const now = performance.now();
    const lastCall = this.limits.get(key) || 0;
    return now - lastCall >= interval;
  }
  
  // Mark action as executed
  markExecuted(key) {
    this.limits.set(key, performance.now());
  }
  
  // Reset a specific limit
  reset(key) {
    this.limits.delete(key);
  }
  
  // Reset all limits
  resetAll() {
    this.limits.clear();
  }
}

class EnhancedErrorBoundary {
  constructor() {
    this.errors = [];
    this.maxErrors = 50;
    this.errorHandlers = new Map();
    this._setupGlobalHandler();
  }
  
  _setupGlobalHandler() {
    window.addEventListener('error', (event) => {
      this.capture(event.error || event.message, 'uncaught');
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.capture(event.reason, 'promise');
    });
  }
  
  capture(error, context = 'unknown') {
    const entry = {
      id: U.uid(),
      message: error?.message || String(error),
      stack: error?.stack,
      context,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    this.errors.push(entry);
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    // Call registered handler for this context
    const handler = this.errorHandlers.get(context);
    if (handler) {
      try {
        handler(entry);
      } catch (e) {
        console.error('Error handler failed:', e);
      }
    }
    
    // Log to console
    console.error(`[ErrorBoundary:${context}]`, error);
    
    return entry.id;
  }
  
  onError(context, handler) {
    this.errorHandlers.set(context, handler);
  }
  
  getErrors(context = null) {
    if (context) {
      return this.errors.filter(e => e.context === context);
    }
    return [...this.errors];
  }
  
  getLastError() {
    return this.errors[this.errors.length - 1];
  }
  
  clear() {
    this.errors = [];
  }
  
  // Wrap a function with error handling
  wrap(fn, context = 'wrapped') {
    return (...args) => {
      try {
        const result = fn(...args);
        if (result instanceof Promise) {
          return result.catch(err => {
            this.capture(err, context);
            throw err;
          });
        }
        return result;
      } catch (err) {
        this.capture(err, context);
        throw err;
      }
    };
  }
  
  // Safe execute - catches errors without throwing
  safeExecute(fn, context = 'safe', fallback = null) {
    try {
      const result = fn();
      if (result instanceof Promise) {
        return result.catch(err => {
          this.capture(err, context);
          return fallback;
        });
      }
      return result;
    } catch (err) {
      this.capture(err, context);
      return fallback;
    }
  }
}

class EnhancedStateValidator {
  constructor() {
    this.validTransitions = {
      'idle': ['initializing'],
      'initializing': ['ready', 'error'],
      'ready': ['recording', 'error'],
      'recording': ['paused', 'stopped', 'ready', 'error'],
      'paused': ['recording', 'stopped', 'ready'],
      'stopped': ['idle', 'recording', 'ready'],
      'error': ['idle', 'ready']
    };
    this.history = [];
    this.maxHistory = 100;
  }
  
  canTransition(from, to) {
    const allowed = this.validTransitions[from];
    return allowed && allowed.includes(to);
  }
  
  recordTransition(from, to, context = {}) {
    this.history.push({
      from,
      to,
      timestamp: performance.now(),
      valid: this.canTransition(from, to),
      ...context
    });
    
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  }
  
  getHistory(limit = 20) {
    return this.history.slice(-limit);
  }
  
  getInvalidTransitions() {
    return this.history.filter(t => !t.valid);
  }
  
  getStats() {
    const total = this.history.length;
    const invalid = this.getInvalidTransitions().length;
    return {
      total,
      valid: total - invalid,
      invalid,
      invalidRate: total > 0 ? (invalid / total * 100).toFixed(1) + '%' : '0%'
    };
  }
}

// Global v2.27 utility instances
const rateLimiter = new RateLimiter();
const enhancedErrorBoundary = new EnhancedErrorBoundary();
const enhancedStateValidator = new EnhancedStateValidator();

// Register error handlers
enhancedErrorBoundary.onError('recording', (err) => {
  toast?.error?.('Recording error: ' + err.message);
  notificationCenter?.error?.('Recording encountered an error');
});

enhancedErrorBoundary.onError('pipeline', (err) => {
  console.warn('[Pipeline Error]', err);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.27 â€” KEYBOARD SHORTCUTS OVERLAY
// Visual keyboard shortcuts reference
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class KeyboardShortcutsOverlay {
  constructor() {
    this.isVisible = false;
    this.shortcuts = [
      { category: 'Recording', shortcuts: [
        { keys: 'Space', action: 'Start/Pause recording' },
        { keys: 'Esc', action: 'Stop recording' },
        { keys: 'M', action: 'Add marker' }
      ]},
      { category: 'Navigation', shortcuts: [
        { keys: 'P', action: 'Playback panel' },
        { keys: 'A', action: 'Analytics panel' },
        { keys: 'E', action: 'Export panel' },
        { keys: 'S', action: 'Settings' }
      ]},
      { category: 'Tools', shortcuts: [
        { keys: 'Ctrl+K', action: 'Search' },
        { keys: 'Ctrl+S', action: 'Save' },
        { keys: 'Ctrl+Z', action: 'Undo' },
        { keys: 'Ctrl+Y', action: 'Redo' }
      ]},
      { category: 'View', shortcuts: [
        { keys: 'W', action: 'Toggle WH overlay' },
        { keys: 'F', action: 'Flip camera' },
        { keys: 'F1 / ?', action: 'Help' }
      ]}
    ];
  }
  
  render() {
    let container = document.getElementById('shortcuts-overlay');
    if (!container) {
      container = document.createElement('div');
      container.id = 'shortcuts-overlay';
      container.className = 'shortcuts-overlay';
      document.body.appendChild(container);
    }
    
    container.innerHTML = `
      <div class="shortcuts-backdrop" onclick="keyboardShortcuts.hide()"></div>
      <div class="shortcuts-modal">
        <div class="shortcuts-header">
          <h3>âŒ¨ï¸ Keyboard Shortcuts</h3>
          <button class="shortcuts-close" onclick="keyboardShortcuts.hide()">âœ•</button>
        </div>
        <div class="shortcuts-content">
          ${this.shortcuts.map(cat => `
            <div class="shortcuts-category">
              <h4>${cat.category}</h4>
              <div class="shortcuts-list">
                ${cat.shortcuts.map(s => `
                  <div class="shortcut-item">
                    <span class="shortcut-keys">${s.keys.split('+').map(k => `<kbd class="kbd">${k}</kbd>`).join(' + ')}</span>
                    <span class="shortcut-action">${s.action}</span>
                  </div>
                `).join('')}
              </div>
            </div>
          `).join('')}
        </div>
        <div class="shortcuts-footer">
          Press <kbd class="kbd">?</kbd> or <kbd class="kbd">F1</kbd> to toggle this overlay
        </div>
      </div>
    `;
    
    container.style.display = this.isVisible ? 'flex' : 'none';
  }
  
  show() {
    this.isVisible = true;
    this.render();
  }
  
  hide() {
    this.isVisible = false;
    const container = document.getElementById('shortcuts-overlay');
    if (container) container.style.display = 'none';
  }
  
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
}

const keyboardShortcuts = new KeyboardShortcutsOverlay();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” CAMERA CONTROLS UI
// Visual interface for camera settings
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CameraControlsUI {
  constructor(cameraManager) {
    this.camera = cameraManager;
  }
  
  render(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const settings = this.camera.getSettings();
    const caps = this.camera.getCapabilities();
    
    container.innerHTML = `
      <div class="camera-controls">
        <div class="camera-control-section">
          <label class="camera-label">Resolution</label>
          <div class="camera-buttons">
            ${['sd', 'hd', 'fhd', '4k'].map(res => `
              <button class="camera-btn ${settings.resolution === res ? 'active' : ''}" 
                      onclick="setCameraResolution('${res}')"
                      aria-pressed="${settings.resolution === res}">
                ${res.toUpperCase()}
              </button>
            `).join('')}
          </div>
        </div>
        
        <div class="camera-control-section">
          <label class="camera-label">Frame Rate</label>
          <div class="camera-buttons">
            ${[15, 24, 30, 60].map(fps => `
              <button class="camera-btn ${settings.fps === fps ? 'active' : ''}" 
                      onclick="setCameraFPS(${fps})"
                      aria-pressed="${settings.fps === fps}">
                ${fps}fps
              </button>
            `).join('')}
          </div>
        </div>
        
        <div class="camera-control-section">
          <label class="camera-label">Camera</label>
          <button class="camera-btn wide" onclick="toggleCameraFacing()">
            ${settings.facingMode === 'user' ? 'ðŸ¤³ Front' : 'ðŸ“· Back'}
          </button>
        </div>
        
        ${caps.hasZoom ? `
          <div class="camera-control-section">
            <label class="camera-label">Zoom: ${settings.zoom.toFixed(1)}x</label>
            <input type="range" class="camera-slider" 
                   min="${caps.zoomRange.min}" max="${caps.zoomRange.max}" 
                   step="0.1" value="${settings.zoom}"
                   onchange="setCameraZoom(this.value)"
                   aria-label="Zoom level">
          </div>
        ` : ''}
        
        ${caps.hasTorch ? `
          <div class="camera-control-section">
            <button class="camera-btn wide ${settings.torch ? 'active' : ''}" onclick="toggleCameraTorch()">
              ${settings.torch ? 'ðŸ”¦ Torch On' : 'ðŸ”¦ Torch Off'}
            </button>
          </div>
        ` : ''}
        
        <div class="camera-info">
          <span class="camera-info-item">Actual: ${this._getActualResolution()}</span>
        </div>
      </div>
    `;
  }
  
  _getActualResolution() {
    const actual = this.camera.getActualSettings();
    if (!actual) return 'Unknown';
    return `${actual.width}x${actual.height}`;
  }
}

// Global v2.26 instances
const cameraManager = new CameraManager();
const a11y = new AccessibilityManager();
const perfOptimizer = new PerformanceOptimizer();
const cameraControlsUI = new CameraControlsUI(cameraManager);

// Global sensor instances
const sensorMonitor = new SensorMonitor();
const sensorController = new SensorController();

// FrameSynchronizer
class FrameSynchronizer {
  constructor(coordinator) { this.coordinator = coordinator; this.syncWindow = 50; this.maxAge = 200; this.qualityHistory = []; }
  collectSynchronized(timestamp) {
    const synced = {};
    this.coordinator.sensors.forEach((sensor, name) => {
      if (!sensor.enabled) return;
      const reading = this.coordinator.get(name);
      const readingTime = this.coordinator.getTime(name);
      const age = timestamp - readingTime;
      if (reading && age < this.maxAge) {
        synced[name] = { data: reading, age, synced: age <= this.syncWindow, interpolated: false, confidence: this.coordinator.health.get(name)?.quality || 1.0, uncertainty: this.coordinator.getUncertainty(name) };
      }
    });
    return synced;
  }
  getSyncQuality(readings) {
    const entries = Object.entries(readings);
    if (entries.length === 0) return { quality: 0, syncedCount: 0, totalCount: 0 };
    const ages = entries.map(([_, r]) => r.age);
    const syncedCount = entries.filter(([_, r]) => r.synced).length;
    const avgAge = U.mean(ages);
    const quality = U.clamp(1 - (avgAge / this.maxAge), 0, 1) * (syncedCount / entries.length);
    this.qualityHistory.push(quality);
    if (this.qualityHistory.length > 30) this.qualityHistory.shift();
    return { quality, avgAge, syncedCount, totalCount: entries.length };
  }
  getAverageQuality() { return this.qualityHistory.length > 0 ? U.mean(this.qualityHistory) : 0; }
}

// BufferManager
class BufferManager {
  constructor(maxSize = 30) { this.maxSize = maxSize; this.buffer = []; this.processedCount = 0; this.droppedCount = 0; }
  add(item, priority = 'normal') {
    const pv = { critical: 3, high: 2, normal: 1, low: 0 }[priority] || 1;
    if (this.buffer.length >= this.maxSize) { this.buffer.shift(); this.droppedCount++; }
    this.buffer.push({ item, priority: pv });
    return true;
  }
  process(callback) {
    const toProcess = [...this.buffer];
    this.buffer = [];
    for (const entry of toProcess) { 
      try { 
        callback(entry.item); 
        this.processedCount++; 
      } catch (e) { 
        console.error('BufferManager process error:', e);
        this.droppedCount++;
      } 
    }
    return toProcess.length;
  }
  getStatus() { return { current: this.buffer.length, max: this.maxSize, fill: this.buffer.length / this.maxSize, processed: this.processedCount, dropped: this.droppedCount }; }
  clear() { this.buffer = []; }
}

// AnomalyDetector
class AnomalyDetector {
  constructor() {
    this.anomalies = [];
    this.thresholds = { motionSpike: { value: 0.7, severity: 'warning' }, luminanceJump: { value: 0.5, severity: 'info' }, timeGap: { value: 500, severity: 'warning' }, highUncertainty: { value: 0.3, severity: 'info' } };
  }
  check(frame, prevFrame) {
    const detected = [];
    const visual = frame.getLayer('visual');
    const prevVisual = prevFrame?.getLayer('visual');
    if (visual && prevVisual) {
      if (visual.motionDelta > this.thresholds.motionSpike.value) detected.push(this._create('motionSpike', visual.motionDelta, frame.index));
      if (Math.abs(visual.stats.luminance - prevVisual.stats.luminance) > this.thresholds.luminanceJump.value) detected.push(this._create('luminanceJump', Math.abs(visual.stats.luminance - prevVisual.stats.luminance), frame.index));
    }
    if (prevFrame && frame.timestamp - prevFrame.timestamp > this.thresholds.timeGap.value) detected.push(this._create('timeGap', frame.timestamp - prevFrame.timestamp, frame.index));
    if (frame.getFrameUncertainty() > this.thresholds.highUncertainty.value) detected.push(this._create('highUncertainty', frame.getFrameUncertainty(), frame.index));
    this.anomalies.push(...detected);
    if (this.anomalies.length > 300) this.anomalies = this.anomalies.slice(-150);
    detected.forEach(a => bus.emit('anomaly:detected', a));
    return detected;
  }
  _create(type, value, frameIndex) { return { id: U.uid(), type, value, frame: frameIndex, severity: this.thresholds[type]?.severity || 'info', timestamp: U.timestamp() }; }
  getSummary() {
    const byType = {}, bySeverity = { critical: 0, warning: 0, info: 0 };
    this.anomalies.forEach(a => { byType[a.type] = (byType[a.type] || 0) + 1; bySeverity[a.severity] = (bySeverity[a.severity] || 0) + 1; });
    return { total: this.anomalies.length, byType, bySeverity, recent: this.anomalies.slice(-10) };
  }
  clear() { this.anomalies = []; }
}

// Validator
class Validator {
  constructor(container) { this.container = container; }
  validate() {
    const frames = this.container.frames;
    let intScore = 40, contScore = 30, qualScore = 30;
    
    // Timestamps
    for (let i = 1; i < frames.length; i++) if (frames[i].timestamp <= frames[i-1].timestamp) intScore -= 5;
    // Signatures
    for (let i = 1; i < frames.length; i++) if (frames[i].prevHash !== frames[i-1].signature) intScore = 0;
    // Gaps
    for (let i = 1; i < frames.length; i++) if (frames[i].timestamp - frames[i-1].timestamp > 500) contScore -= 3;
    // Motion spikes
    let spikes = 0;
    frames.forEach(f => { if (f.getLayer('visual')?.motionDelta > 0.7) spikes++; });
    if (spikes > 3) contScore -= spikes * 3;
    // Sync quality
    const qualities = frames.map(f => f.syncQuality?.quality || 0);
    qualScore = Math.round(U.mean(qualities) * 30);
    
    intScore = Math.max(0, Math.min(40, intScore));
    contScore = Math.max(0, Math.min(30, contScore));
    qualScore = Math.max(0, Math.min(30, qualScore));
    
    return { score: intScore + contScore + qualScore, integrity: { score: intScore, max: 40 }, continuity: { score: contScore, max: 30 }, quality: { score: qualScore, max: 30 } };
  }
}

// RealityContainer
class RealityContainer extends Symbol {
  constructor(mode) {
    super('container', 'reality');
    this.version = '2.6';
    this.mode = mode;
    this.frames = [];
    this.symbols = new Map();
    this.lastSig = null;
    this.totalSize = 0;
    this.totalRelations = 0;
    this.validator = new Validator(this);
    this.metrics = { avgSyncQuality: 0, avgUncertainty: 0, droppedFrames: 0, causalInferenceCount: 0, patternCount: 0 };
    this.wh.what = 'reality_container';
    this.wh.when = U.timestamp();
    this.symbols.set(this.id, this);
    
    // v2.26 Architecture
    this.scenes = [];
    this.currentScene = null;
    this.moments = [];
    this.currentMoment = null;
    this.compressedFrames = [];
    this.pyramids = new Map();
    this.diffs = [];
    this.lastSceneType = null;
  }
  
  addFrame(frameData) {
    const { index, timestamp, syncedReadings, syncQuality, videoFrame, visualFingerprint, causalResults, theoreticalAnalysis } = frameData;
    const frame = new FrameSymbol(index, timestamp);
    
    if (videoFrame) { frame.addLayer(videoFrame); this.symbols.set(videoFrame.id, videoFrame); this.totalRelations += videoFrame.relations.length; }
    if (visualFingerprint) { 
      frame.addLayer(visualFingerprint); 
      this.symbols.set(visualFingerprint.id, visualFingerprint); 
      this.totalRelations += visualFingerprint.relations.length;
      
      // v2.26: Build resolution pyramid
      if (visualFingerprint.grid) {
        const pyramid = new ResolutionPyramid().build(visualFingerprint.grid);
        this.pyramids.set(index, pyramid);
        
        // v2.26: Compute attention map
        frame.attention = new AttentionMap(visualFingerprint.grid);
      }
    }
    
    if (syncedReadings) {
      Object.entries(syncedReadings).forEach(([name, reading]) => {
        if (reading.data && name !== 'video' && name !== 'visual') {
          const sensor = new SensorSymbol(name, reading.data, timestamp);
          sensor.setConfidence(reading.confidence);
          frame.addLayer(sensor);
          this.symbols.set(sensor.id, sensor);
        }
      });
    }
    
    const ts = new SensorSymbol('timestamp', { utc: U.timestamp(), iso: new Date().toISOString() });
    frame.addLayer(ts);
    this.symbols.set(ts.id, ts);
    if (syncQuality) frame.setSyncQuality(syncQuality);
    
    if (causalResults) { 
      causalResults.inferences?.forEach(inf => {
        frame.addCausalInference(inf);
        eventStore.causalInference(inf);  // v2.26: Event sourcing
      }); 
      causalResults.patterns?.forEach(pat => {
        frame.addPattern(pat);
        eventStore.patternDetected(pat);  // v2.26: Event sourcing
      }); 
      this.metrics.causalInferenceCount += (causalResults.inferences?.length || 0); 
      this.metrics.patternCount += (causalResults.patterns?.length || 0); 
    }
    
    // Store theoretical analysis if provided
    if (theoreticalAnalysis) {
      frame.theoretical = theoreticalAnalysis;
      
      // v2.26: Detect phase transitions
      const prevFrame = this.frames[this.frames.length - 1];
      const prevPhase = prevFrame?.theoretical?.thermodynamics?.phase;
      const newPhase = theoreticalAnalysis.thermodynamics?.phase;
      if (prevPhase && newPhase && prevPhase !== newPhase) {
        eventStore.phaseTransition(prevPhase, newPhase, index);
      }
    }
    
    this.lastSig = frame.sign(this.lastSig);
    
    // v2.26: Symbolic index
    symbolicIndex.index(frame);
    
    // v2.26: Delta compression
    const prevFrame = this.frames.length > 0 ? this.frames[this.frames.length - 1] : null;
    const compressed = deltaCompressor.compress(frame, prevFrame);
    this.compressedFrames.push(compressed);
    
    // v2.26: Symbolic diff
    if (prevFrame) {
      const diff = SymbolicDiff.compute(prevFrame, frame);
      this.diffs.push(diff);
    }
    
    // v2.26: Scene/Moment tracking
    this._updateHierarchy(frame, visualFingerprint);
    
    if (this.frames.length > 0) { 
      frame.link(prevFrame, 'follows', 1.0); 
      prevFrame.link(frame, 'precedes', 1.0); 
      this.totalRelations += 2; 
    }
    
    this.symbols.set(frame.id, frame);
    this.frames.push(frame);
    this.totalSize += frame.getSize();
    this.totalRelations += frame.relations.length;
    this.addChild(frame);
    frame.setParent(this);
    this.metrics.avgSyncQuality = U.runningAvg(this.metrics.avgSyncQuality, syncQuality?.quality || 0, this.frames.length);
    this.metrics.avgUncertainty = U.runningAvg(this.metrics.avgUncertainty, frame.getFrameUncertainty(), this.frames.length);
    
    // v2.26: Event sourcing
    eventStore.frameCapture(frame.index, frame.signature);
    
    bus.emit('frame:added', { index: frame.index, symbolCount: this.symbols.size });
    return frame;
  }
  
  _updateHierarchy(frame, visual) {
    const sceneType = visual?.sceneType || 'unknown';
    const sceneChanged = this.lastSceneType && sceneType !== this.lastSceneType;
    
    // Scene management
    if (!this.currentScene || sceneChanged) {
      if (this.currentScene) {
        this.currentScene.close();
        this.scenes.push(this.currentScene);
      }
      this.currentScene = new SceneCapsule(this.scenes.length, frame.index);
      if (sceneChanged) {
        eventStore.sceneChange(this.lastSceneType, sceneType, frame.index);
      }
    }
    
    // Moment management (every 1-3 seconds, ~10-30 frames)
    if (!this.currentMoment || frame.index - this.currentMoment.startFrame >= 15) {
      if (this.currentMoment) {
        this.currentMoment.computeAttention();
        this.currentScene.addMoment(this.currentMoment);
        this.moments.push(this.currentMoment);
      }
      this.currentMoment = new MomentCapsule(this.moments.length, frame.index);
    }
    
    this.currentMoment.addFrame(frame);
    this.lastSceneType = sceneType;
  }
  
  // v2.26: Query by index
  queryFrames(criteria) {
    return symbolicIndex.query(criteria).map(idx => this.frames[idx]);
  }
  
  // v2.26: Find similar frames
  findSimilar(frameIndex, threshold = 3) {
    const frame = this.frames[frameIndex];
    const hash = frame?.getLayer('visual')?.dHash;
    if (!hash) return [];
    return symbolicIndex.findSimilar(hash, threshold).map(r => ({
      frame: this.frames[r.index],
      distance: r.distance
    }));
  }
  
  // v2.26: Get scene summary
  getSceneSummary() {
    const scenes = [...this.scenes];
    if (this.currentScene) scenes.push(this.currentScene);
    return scenes.map(s => s.getSummary());
  }
  
  // v2.26: Get compression stats
  getCompressionStats() {
    return {
      originalFrames: this.frames.length,
      keyframes: this.compressedFrames.filter(c => c.type === 'keyframe').length,
      deltaFrames: this.compressedFrames.filter(c => c.type === 'delta').length,
      ratio: deltaCompressor.getCompressionRatio(this.frames)
    };
  }
  
  // v2.26: Get diff summary
  getDiffSummary() {
    return SymbolicDiff.summarize(this.diffs);
  }
  
  // v2.26: Get index stats
  getIndexStats() {
    return symbolicIndex.getStats();
  }
  
  getValidation() { return this.validator.validate(); }
  
  getCausalSummary() {
    const allInferences = this.frames.flatMap(f => f.causalInferences);
    const allPatterns = this.frames.flatMap(f => f.patterns);
    return { totalInferences: allInferences.length, totalPatterns: allPatterns.length, recentInferences: allInferences.slice(-10), recentPatterns: allPatterns.slice(-5) };
  }
  
  getMaxDepth() { let max = 0; this.symbols.forEach(s => { max = Math.max(max, s.meta.structure.depth); }); return max; }
  
  getTheoreticalSummary() {
    const analyses = this.frames.filter(f => f.theoretical).map(f => f.theoretical);
    if (analyses.length === 0) return null;
    return {
      avgScore: U.mean(analyses.map(a => a.theoreticalScore || 0)),
      avgEntropy: U.mean(analyses.filter(a => a.information).map(a => a.information.entropy?.total || 0)),
      avgContinuity: U.mean(analyses.filter(a => a.topology).map(a => a.topology?.continuity || 0)),
      avgStability: U.mean(analyses.filter(a => a.dynamics).map(a => a.dynamics?.stability || 0)),
      totalAnalyses: analyses.length
    };
  }
  
  toVRC() {
    const validation = this.getValidation();
    const causal = this.getCausalSummary();
    const theoretical = this.getTheoreticalSummary();
    const compression = this.getCompressionStats();
    const indexStats = this.getIndexStats();
    const diffSummary = this.getDiffSummary();
    const sceneSummary = this.getSceneSummary();
    
    const data = { 
      version: this.version, 
      mode: this.mode, 
      created: this.created, 
      frameCount: this.frames.length, 
      symbolCount: this.symbols.size, 
      relationCount: this.totalRelations, 
      metrics: this.metrics, 
      validation, 
      causalSummary: causal, 
      theoreticalSummary: theoretical,
      // v2.26 additions
      compression,
      indexStats,
      diffSummary,
      sceneSummary,
      eventTimeline: eventStore.getTimeline().slice(-100),
      frames: this.compressedFrames  // Use compressed frames for smaller export
    };
    return (this.mode === 'full' ? 'MLVF2.4F' : 'MLVF2.4L') + btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  }
}

// Orchestrator - 7 Stage Pipeline
class Orchestrator {
  constructor() {
    this.state = 'idle';
    this.coordinator = new SensorCoordinator();
    this.synchronizer = new FrameSynchronizer(this.coordinator);
    this.buffer = new BufferManager(30);
    this.anomalyDetector = new AnomalyDetector();
    this.causalEngine = new CausalReasoningEngine();
    this.container = null;
    this.mode = 'full';
    this.config = { targetFPS: 10, adaptiveFPS: true, minFPS: 5, maxFPS: 15 };
    this.frameIndex = 0;
    this.startTime = 0;
    this.lastFrameTime = 0;
    this.stages = ['sense', 'sync', 'symbol', 'reason', 'validate', 'chain', 'store'];
    this.currentStage = null;
    this.stageProgress = {};
    this.performance = { avgPipelineTime: 0 };
  }
  transition(newState) {
    const valid = { idle: ['initializing'], initializing: ['ready', 'error'], ready: ['recording', 'error'], recording: ['ready', 'paused', 'error'], paused: ['recording', 'ready'], error: ['idle', 'ready'] };
    if (!valid[this.state]?.includes(newState)) {
      console.error('[Orch] Invalid transition from', this.state, 'to', newState, '- valid targets:', valid[this.state]);
      return false;
    }
    const oldState = this.state;
    this.state = newState;
    bus.emit('orch:state', { from: oldState, to: newState });
    Log.info('orch', `State: ${oldState} -> ${newState}`);
    this._updateStateUI();
    return true;
  }
  getState() { return this.state; }
  async initialize() {
    this.transition('initializing');
    this.coordinator.register('video', { priority: 'critical', updateRate: 100, timeout: 500, baseUncertainty: 0.02 });
    this.coordinator.register('audio', { priority: 'critical', updateRate: 100, timeout: 500, baseUncertainty: 0.05 });
    this.coordinator.register('visual', { priority: 'critical', updateRate: 100, timeout: 500, baseUncertainty: 0.03 });
    this.coordinator.register('gps', { priority: 'important', updateRate: 1000, timeout: 5000, baseUncertainty: 0.1 });
    this.coordinator.register('motion', { priority: 'optional', updateRate: 50, timeout: 1000, baseUncertainty: 0.08 });
    this.coordinator.register('env', { priority: 'derived', updateRate: 200, timeout: 1000, baseUncertainty: 0.1 });
    return true;
  }
  startRecording() {
    console.log('[Orch] startRecording called, current state:', this.state);
    if (this.state !== 'ready') {
      console.error('[Orch] Cannot start recording - state is not ready:', this.state);
      return false;
    }
    this.container = new RealityContainer(this.mode);
    this.frameIndex = 0;
    this.startTime = U.timestamp();
    this.lastFrameTime = 0;
    this.anomalyDetector.clear();
    this.causalEngine.clear();
    this.buffer.clear();
    theoreticalAnalyzer.clear();
    DynamicalSystems.clear();
    bus.emit('recording:start', { mode: this.mode });
    const transitioned = this.transition('recording');
    console.log('[Orch] Transition to recording:', transitioned, 'new state:', this.state);
    return transitioned;
  }
  stopRecording() {
    if (this.state !== 'recording' && this.state !== 'paused') return false;
    bus.emit('recording:stop', { frameCount: this.container?.frames.length });
    return this.transition('ready');
  }
  pauseCapture() {
    if (this.state !== 'recording') return false;
    bus.emit('recording:pause', { frameCount: this.container?.frames.length });
    return this.transition('paused');
  }
  resumeCapture() {
    if (this.state !== 'paused') return false;
    bus.emit('recording:resume', { frameCount: this.container?.frames.length });
    return this.transition('recording');
  }
  runPipeline() {
    if (this.state !== 'recording') {
      // Only log occasionally to avoid spam
      if (Math.random() < 0.01) console.log('[Orch] runPipeline skipped, state:', this.state);
      return null;
    }
    const now = U.timestamp();
    const targetInterval = 1000 / this.config.targetFPS;
    if (now - this.lastFrameTime < targetInterval) return null;
    this.lastFrameTime = now;
    const timestamp = now - this.startTime;
    
    // SENSE
    this._setStage('sense', 100);
    // SYNC
    this._setStage('sync', 0);
    const syncedReadings = this.synchronizer.collectSynchronized(now);
    const syncQuality = this.synchronizer.getSyncQuality(syncedReadings);
    this._setStage('sync', 100);
    // SYMBOL
    this._setStage('symbol', 100);
    
    const frameData = { index: this.frameIndex++, timestamp, syncedReadings, syncQuality, videoFrame: null, visualFingerprint: null, causalResults: null };
    const priority = syncQuality.quality > 0.8 ? 'high' : 'normal';
    this.buffer.add(frameData, priority);
    
    // Log first few frames
    if (frameData.index < 5) {
      console.log('[Orch] Frame', frameData.index, 'added to buffer, syncQuality:', syncQuality.quality.toFixed(2));
    }
    
    bus.emit('pipeline:frame', { index: frameData.index, syncQuality: syncQuality.quality });
    return frameData;
  }
  processBuffer(videoFrame, visualFingerprint) {
    // REASON
    this._setStage('reason', 0);
    let processedCount = 0;
    
    DEBUG.pipeline_log('processBuffer', { 
      hasVF: !!visualFingerprint,
      hasGrid: !!visualFingerprint?.grid,
      bufferSize: this.buffer.getStatus().current
    });
    
    this.buffer.process(frameData => {
      frameData.videoFrame = this.mode === 'full' ? videoFrame : null;
      frameData.visualFingerprint = visualFingerprint;
      
      // Create temp frame for analysis
      const tempFrame = new FrameSymbol(frameData.index, frameData.timestamp);
      
      // Add visual layer
      if (visualFingerprint) {
        tempFrame.addLayer(visualFingerprint);
      }
      
      // Add other sensor layers
      Object.entries(frameData.syncedReadings || {}).forEach(([name, reading]) => { 
        if (reading.data && name !== 'visual') {
          tempFrame.addLayer(new SensorSymbol(name, reading.data)); 
        }
      });
      
      const prevFrame = this.container.frames[this.container.frames.length - 1];
      
      // Causal reasoning
      frameData.causalResults = this.causalEngine.reason(tempFrame, prevFrame);
      this._setStage('reason', 50);
      
      // THEORETICAL ANALYSIS â€” Apply 11 mathematical frameworks
      try {
        frameData.theoreticalAnalysis = theoreticalAnalyzer.analyzeFrame(tempFrame, prevFrame, this.container);
        DEBUG.theory_log('Frame', frameData.index, 'score:', frameData.theoreticalAnalysis?.theoreticalScore);
      } catch (e) {
        DEBUG.log('Theoretical error:', e.message);
        frameData.theoreticalAnalysis = { 
          error: e.message, 
          theoreticalScore: 0,
          information: { entropy: { total: 0 }, novelty: 0 },
          topology: { continuity: 0, components: 0 },
          symmetry: { radialSymmetry: 0 },
          thermodynamics: { phase: 'unknown', entropy: 0 }
        };
      }
      this._setStage('reason', 80);
      
      // VALIDATE & CHAIN
      this._setStage('validate', 100);
      this._setStage('chain', 50);
      
      // Add frame to container
      const frame = this.container.addFrame(frameData);
      
      // Attach theoretical analysis to stored frame
      frame.theoretical = frameData.theoreticalAnalysis;
      
      // Anomaly detection
      const anomalies = this.anomalyDetector.check(frame, prevFrame);
      anomalies.forEach(a => frame.addAnomaly(a));
      
      // Emit event for UI updates
      bus.emit('frame:theoretical', { 
        index: frame.index, 
        score: frame.theoretical?.theoreticalScore || 0 
      });
      
      this._setStage('chain', 100);
      this._setStage('store', 100);
      processedCount++;
    });
    
    this.container.metrics.droppedFrames = this.buffer.getStatus().dropped;
    return processedCount;
  }
  getTheoreticalSummary() { return theoreticalAnalyzer.getSummary(); }
  _setStage(stage, progress) {
    this.currentStage = stage;
    this.stageProgress[stage] = progress;
    this._updatePipelineUI();
  }
  getContainer() { return this.container; }
  getSensorHealth() { return this.coordinator.getAllHealth(); }
  getBufferStatus() { return this.buffer.getStatus(); }
  getAnomalies() { return this.anomalyDetector.getSummary(); }
  getCausalSummary() { return this.causalEngine.getSummary(); }
  _updateStateUI() {
    const chip = document.getElementById('state-chip');
    const text = document.getElementById('state-text');
    chip.className = 'chip state ' + this.state;
    text.textContent = this.state.charAt(0).toUpperCase() + this.state.slice(1);
    const pipeDot = document.getElementById('info-pipe-dot');
    const pipeText = document.getElementById('info-pipe');
    if (this.state === 'recording') { pipeDot.className = 'info-dot green'; pipeText.textContent = this.currentStage || 'Running'; }
    else if (this.state === 'error') { pipeDot.className = 'info-dot red'; pipeText.textContent = 'Error'; }
    else { pipeDot.className = 'info-dot yellow'; pipeText.textContent = this.state; }
  }
  _updatePipelineUI() {
    this.stages.forEach(stage => {
      const el = document.getElementById(`stage-${stage}`);
      const fill = document.getElementById(`fill-${stage}`);
      if (el && fill) { const progress = this.stageProgress[stage] || 0; fill.style.width = progress + '%'; el.classList.toggle('active', this.currentStage === stage && progress < 100); }
    });
    document.getElementById('info-pipe').textContent = this.currentStage || 'Idle';
  }
  updateSensorUI(name) {
    const health = this.coordinator.getHealth(name);
    const fullHealth = this.coordinator.getFullHealth(name);
    const healthEl = document.getElementById(`health-${name}`);
    const cardEl = document.getElementById(`card-${name}`);
    const confEl = document.getElementById(`conf-${name}`);
    const uncEl = document.getElementById(`unc-${name}`);
    if (healthEl) healthEl.className = 'sensor-card-health ' + health;
    if (cardEl) { cardEl.classList.remove('healthy', 'degraded', 'stale', 'failed'); cardEl.classList.add(health); }
    if (confEl) confEl.style.width = (fullHealth.quality * 100) + '%';
    if (uncEl) uncEl.textContent = `Ïƒ: ${(fullHealth.uncertainty * 100).toFixed(1)}%`;
  }
}

// QueryEngine
class QueryEngine {
  constructor(orchestrator) { this.orch = orchestrator; }
  ask(q) {
    const question = q.toLowerCase().trim();
    const container = this.orch.getContainer();
    if (!container || container.frames.length === 0) return 'No reality captured yet. Start recording first!';
    
    // Help command
    if (question.match(/^(help|\?)$/)) return this._help();
    
    // Overview commands
    if (question.match(/^(overview|summary|status)$/)) return this._overview(container);
    
    // WH commands
    if (question.match(/^wh$/)) return this._whCurrent(container);
    const whMatch = question.match(/^wh\s+frame\s*(\d+)$/);
    if (whMatch) return this._whFrame(container, parseInt(whMatch[1]));
    
    // Dive commands
    const diveMatch = question.match(/^dive\s+(what|where|when|why|how|because)$/);
    if (diveMatch) return this._dive(container, diveMatch[1]);
    
    // Causal commands
    if (question.match(/^causal/)) return this._causal(container);
    if (question.match(/^pattern/)) return this._patterns(container);
    
    // Theory commands
    if (question.match(/^theor/)) return this._theory(container);
    if (question.match(/^entropy/)) return this._entropy(container);
    if (question.match(/^phase/)) return this._phase(container);
    
    // Frame commands
    const frameMatch = question.match(/^frame\s*(\d+)$/);
    if (frameMatch) return this._frame(container, parseInt(frameMatch[1]));
    if (question.match(/^last$/)) return this._frame(container, container.frames.length - 1);
    if (question.match(/^first$/)) return this._frame(container, 0);
    
    // Sensor commands
    if (question.match(/sensor|health/)) return this._sensors();
    if (question.match(/uncertainty|sigma/)) return this._uncertainty(container);
    
    // v2.26 Sensor control commands
    const profileMatch = question.match(/^profile\s+(full|lite|indoor|outdoor)$/);
    if (profileMatch) {
      applySensorProfile(profileMatch[1]);
      return `Applied sensor profile: ${profileMatch[1]}`;
    }
    if (question.match(/^calibrate$/)) {
      switchTab('sensors');
      return 'Open Settings â†’ Sensors tab to calibrate sensors.';
    }
    if (question.match(/^monitor$/)) {
      if (sensorMonitor.isMonitoring) {
        sensorMonitor.stop();
        return 'Sensor monitoring stopped.';
      } else {
        sensorMonitor.start();
        return 'Sensor monitoring started.';
      }
    }
    if (question.match(/^reset\s+sensors?$/)) {
      resetAllSensors();
      return 'All sensors reset.';
    }
    if (question.match(/^battery$/)) {
      sensorController.optimizeForBattery();
      return 'Optimized for battery life.';
    }
    if (question.match(/^quality$/)) {
      sensorController.optimizeForQuality();
      return 'Optimized for quality.';
    }
    if (question.match(/^policy$/)) {
      return this._policyStatus();
    }
    
    // Stats commands
    if (question.match(/^stats$/)) return this._stats(container);
    if (question.match(/^export$/)) return this._exportInfo(container);
    
    // v2.26 Architecture commands
    if (question.match(/^scenes?$/)) return this._scenes(container);
    if (question.match(/^moments?$/)) return this._moments(container);
    if (question.match(/^index$/)) return this._index(container);
    if (question.match(/^compress/)) return this._compression(container);
    if (question.match(/^timeline$/)) return this._timeline(container);
    if (question.match(/^diff/)) return this._diffSummary(container);
    if (question.match(/^attention/)) return this._attention(container);
    
    // v2.26 Find commands
    if (question.match(/^find\s+high/)) return this._findByEntropy(container, 'high');
    if (question.match(/^find\s+low/)) return this._findByEntropy(container, 'low');
    if (question.match(/^find\s+motion/)) return this._findByMotion(container);
    if (question.match(/^find\s+bright/)) return this._findByLuminance(container, 'bright');
    if (question.match(/^find\s+dark/)) return this._findByLuminance(container, 'dark');
    if (question.match(/^find\s+outliers?/)) return this._findOutliers(container);
    if (question.match(/^find\s+transitions?/)) return this._findTransitions(container);
    const similarMatch = question.match(/^similar\s*(\d+)$/);
    if (similarMatch) return this._findSimilar(container, parseInt(similarMatch[1]));
    const nearMatch = question.match(/^near\s*(\d+)$/);
    if (nearMatch) return this._findNear(container, parseInt(nearMatch[1]));
    const searchMatch = question.match(/^search\s+(.+)$/);
    if (searchMatch) return this._searchFrames(container, searchMatch[1]);
    
    // v2.26 Event queries
    if (question.match(/^events?$/)) return this._events(container);
    if (question.match(/^phases?$/)) return this._phases(container);
    if (question.match(/^tags?$/)) return this._tags(container);
    
    // v2.26 Playback queries
    if (question.match(/^play$/)) { openPlaybackPanel(); return 'Opening playback panel...'; }
    if (question.match(/^compare$/)) { openComparePanel(); return 'Opening compare panel...'; }
    if (question.match(/^analytics$/)) { openAnalyticsPanel(); return 'Opening analytics dashboard...'; }
    if (question.match(/^graph$/)) { openAnalyticsPanel(); return 'Opening metrics graph...'; }
    if (question.match(/^film(strip)?$/)) { openAnalyticsPanel(); return 'Opening filmstrip view...'; }
    if (question.match(/^clip$/)) { openClipPanel(); return 'Opening clip export...'; }
    if (question.match(/^report$/)) { openReportPanel(); return 'Opening report generator...'; }
    
    // v2.26 Symbolic visualization commands
    if (question.match(/^mesh$/)) { openMeshPanel(); return 'Opening symbol mesh network...'; }
    if (question.match(/^chain(s)?$/)) { openChainPanel(); return 'Opening causal chains...'; }
    if (question.match(/^mfidel|fidel|geez$/)) { openMfidelPanel(); return 'Opening Mfidel encoding...'; }
    if (question.match(/^narrative$/)) { openNarrativePanel(); return 'Generating narrative...'; }
    if (question.match(/^symbols?$/)) return this._symbols();
    if (question.match(/^causal$/)) return this._causalSummary();
    
    // v2.26 Deep exploration commands
    if (question.match(/^dive$/)) { openDivePanel(); return 'Opening InceptaDive explorer...'; }
    if (question.match(/^ontology$/)) { openOntologyPanel(); return 'Opening symbol ontology...'; }
    if (question.match(/^sql|query$/)) { openSqlPanel(); return 'Opening symbolic query...'; }
    if (question.match(/^dive\s+(what|where|when|who|why|how|which)$/i)) {
      const dim = question.match(/dive\s+(\w+)/i)[1].toUpperCase();
      openDivePanel();
      setTimeout(() => inceptaDive.dive(dim), 100);
      return `Diving into ${dim}...`;
    }
    
    // v2.26 Audio, Motion, Mullu commands
    if (question.match(/^audio$/)) { openAudioPanel(); return 'Opening audio waveform...'; }
    if (question.match(/^waveform$/)) { openAudioPanel(); return 'Opening audio waveform...'; }
    if (question.match(/^motion$/)) { openMotionPanel(); return 'Opening motion trajectory...'; }
    if (question.match(/^trajectory$/)) { openMotionPanel(); return 'Opening motion trajectory...'; }
    if (question.match(/^mullu$/)) { openMulluPanel(); return 'Opening Mullu export...'; }
    if (question.match(/^export mullu$/)) { downloadMullu(); return 'Downloading .mullu file...'; }
    if (question.match(/^perf(ormance)?$/)) { togglePerfMonitor(); return 'Toggling performance monitor...'; }
    
    // v2.26 Pattern, Help, Theme commands
    if (question.match(/^patterns?$/)) { openPatternPanel(); return 'Analyzing patterns...'; }
    if (question.match(/^anomal(y|ies)$/)) { openPatternPanel(); return 'Detecting anomalies...'; }
    if (question.match(/^highlights?$/)) { openPatternPanel(); return 'Finding highlights...'; }
    if (question.match(/^help$/)) { openHelpPanel(); return 'Opening help...'; }
    if (question.match(/^shortcuts?$/)) { openHelpPanel(); return 'Showing keyboard shortcuts...'; }
    if (question.match(/^theme\s+(dark|light|midnight)$/i)) {
      const themeName = question.match(/theme\s+(\w+)/i)[1].toLowerCase();
      applyTheme(themeName);
      return `Applied ${themeName} theme`;
    }
    if (question.match(/^theme$/)) { cycleTheme(); return `Cycled to ${themeManager.getCurrent()} theme`; }
    if (question.match(/^timeline$/)) { updateSmartTimeline(); return 'Updated smart timeline'; }
    
    // v2.26 Professional Recording Commands
    if (question.match(/^tour$/)) { showTour(); return 'Starting tour...'; }
    if (question.match(/^onboarding$/)) { showTour(); return 'Starting onboarding...'; }
    if (question.match(/^record$/)) { 
      const state = recordingController.getState();
      if (state === 'idle' || state === 'stopped') {
        recordingController.startNew();
        return 'Recording started...';
      } else if (state === 'paused') {
        recordingController.resume();
        return 'Recording resumed...';
      }
      return `Already ${state}`;
    }
    if (question.match(/^pause$/)) { 
      if (recordingController.pause()) return 'Recording paused';
      return 'Cannot pause (not recording)';
    }
    if (question.match(/^resume$/)) { 
      if (recordingController.resume()) return 'Recording resumed';
      return 'Cannot resume (not paused)';
    }
    if (question.match(/^stop$/)) { 
      if (recordingController.forceStop()) return 'Recording stopped';
      return 'No active recording';
    }
    if (question.match(/^new$/)) { 
      recordingController.startNew();
      return 'Starting new recording...';
    }
    if (question.match(/^status$/)) { 
      const s = recordingController.getStats();
      return `State: ${s.state}, Frames: ${s.frameCount}, Duration: ${(s.duration/1000).toFixed(1)}s, Paused: ${(s.pauseDuration/1000).toFixed(1)}s, Unsaved: ${s.hasUnsavedData}`;
    }
    
    // v2.26 Data management commands
    if (question.match(/^data$/)) { openDataPanel(); return 'Opening data manager...'; }
    if (question.match(/^recordings?$/)) { openDataPanel(); return 'Opening recordings...'; }
    if (question.match(/^save$/)) { saveCurrentRecording(); return 'Saving...'; }
    if (question.match(/^autosave$/)) { toggleAutoSave(); return dataManager.autoSaveEnabled ? 'Auto-save ON' : 'Auto-save OFF'; }
    if (question.match(/^storage$/)) { showStorageUsage(); return 'Checking storage...'; }
    if (question.match(/^install$/)) { promptInstallPWA(); return 'Checking install...'; }
    if (question.match(/^pwa$/)) { 
      const s = pwaManager.getStatus();
      return `Installed: ${s.isInstalled}, Can install: ${s.canInstall}, Online: ${s.isOnline}`;
    }
    if (question.match(/^mobile$/)) { 
      const v = mobileAdapter.getViewportSize();
      return `Mobile: ${v.isMobile}, ${v.width}x${v.height}, ${v.orientation}`;
    }
    if (question.match(/^errors?$/)) { 
      const errs = errorBoundary.getRecentErrors();
      return errs.length > 0 ? `${errs.length} errors logged` : 'No errors';
    }
    if (question.match(/^recover$/)) {
      dataManager.loadDraft().then(d => {
        if (d) toast.success(`Draft recovered: ${d.serialized?.frames?.length || 0} frames`);
        else toast.info('No draft to recover');
      });
      return 'Recovering draft...';
    }
    
    // v2.26 Camera & Performance commands
    if (question.match(/^camera$/)) { openCameraPanel(); return 'Opening camera settings...'; }
    if (question.match(/^resolution\s+(\w+)$/i)) {
      const res = question.match(/^resolution\s+(\w+)$/i)[1].toLowerCase();
      setCameraResolution(res);
      return `Setting resolution to ${res.toUpperCase()}...`;
    }
    if (question.match(/^fps\s+(\d+)$/i)) {
      const fps = parseInt(question.match(/^fps\s+(\d+)$/i)[1]);
      setCameraFPS(fps);
      return `Setting FPS to ${fps}...`;
    }
    if (question.match(/^flip$/)) { toggleCameraFacing(); return 'Flipping camera...'; }
    if (question.match(/^zoom\s+([\d.]+)$/i)) {
      const zoom = parseFloat(question.match(/^zoom\s+([\d.]+)$/i)[1]);
      setCameraZoom(zoom);
      return `Setting zoom to ${zoom}x...`;
    }
    if (question.match(/^torch$/)) { toggleCameraTorch(); return 'Toggling torch...'; }
    if (question.match(/^perf$/)) { togglePerfMonitor(); return 'Toggling performance monitor...'; }
    if (question.match(/^performance$/)) { return getPerformanceReport(); }
    if (question.match(/^a11y$/)) { 
      a11y.announce('Accessibility features active. Screen reader support enabled.');
      return 'Accessibility: Screen reader support, skip links, focus management enabled.';
    }
    
    // v2.26 Clip Editor & Export commands
    if (question.match(/^clips?$/)) { openClipEditorPanel(); return 'Opening clip editor...'; }
    if (question.match(/^edit$/)) { openClipEditorPanel(); return 'Opening clip editor...'; }
    if (question.match(/^cut$/)) { openClipEditorPanel(); return 'Opening clip editor...'; }
    if (question.match(/^trim$/)) { openClipEditorPanel(); return 'Opening clip editor...'; }
    if (question.match(/^create\s*clip$/i)) { 
      const clip = clipEditor.createFromSelection();
      return clip ? `Created: ${clip.name}` : 'No selection. Select range first.';
    }
    if (question.match(/^auto\s*clips?$/i)) { 
      const clips = clipEditor.autoDetectClips();
      return `Created ${clips.length} clips from scenes`;
    }
    if (question.match(/^export$/)) { openExportPanel(); return 'Opening export panel...'; }
    if (question.match(/^export\s+mullu$/i)) { quickExportMullu(); return 'Exporting as Mullu...'; }
    if (question.match(/^export\s+json$/i)) { quickExportJSON(); return 'Exporting as JSON...'; }
    if (question.match(/^export\s+csv$/i)) { quickExportCSV(); return 'Exporting as CSV...'; }
    if (question.match(/^export\s+report$/i)) { quickExportReport(); return 'Exporting report...'; }
    if (question.match(/^formats?$/)) { 
      return 'Export formats: mullu, json, csv, report\nUse: export <format>';
    }
    
    // v2.26 Annotation commands
    if (question.match(/^timeline$/i)) { openAnnotationPanel(); return 'Opening annotation timeline...'; }
    if (question.match(/^annotations?$/i)) { openAnnotationPanel(); return 'Opening annotation timeline...'; }
    if (question.match(/^add\s*marker$/i)) { addMarkerAtCurrent(); return 'Marker added'; }
    if (question.match(/^chapter$/i)) { addChapterMarker(); return 'Chapter marker added'; }
    if (question.match(/^important$/i)) { addImportantMarker(); return 'Important marker added'; }
    if (question.match(/^next\s*marker$/i)) { goToNextMarker(); return 'Going to next marker...'; }
    if (question.match(/^prev\s*marker$/i)) { goToPrevMarker(); return 'Going to previous marker...'; }
    if (question.match(/^notes?$/i)) { openNotesPanel(); return 'Opening notes panel...'; }
    if (question.match(/^clear\s*markers$/i)) { clearAllMarkers(); return 'Markers cleared'; }
    if (question.match(/^import\s*scenes$/i)) { importScenesAsRegions(); return 'Importing scenes as regions...'; }
    if (question.match(/^export\s*annotations$/i)) { exportAnnotations(); return 'Exporting annotations...'; }
    if (question.match(/^marker\s*stats$/i)) { 
      const stats = annotationTimeline.getStats();
      return `Markers: ${stats.markerCount}, Regions: ${stats.regionCount}, Notes: ${stats.noteCount}`;
    }
    
    // v2.26 Undo/Redo commands
    if (question.match(/^undo$/i)) { doUndo(); return 'Undo performed'; }
    if (question.match(/^redo$/i)) { doRedo(); return 'Redo performed'; }
    if (question.match(/^history$/i)) { openHistoryPanel(); return 'Opening history panel...'; }
    if (question.match(/^clear\s*history$/i)) { clearHistory(); return 'History cleared'; }
    
    // v2.26 Batch commands
    if (question.match(/^select\s*all\s*clips$/i)) { selectAllClips(); return 'All clips selected'; }
    if (question.match(/^select\s*all\s*markers$/i)) { selectAllMarkers(); return 'All markers selected'; }
    if (question.match(/^clear\s*selection$/i)) { clearBatchSelection(); return 'Selection cleared'; }
    if (question.match(/^batch\s*delete$/i)) { batchDelete(); return 'Batch delete performed'; }
    if (question.match(/^generate\s*chapters$/i)) { generateChapters(); return 'Chapters generated from scenes'; }
    if (question.match(/^generate\s*markers\s*(\d+)$/i)) { 
      const n = parseInt(question.match(/^generate\s*markers\s*(\d+)$/i)[1]);
      generateMarkersEveryN(n);
      return `Markers generated every ${n} frames`;
    }
    
    // v2.26 Keyboard cheatsheet
    if (question.match(/^shortcuts?$/i)) { toggleCheatsheet(); return 'Opening keyboard shortcuts...'; }
    if (question.match(/^keys?$/i)) { toggleCheatsheet(); return 'Opening keyboard shortcuts...'; }
    if (question.match(/^cheatsheet$/i)) { toggleCheatsheet(); return 'Opening keyboard shortcuts...'; }
    
    // v2.26 Project management commands
    if (question.match(/^projects?$/i)) { openProjectBrowser(); return 'Opening project browser...'; }
    if (question.match(/^new\s*project$/i)) { createNewProject(); return 'Creating new project...'; }
    if (question.match(/^save\s*project$/i)) { quickSaveProject(); return 'Saving project...'; }
    if (question.match(/^export\s*project$/i)) { exportCurrentProject(); return 'Exporting project...'; }
    if (question.match(/^templates?$/i)) { 
      projectBrowserUI.currentTab = 'templates';
      openProjectBrowser();
      return 'Opening templates...';
    }
    if (question.match(/^project\s*info$/i)) {
      const info = projectManager.getProjectInfo();
      if (!info) return 'No project loaded';
      return `Project: ${info.name}\nFrames: ${info.frameCount}\nClips: ${info.clipCount}\nMarkers: ${info.markerCount}\n${info.isDirty ? '(Unsaved changes)' : '(Saved)'}`;
    }
    
    // v2.26 Share & collaboration commands
    if (question.match(/^share$/i)) { openSharePanel(); return 'Opening share panel...'; }
    if (question.match(/^collaborate$/i)) { openSharePanel(); return 'Opening share panel...'; }
    if (question.match(/^comments?$/i)) { openCommentsPanel(); return 'Opening comments panel...'; }
    if (question.match(/^create\s*share$/i)) { createNewShare(); return 'Creating share link...'; }
    if (question.match(/^add\s*collaborator$/i)) { openAddCollaboratorDialog(); return 'Adding collaborator...'; }
    if (question.match(/^share\s*stats$/i)) {
      openSharePanel();
      return 'Opening share panel to view stats...';
    }
    
    // v2.26 Search commands
    if (question.match(/^search$/i)) { openSearchPanel(); return 'Opening global search...'; }
    if (question.match(/^find$/i)) { openSearchPanel(); return 'Opening global search...'; }
    const globalSearchMatch = question.match(/^search\s+(.+)$/i);
    if (globalSearchMatch) {
      openSearchPanel();
      setTimeout(() => {
        searchUI.performSearch(globalSearchMatch[1]);
      }, 200);
      return `Searching for "${globalSearchMatch[1]}"...`;
    }
    if (question.match(/^saved\s*searches?$/i)) {
      openSearchPanel();
      return 'Opening saved searches...';
    }
    if (question.match(/^clear\s*search\s*history$/i)) {
      globalSearch.clearHistory();
      return 'Search history cleared';
    }
    
    // v2.26 Diagnostic commands
    if (question.match(/^diagnostics?$/i) || question.match(/^health$/i)) {
      return runDiagnostics();
    }
    if (question.match(/^system\s*health$/i)) {
      return getSystemHealth();
    }
    if (question.match(/^memory$/i) || question.match(/^memory\s*status$/i)) {
      return checkMemory();
    }
    if (question.match(/^cleanup$/i) || question.match(/^memory\s*cleanup$/i)) {
      return forceMemoryCleanup();
    }
    if (question.match(/^integrity$/i) || question.match(/^check\s*integrity$/i)) {
      return checkDataIntegrity();
    }
    if (question.match(/^repair$/i) || question.match(/^repair\s*data$/i)) {
      return repairData();
    }
    if (question.match(/^validate$/i) || question.match(/^validate\s*project$/i)) {
      return validateProject();
    }
    if (question.match(/^state\s*history$/i) || question.match(/^states$/i)) {
      return getStateHistory();
    }
    if (question.match(/^autosave$/i) || question.match(/^auto\s*save\s*status$/i)) {
      return getAutoSaveStatus();
    }
    if (question.match(/^force\s*save$/i)) {
      return forceAutoSave();
    }
    if (question.match(/^clear\s*backups$/i)) {
      return clearAutoSaveBackups();
    }
    
    // v2.26 Menu & Navigation commands
    if (question.match(/^menu$/i)) {
      toggleMainMenu();
      return 'Opening main menu...';
    }
    if (question.match(/^dashboard$/i) || question.match(/^home$/i)) {
      openDashboard();
      return 'Opening dashboard...';
    }
    if (question.match(/^info$/i) || question.match(/^system\s*info$/i)) {
      openInfoPanel();
      return 'Opening system information...';
    }
    if (question.match(/^about$/i)) {
      showAboutDialog();
      return 'Opening about dialog...';
    }
    if (question.match(/^version$/i)) {
      return 'VIRECAI v2.27.1 - Mullu Symbolic Intelligence\nBuild: 2025-12-23 (Hotfix)\nWebsite: mullusi.com';
    }
    
    // v2.26 UX Commands
    if (question.match(/^notifications?$/i)) {
      toggleNotifications();
      return 'Opening notifications...';
    }
    if (question.match(/^floating$/i) || question.match(/^toolbar$/i)) {
      toggleFloatingActions();
      return floatingActions.isVisible ? 'Floating toolbar visible' : 'Floating toolbar hidden';
    }
    if (question.match(/^minimap$/i)) {
      timelineMinimap.render('timeline-minimap-container');
      return 'Timeline minimap updated';
    }
    if (question.match(/^star$/i) || question.match(/^starred$/i)) {
      const starred = starredManager.getStarred();
      return starred.length > 0 ? `Starred projects: ${starred.length}` : 'No starred projects';
    }
    if (question.match(/^recent$/i) || question.match(/^actions$/i)) {
      recentActions.render('query-output');
      return 'Showing recent actions';
    }
    if (question.match(/^layout\s+(recording|editing|analysis)$/i)) {
      const match = question.match(/layout\s+(\w+)/i);
      workspaceLayouts.apply(match[1].toLowerCase());
      return `Layout changed to: ${match[1]}`;
    }
    if (question.match(/^palette$/i) || question.match(/^symbols$/i)) {
      symbolPalette.render('query-output');
      return 'Symbol palette displayed';
    }
    if (question.match(/^wh$/i) || question.match(/^query\s*builder$/i)) {
      whQueryBuilder.render('query-output');
      return 'WH Query Builder displayed';
    }
    if (question.match(/^presets?$/i)) {
      exportPresets.render('query-output');
      return 'Export presets displayed';
    }
    
    // Symbolic query inline execution
    const sqlMatch = question.match(/^(find|show|what|when|where|how|compare)\s+.+$/i);
    if (sqlMatch) {
      const result = symbolicQuery.parse(question, orch?.getContainer());
      return symbolicQuery.formatResult(result);
    }
    
    if (question.match(/^annotate?$/)) return this._annotations();
    if (question.match(/^tags$/)) return this._quickTags();
    if (question.match(/^bookmarks?$/)) return this._bookmarks();
    if (question.match(/^markers?$/)) return this._markers();
    if (question.match(/^heatmap$/)) { openAnalyticsPanel(); return 'Use heatmap controls in Analytics panel.'; }
    if (question.match(/^history$/)) return this._history();
    if (question.match(/^session$/)) return this._session();
    if (question.match(/^detect$/)) { autoDetectMarkers(); return 'Auto-detecting timeline markers...'; }
    
    // v2.26 Search queries
    const vsearchMatch = question.match(/^vsearch\s+(.+)$/);
    if (vsearchMatch) {
      showSearchResults(vsearchMatch[1]);
      openAnalyticsPanel();
      return `Searching for "${vsearchMatch[1]}"...`;
    }
    
    return this._overview(container);
  }
  
  _symbols() {
    const container = orch?.getContainer();
    if (!container || container.frames.length === 0) {
      return 'No data available. Record some content first.';
    }
    
    symbolMesh.buildFromContainer(container);
    const stats = symbolMesh.getStats();
    
    let output = `SYMBOL MESH NETWORK (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Nodes: ${stats.totalNodes}
Total Edges: ${stats.totalEdges}
Density: ${(stats.density * 100).toFixed(1)}%

BY TYPE:
${Object.entries(stats.nodesByType).map(([k, v]) => `  ${k}: ${v}`).join('\n')}

RELATIONSHIPS:
${Object.entries(stats.edgesByType).map(([k, v]) => `  ${k}: ${v}`).join('\n')}

Open mesh panel for visualization: type "mesh"`;
    
    return output;
  }
  
  _causalSummary() {
    const container = orch?.getContainer();
    if (!container || container.frames.length === 0) {
      return 'No data available. Record some content first.';
    }
    
    causalChain.buildFromContainer(container);
    const stats = causalChain.getStats();
    const longest = causalChain.getLongestChain();
    
    let output = `CAUSAL CHAIN ANALYSIS (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Chains: ${stats.total}
Total Events: ${stats.totalEvents}
Avg Chain Length: ${stats.avgLength?.toFixed(1) || 0}
Max Chain Length: ${stats.maxLength || 0}
Avg Confidence: ${((stats.avgConfidence || 0) * 100).toFixed(0)}%

`;
    
    if (longest) {
      output += `LONGEST CHAIN:
${longest.events.map((e, i) => 
  `  ${i + 1}. F${e.frameIndex}: ${e.type}${e.effect ? ' â†’ ' + e.effect : ''}`
).join('\n')}

`;
    }
    
    output += `Open chains panel for details: type "chains"`;
    
    return output;
  }
  
  _bookmarks() {
    const bookmarks = bookmarkManager.getAll();
    
    if (bookmarks.length === 0) {
      return `BOOKMARKS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
No bookmarks yet.

Add bookmark: Press B in playback mode
Navigate: [ ] to jump between bookmarks`;
    }
    
    return `BOOKMARKS (${bookmarks.length})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${bookmarks.map(b => `â€¢ F${b.frameIndex}: ${b.name}`).join('\n')}

Navigation:
  [ = Previous bookmark
  ] = Next bookmark
  B = Add bookmark at current frame`;
  }
  
  _markers() {
    const markers = timelineMarkers.markers;
    const byType = {};
    markers.forEach(m => byType[m.type] = (byType[m.type] || 0) + 1);
    
    if (markers.length === 0) {
      return `TIMELINE MARKERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
No markers yet.

To auto-detect: Query "detect" or press M
Manual markers are added via bookmarks (B)`;
    }
    
    return `TIMELINE MARKERS (${markers.length})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${Object.entries(byType).map(([k, v]) => `â€¢ ${k}: ${v}`).join('\n')}

Recent:
${markers.slice(-5).map(m => `â€¢ F${m.frameIndex}: ${m.type} - ${m.label || 'â€”'}`).join('\n')}

Commands: detect (auto-detect), B (add bookmark)`;
  }
  
  _quickTags() {
    const allTags = quickTags.getAllUsedTags();
    
    if (allTags.length === 0) {
      return `QUICK TAGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
No tags applied yet.

Available tags:
${quickTags.predefinedTags.map(t => `â€¢ ${t.icon} ${t.name}`).join('\n')}

To tag: Open Playback (P), navigate to frame,
then click tags in Analytics panel (A).`;
    }
    
    return `QUICK TAGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${allTags.map(tag => {
  const frames = quickTags.getFramesWithTag(tag);
  const icon = quickTags.getTagIcon(tag);
  return `${icon} ${tag}: ${frames.length} frames [${frames.slice(0,5).join(', ')}${frames.length > 5 ? '...' : ''}]`;
}).join('\n')}

Search tagged frames: vsearch tag:tagname`;
  }
  
  _annotations() {
    const annotations = annotationManager.getAll();
    const tags = annotationManager.getAllTags();
    
    if (annotations.length === 0) {
      return `ANNOTATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
No annotations yet.

To add: Press A to open Analytics panel,
then enter frame number and note text.`;
    }
    
    return `ANNOTATIONS (${annotations.length})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${annotations.slice(0, 10).map(a => `F${a.frameIndex}: ${a.text}`).join('\n')}
${annotations.length > 10 ? `\n... and ${annotations.length - 10} more` : ''}

${tags.length > 0 ? `Tags: ${tags.join(', ')}` : ''}`;
  }
  
  async _history() {
    try {
      const stats = await persistence.getStorageStats();
      const recordings = await persistence.getAllRecordings();
      
      return `RECORDING HISTORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Recordings: ${stats.recordingCount}
Total Storage: ${stats.totalSizeFormatted}

${recordings.length > 0 ? 'RECENT:' : 'No saved recordings.'}
${recordings.slice(0, 5).map(r => 
  `â€¢ ${r.name || 'Untitled'} (${r.frameCount}f, ${U.formatSize(r.size || 0)})`
).join('\n')}

Commands: Switch to History tab to manage`;
    } catch (err) {
      return 'History unavailable: ' + err.message;
    }
  }
  
  _session() {
    const state = playbackEngine.getState();
    return `CURRENT SESSION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Session ID: ${recordingSession.id || 'none'}
Session Name: ${recordingSession.name || 'none'}
Started: ${recordingSession.startTime ? new Date(recordingSession.startTime).toLocaleString() : 'never'}
Dirty: ${recordingSession.isDirty ? 'Yes (unsaved changes)' : 'No'}

PLAYBACK ENGINE
â€¢ Loaded: ${state.totalFrames} frames
â€¢ Current: F${state.currentFrame}
â€¢ Playing: ${state.isPlaying ? 'Yes' : 'No'}
â€¢ Speed: ${state.speed}x

Commands: play, save`;
  }
  
  _perf() {
    const stats = perfMonLegacy.getStats();
    const lazyStats = lazyCompute.getStats();
    
    return `PERFORMANCE STATS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FPS: ${stats.fps}
Frame Time: ${stats.frameTime}ms
Memory: ${stats.memory} MB
Samples: ${stats.samples}

LAZY COMPUTE
â€¢ Cached: ${lazyStats.cached}
â€¢ Pending: ${lazyStats.pending}

INDEX
â€¢ Indexed Frames: ${symbolicIndex.temporal.length}
â€¢ Unique Hashes: ${symbolicIndex.byHash.size}`;
  }
  
  _help() {
    return `VIRECAI v2.27 QUERY COMMANDS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
OVERVIEW
  overview    Full capture summary
  stats       Detailed statistics
  export      Export information

FRAMES
  wh          Current frame WH analysis
  wh frame N  WH for specific frame
  frame N     Full frame details
  first       First captured frame
  last        Most recent frame

ANALYSIS
  theory      11-theory analysis
  entropy     Information theory detail
  phase       Thermodynamic phase info
  causal      Causal inferences
  pattern     Detected patterns

DIVE (inception)
  dive what   What classifications
  dive where  Location history
  dive when   Temporal analysis
  dive why    Causal chains
  dive how    Process analysis

v2.26 ARCHITECTURE
  scenes      Scene hierarchy summary
  moments     Moment capsule analysis
  index       Symbolic index stats
  compress    Compression statistics
  timeline    Event timeline
  diff        Symbolic diff summary
  attention   Attention map analysis

FIND (enhanced search)
  find high      High entropy frames
  find low       Low entropy frames
  find motion    High motion frames
  find bright    Bright frames
  find dark      Dark frames
  find outliers  Anomalous frames
  find trans     Transition frames
  similar N      Frames similar to N
  near N         Frames near N (Â±5)
  search <word>  Text search events
  phases         Phase distribution
  tags           Custom tags

v2.26 PLAYBACK & ANALYTICS
  play        Open frame viewer
  compare     Compare two frames
  analytics   Open analytics dashboard
  graph       Metrics graph
  filmstrip   Frame thumbnail view
  clip        Export frame range
  report      Generate analysis report
  annotate    View annotations
  tags        View quick tags
  bookmarks   View bookmarks
  markers     View timeline markers
  detect      Auto-detect markers
  heatmap     Toggle heatmap overlay
  vsearch X   Visual search frames
  history     Recording history
  session     Current session info
  perf        Performance stats

VISUAL SEARCH (vsearch)
  vsearch tag:important  Frames with tag
  vsearch scene:bright   Frames by scene type
  vsearch entropy>0.7    High entropy frames

SYMBOLIC INTELLIGENCE (v2.26)
  mesh        Symbol mesh network graph
  chains      Causal chain timeline
  symbols     Symbol statistics
  causal      Causal analysis summary
  mfidel      Ge'ez fidel encoding
  narrative   Generate text description

DEEP EXPLORATION (v2.26)
  dive        Open InceptaDive explorer
  dive WHAT   Dive into WHAT dimension
  dive WHY    Dive into WHY (causal)
  ontology    Symbol hierarchy browser
  sql / query Symbolic query language

SENSORY VISUALIZATION (v2.26)
  audio       Audio waveform display
  motion      Motion trajectory overlay
  mullu       Open Mullu export panel
  export mullu  Download .mullu file
  perf        Toggle performance monitor

AI INTELLIGENCE (v2.26)
  patterns    AI pattern detection
  anomalies   Detect anomalies
  highlights  Find key moments
  timeline    Smart timeline view

RECORDING (v2.26)
  record      Start/resume recording
  pause       Pause recording (keep frames)
  resume      Resume paused recording
  stop        Stop recording completely
  new         Start new recording (confirm if unsaved)
  status      Show recording state & stats

CLIP EDITOR (v2.26)
  clips       Open clip editor
  edit        Open clip editor
  create clip Create clip from selection
  auto clips  Auto-detect clips from scenes

ANNOTATIONS (v2.26)
  timeline    Open annotation timeline
  annotations Open annotation timeline
  add marker  Add marker at current frame
  chapter     Add chapter marker
  important   Add important marker
  next marker Go to next marker
  prev marker Go to previous marker
  notes       Open notes panel
  clear markers  Clear all markers
  import scenes  Import scenes as regions
  export annotations  Export annotations
  marker stats  Show marker statistics

UNDO/REDO (v2.26)
  undo        Undo last action
  redo        Redo last undone action
  history     Open history panel
  clear history  Clear edit history

BATCH OPERATIONS (v2.26)
  select all clips     Select all clips
  select all markers   Select all markers
  clear selection      Clear selection
  batch delete         Delete selected items
  generate chapters    Create chapters from scenes
  generate markers N   Create markers every N frames

EXPORT (v2.26)
  export          Open export panel
  export mullu    Export as Mullu package
  export json     Export as JSON data
  export csv      Export as CSV metadata
  export report   Export analysis report
  formats         Show available formats

DATA MANAGEMENT (v2.26)
  data        Open data manager
  recordings  List saved recordings
  save        Save current recording
  autosave    Toggle auto-save
  storage     Show storage usage
  recover     Recover draft

CAMERA (v2.26)
  camera      Open camera settings
  resolution  Set resolution (sd/hd/fhd/4k)
  fps N       Set frame rate (15/24/30/60)
  flip        Toggle front/back camera
  zoom N      Set zoom level
  torch       Toggle flashlight

PROJECT MANAGEMENT (v2.26)
  projects    Open project browser
  new project Create new project
  save project  Save current project
  export project  Export project file
  templates   Browse templates
  project info  Show project info

SHARE & COLLABORATION (v2.26)
  share       Open share panel
  collaborate Open share panel
  comments    Open comments panel
  create share  Create share link
  add collaborator  Add team member

GLOBAL SEARCH (v2.26)
  search      Open global search
  find        Open global search
  search X    Search for X
  saved searches  View saved searches
  clear search history  Clear history

DIAGNOSTICS & HARDENING (v2.26)
  diagnostics Run full system check
  health      Quick health summary
  memory      Check memory status
  cleanup     Force memory cleanup
  integrity   Check data integrity
  repair      Repair data issues
  validate    Validate project data
  states      View state history
  autosave    Auto-save status
  force save  Force auto-save
  clear backups  Clear auto-save backups

MENU & NAVIGATION (v2.26)
  menu        Open main menu
  dashboard   Open dashboard / home
  home        Open dashboard
  info        System information
  about       About VIRECAI
  version     Show version info

UX & TOOLS (v2.26)
  notifications  Toggle notification panel
  floating    Toggle floating toolbar
  toolbar     Toggle floating toolbar
  minimap     Show timeline minimap
  star        Show starred projects
  starred     Show starred projects
  recent      Show recent actions
  actions     Show recent actions
  layout X    Switch layout (recording/editing/analysis)
  palette     Show symbol palette
  wh          WH Query Builder
  presets     Export presets

SYSTEM (v2.26)
  help        Show keyboard shortcuts
  shortcuts   Open keyboard cheatsheet
  keys        Open keyboard cheatsheet
  theme       Cycle dark/light/midnight
  tour        Start onboarding tutorial
  perf        Toggle performance monitor
  performance Show performance report
  a11y        Check accessibility status

RECORDING SHORTCUTS
  Space       Record â†’ Pause â†’ Resume
  Escape      Stop recording completely
  Ctrl+S      Save recording
  Ctrl+E      Open export panel
  
EDITING SHORTCUTS
  Ctrl+Z      Undo
  Ctrl+Y      Redo
  Ctrl+H      History panel
  Ctrl+P      Project browser
  Ctrl+N      New project
  Ctrl+Shift+S  Share panel
  Ctrl+K      Global search
  Ctrl+F      Global search
  Alt+M       Toggle menu
  Alt+D       Dashboard
  Alt+I       Info panel
  ?           Keyboard cheatsheet
  
PANEL SHORTCUTS
  P=playback  C=compare  A=analytics
  S=mesh  D=chains  Shift+N=notes
  I=dive  O=ontology  Q=query
  U=audio  J=motion  E=mullu
  V=camera  X=clips  Z=timeline
  Y=patterns  G=data  M=marker
  W=WH  T=theory  L=theme
  
PLAYBACK KEYS
  Space=play/pause  â†â†’=prev/next
  Home=start  End=end  M=marker`;
  }
  
  _entropy(c) {
    const frames = c.frames.filter(f => f.theoretical?.information);
    if (frames.length === 0) return 'No entropy data available.';
    
    const entropies = frames.map(f => f.theoretical.information.entropy.total);
    const novelties = frames.map(f => f.theoretical.information.novelty || 0);
    
    return `INFORMATION THEORY ANALYSIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frames analyzed: ${frames.length}

ENTROPY (H)
â€¢ Min:  ${Math.min(...entropies).toFixed(3)}
â€¢ Max:  ${Math.max(...entropies).toFixed(3)}
â€¢ Avg:  ${U.mean(entropies).toFixed(3)}
â€¢ StdDev: ${U.stdDev(entropies).toFixed(3)}

NOVELTY
â€¢ Min:  ${Math.min(...novelties).toFixed(3)}
â€¢ Max:  ${Math.max(...novelties).toFixed(3)}
â€¢ Avg:  ${U.mean(novelties).toFixed(3)}

Interpretation:
${U.mean(entropies) > 0.7 ? 'â€¢ High entropy: Complex, information-rich scene' :
  U.mean(entropies) > 0.4 ? 'â€¢ Medium entropy: Balanced information content' :
  'â€¢ Low entropy: Simple, uniform scene'}`;
  }
  
  _phase(c) {
    const frames = c.frames.filter(f => f.theoretical?.thermodynamics);
    if (frames.length === 0) return 'No phase data available.';
    
    const phases = frames.map(f => f.theoretical.thermodynamics.phase);
    const phaseCounts = phases.reduce((acc, p) => { acc[p] = (acc[p] || 0) + 1; return acc; }, {});
    const temps = frames.map(f => f.theoretical.thermodynamics.temperature);
    const orders = frames.map(f => f.theoretical.thermodynamics.orderParameter);
    
    return `THERMODYNAMIC PHASE ANALYSIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frames analyzed: ${frames.length}

PHASE DISTRIBUTION
${Object.entries(phaseCounts).map(([p, n]) => `â€¢ ${p}: ${n} (${((n/frames.length)*100).toFixed(0)}%)`).join('\n')}

TEMPERATURE
â€¢ Min:  ${Math.min(...temps).toFixed(4)}
â€¢ Max:  ${Math.max(...temps).toFixed(4)}
â€¢ Avg:  ${U.mean(temps).toFixed(4)}

ORDER PARAMETER
â€¢ Min:  ${Math.min(...orders).toFixed(3)}
â€¢ Max:  ${Math.max(...orders).toFixed(3)}
â€¢ Avg:  ${U.mean(orders).toFixed(3)}

Current: ${phases[phases.length-1]?.toUpperCase() || 'unknown'}`;
  }
  
  _stats(c) {
    const framesWithTheory = c.frames.filter(f => f.theoretical);
    const anomalies = c.frames.reduce((sum, f) => sum + (f.anomalies?.length || 0), 0);
    
    return `DETAILED STATISTICS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CAPTURE
â€¢ Total Frames:    ${c.frames.length}
â€¢ Total Symbols:   ${c.symbols.size}
â€¢ Total Relations: ${c.totalRelations}
â€¢ Total Size:      ${U.formatSize(c.totalSize)}

ANALYSIS
â€¢ Theoretical:     ${framesWithTheory.length}/${c.frames.length} (${((framesWithTheory.length/c.frames.length)*100).toFixed(0)}%)
â€¢ Anomalies:       ${anomalies}
â€¢ Causal Infer:    ${c.getCausalSummary().totalInferences}
â€¢ Patterns:        ${c.getCausalSummary().totalPatterns}

PERFORMANCE
â€¢ Sync Quality:    ${(c.metrics.avgSyncQuality*100).toFixed(0)}%
â€¢ Uncertainty:     ${(c.metrics.avgUncertainty*100).toFixed(1)}%
â€¢ Dropped Frames:  ${c.metrics.droppedFrames}

QUALITY SCORE: ${c.getValidation().score}%`;
  }
  
  _exportInfo(c) {
    const vrcSize = JSON.stringify(c.toVRC()).length;
    return `EXPORT INFORMATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Format:     .vrc (VIRECAI Reality Container)
Estimated:  ${U.formatSize(vrcSize)}

CONTENTS
â€¢ ${c.frames.length} frames
â€¢ ${c.symbols.size} symbols
â€¢ ${c.totalRelations} relations
â€¢ 11-theory analysis per frame
â€¢ Causal chain data
â€¢ WH semantic metadata

Click ðŸ“¥ Export Reality to download.`;
  }
  
  _theory(c) {
    const framesWithTheory = c.frames.filter(f => f.theoretical);
    const summary = c.getTheoreticalSummary();
    const analyzerSummary = theoreticalAnalyzer.getSummary();
    
    if (framesWithTheory.length === 0 && (!analyzerSummary || analyzerSummary.totalAnalyses === 0)) {
      return `THEORETICAL ANALYSIS â€” v2.26
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ No theoretical data found!

Frames captured: ${c.frames.length}
Frames with theory: ${framesWithTheory.length}
Analyzer history: ${analyzerSummary?.totalAnalyses || 0}

ðŸ’¡ Enable debug mode in console:
   VIRECAI_DEBUG(true)`;
    }
    
    const lastTheory = framesWithTheory.length > 0 ? framesWithTheory[framesWithTheory.length - 1].theoretical : null;
    
    return `THEORETICAL ANALYSIS (11 Theories)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frames analyzed: ${framesWithTheory.length}/${c.frames.length}
Coverage: ${((framesWithTheory.length / c.frames.length) * 100).toFixed(0)}%

AVERAGES:
â€¢ Score (Î˜):     ${summary?.avgScore?.toFixed(1) || 'â€”'}
â€¢ Entropy (H):   ${summary?.avgEntropy?.toFixed(3) || 'â€”'}
â€¢ Continuity:    ${summary?.avgContinuity?.toFixed(3) || 'â€”'}
â€¢ Stability:     ${summary?.avgStability?.toFixed(3) || 'â€”'}

LAST FRAME (#${lastTheory?.frameIndex || 'â€”'}):
â€¢ Score:         ${lastTheory?.theoreticalScore || 'â€”'}
â€¢ Info Entropy:  ${lastTheory?.information?.entropy?.total?.toFixed(3) || 'â€”'}
â€¢ Novelty:       ${lastTheory?.information?.novelty?.toFixed(3) || 'â€”'}
â€¢ Topology:      ${lastTheory?.topology?.continuity?.toFixed(3) || 'â€”'}
â€¢ Symmetry:      ${lastTheory?.symmetry?.radialSymmetry?.toFixed(3) || 'â€”'}
â€¢ Phase:         ${lastTheory?.thermodynamics?.phase || 'â€”'}

ANALYZER: ${analyzerSummary?.totalAnalyses || 0} analyses

Click ðŸ“ Theory card for details.`;
  }
  _overview(c) {
    const v = c.getValidation();
    const causal = c.getCausalSummary();
    const elapsed = c.frames.length > 0 ? c.frames[c.frames.length - 1].timestamp : 0;
    const theory = c.getTheoreticalSummary();
    const framesWithTheory = c.frames.filter(f => f.theoretical).length;
    const compression = c.getCompressionStats();
    const scenes = c.getSceneSummary();
    const indexStats = c.getIndexStats();
    
    return `VIRECAI v2.27 â€” REALITY CAPTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Mode:       ${c.mode.toUpperCase()}
Frames:     ${c.frames.length}
Symbols:    ${c.symbols.size}
Relations:  ${c.totalRelations}
Size:       ${U.formatSize(c.totalSize)}
Duration:   ${U.formatTime(elapsed)}
Score:      ${v.score}%

ARCHITECTURE (v2.26)
â€¢ Scenes:      ${scenes.length}
â€¢ Moments:     ${c.moments.length}
â€¢ Compression: ${compression.ratio.toFixed(1)}x
â€¢ Events:      ${eventStore.events.length}

SYMBOLIC INDEX
â€¢ High entropy: ${indexStats.entropyDistribution.high}
â€¢ High motion:  ${indexStats.motionDistribution.high}
â€¢ Scene types:  ${indexStats.sceneTypes}

CAUSAL REASONING
â€¢ Inferences: ${causal.totalInferences}
â€¢ Patterns:   ${causal.totalPatterns}

THEORETICAL (11 theories)
â€¢ Analyzed: ${framesWithTheory}/${c.frames.length}
â€¢ Score (Î˜): ${theory?.avgScore?.toFixed(0) || 'â€”'}

QUALITY
â€¢ Sync: ${(c.metrics.avgSyncQuality*100).toFixed(0)}% | Ïƒ: ${(c.metrics.avgUncertainty*100).toFixed(1)}%

Type 'help' for all v2.26 commands`;
  }
  _whCurrent(c) { return this._whFrame(c, c.frames.length - 1); }
  _whFrame(c, idx) {
    const f = c.frames[idx];
    if (!f) return `Frame ${idx} not found.`;
    return `WH ANALYSIS â€” Frame ${idx}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WHAT:     ${f.wh.what || 'â€”'}
WHERE:    ${f.wh.where || 'â€”'}
WHEN:     ${f.wh.when || 'â€”'}
WHY:      ${f.wh.why || 'â€”'}
HOW:      ${f.wh.how || 'â€”'}
BECAUSE:  ${f.wh.because || 'â€”'}

â€¢ Layers:      ${f.layers.size}
â€¢ Inferences:  ${f.causalInferences.length}
â€¢ Patterns:    ${f.patterns.length}
â€¢ Uncertainty: ${(f.getFrameUncertainty()*100).toFixed(1)}%`;
  }
  _dive(c, field) {
    const frames = c.frames.slice(-20);
    const values = frames.map(f => f.wh[field]).filter(Boolean);
    const unique = [...new Set(values)];
    return `INCEPTION DIVE: ${field.toUpperCase()}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Last ${frames.length} frames

UNIQUE VALUES (${unique.length}):
${unique.map(v => `â€¢ ${v}`).join('\n') || 'â€¢ (none)'}

DISTRIBUTION:
${unique.map(v => `â€¢ ${v}: ${values.filter(x=>x===v).length} frames`).join('\n') || 'â€¢ (none)'}`;
  }
  _causal(c) {
    const s = c.getCausalSummary();
    return `CAUSAL REASONING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Inferences: ${s.totalInferences}
Patterns:   ${s.totalPatterns}

RECENT:
${s.recentInferences.slice(-5).map(i => `F${i.frameIndex}: ${i.type} (${(i.confidence*100).toFixed(0)}%)`).join('\n') || 'â€¢ None'}`;
  }
  _patterns(c) {
    const pats = c.frames.flatMap(f => f.patterns);
    return `PATTERNS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total: ${pats.length}

${pats.slice(-5).map(p => `â€¢ ${p.type} (F${p.detectedAt})`).join('\n') || 'â€¢ None'}`;
  }
  _frame(c, idx) {
    const f = c.frames[idx];
    if (!f) return `Frame ${idx} not found.`;
    return `FRAME ${idx}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Timestamp: ${f.timestamp}ms
Signature: ${f.signature?.slice(0,12)}...
Merkle:    ${f.merkleRoot}
Layers:    ${Array.from(f.layers.keys()).join(', ')}
Sync:      ${((f.syncQuality?.quality||0)*100).toFixed(0)}%
Causal:    ${f.causalInferences.length} inferences`;
  }
  _sensors() {
    const h = this.orch.getSensorHealth();
    const summary = SensorState.getSummary();
    const profile = sensorController.getActiveProfile();
    
    // Get detailed stats from monitor
    let statsOutput = '';
    ['video', 'audio', 'visual', 'gps', 'motion', 'env'].forEach(sensor => {
      const stats = sensorMonitor.getStats(sensor);
      const state = SensorState.get(sensor);
      const health = h[sensor] || {};
      const policy = sensorController.checkPolicy(sensor);
      
      const statusIcon = state.status === 'active' ? 'âœ“' :
                         state.status === 'stale' ? 'â³' :
                         state.status === 'degraded' ? 'âš ' :
                         state.status === 'denied' || state.status === 'failed' ? 'âœ—' : 'â—‹';
      
      statsOutput += `
${statusIcon} ${sensor.toUpperCase()}
  Status:     ${state.status} (${state.health})
  Permission: ${state.permission}
  Updates:    ${health.updateCount || 0}
  Errors:     ${health.errorCount || 0}
  Quality:    ${((health.quality || 0) * 100).toFixed(0)}%
  Uncertainty: Â±${((health.uncertainty || 0) * 100).toFixed(1)}%
  ${stats ? `Value Range: ${stats.min?.toFixed(3)} â€” ${stats.max?.toFixed(3)}` : 'No data yet'}
  ${policy.compliant ? 'âœ“ Policy OK' : 'âš  ' + policy.issues?.join(', ')}
`;
    });
    
    return `SENSOR SYSTEM (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Profile: ${profile?.name || 'Custom'}
Active: ${summary.active}/${summary.total - summary.off}
Health: ${summary.healthPercent}%

â”€â”€â”€ SENSOR STATUS â”€â”€â”€${statsOutput}
â”€â”€â”€ QUICK COMMANDS â”€â”€â”€
  profile X   Apply profile (full/lite/indoor/outdoor)
  calibrate   Open calibration panel
  monitor     Toggle live monitor
  reset       Reset all sensors`;
  }
  _uncertainty(c) {
    const frames = c.frames;
    const uncs = frames.map(f => f.getFrameUncertainty());
    return `MEASUREMENT UNCERTAINTY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Average: ${(U.mean(uncs)*100).toFixed(2)}%
Min:     ${(Math.min(...uncs)*100).toFixed(2)}%
Max:     ${(Math.max(...uncs)*100).toFixed(2)}%

TREND (last 10):
${frames.slice(-10).map(f => `F${f.index}: ${(f.getFrameUncertainty()*100).toFixed(1)}%`).join('\n')}`;
  }
  
  _policyStatus() {
    const sensors = ['video', 'audio', 'visual', 'gps', 'motion', 'env'];
    let output = `SENSOR POLICY COMPLIANCE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
    
    let allCompliant = true;
    sensors.forEach(sensor => {
      const result = sensorController.checkPolicy(sensor);
      const icon = result.compliant ? 'âœ“' : 'âœ—';
      allCompliant = allCompliant && result.compliant;
      
      output += `\n${icon} ${sensor.toUpperCase()}`;
      if (result.policy) {
        output += `\n  Min Rate: ${result.policy.minUpdateRate || 'â€”'}Hz`;
        output += `\n  Max Latency: ${result.policy.maxLatency || 'â€”'}ms`;
        if (result.policy.requiredAccuracy) {
          output += `\n  Required Accuracy: ${result.policy.requiredAccuracy}m`;
        }
      }
      if (!result.compliant && result.issues) {
        result.issues.forEach(issue => {
          output += `\n  âš  ${issue}`;
        });
      }
    });
    
    output += `\n\nâ”€â”€â”€ SUMMARY â”€â”€â”€`;
    output += `\nOverall: ${allCompliant ? 'âœ“ All policies met' : 'âš  Some violations detected'}`;
    
    return output;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // v2.26 ARCHITECTURE QUERIES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  _scenes(c) {
    const scenes = c.getSceneSummary();
    if (scenes.length === 0) return 'No scenes detected yet. Keep recording!';
    
    return `SCENE HIERARCHY (v2.26 Enhanced)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Scenes: ${scenes.length}
Total Moments: ${c.moments.length}

${scenes.slice(-4).map((s) => `
â”Œâ”€ SCENE ${s.id + 1} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ Frames:     ${s.frames} (${s.frameCount || '?'} total)
â”‚ Moments:    ${s.moments}
â”‚ Keyframes:  ${s.keyframes?.join(', ') || 'none'}
â”‚ Type:       ${s.dominantType || 'mixed'}
â”‚ Tags:       ${s.tags?.join(', ') || 'none'}
â”‚ Entropy:    ${s.avgEntropy?.toFixed(3) || 'â€”'}
â”‚ Motion:     ${s.avgMotion?.toFixed(3) || 'â€”'}
â”‚ Luminance:  ${s.avgLuminance?.toFixed(3) || 'â€”'}
â”‚ Complexity: ${s.complexity?.toFixed(3) || 'â€”'}
â”‚ Stability:  ${s.stability?.toFixed(3) || 'â€”'}
â”‚ Events:     ${s.eventCount}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`).join('\n')}

Scene auto-tags: dark/bright, static/dynamic,
                 simple/complex, stable/turbulent`;
  }
  
  _moments(c) {
    const moments = c.moments.slice(-8);
    if (moments.length === 0) return 'No moments captured yet.';
    
    return `MOMENT CAPSULES (v2.26 Enhanced)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Moments: ${c.moments.length}
Current Moment: ${c.currentMoment?.id || 'none'}

RECENT MOMENTS:
${moments.map(m => {
  const summary = m.getSummary ? m.getSummary() : m;
  return `M${m.id}: F${m.startFrame}-${m.endFrame || '?'}
   ${m.frames?.length || '?'}f | Key:F${summary.keyframe || '?'} | ${m.events?.length || 0} events
   H=${summary.avgEntropy?.toFixed(2) || '?'} M=${summary.avgMotion?.toFixed(2) || '?'} Peak=${summary.peakMotion?.toFixed(2) || '?'}`;
}).join('\n')}

Moment = 1-3 sec micro-segment
â€¢ Keyframe = most informative frame
â€¢ Attention = focus regions computed`;
  }
  
  _index(c) {
    const stats = c.getIndexStats();
    
    return `SYMBOLIC INDEX (v2.26 Enhanced)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Indexed: ${stats.totalFrames} frames
Unique Hashes: ${stats.uniqueHashes}
Indexed Words: ${stats.indexedWords}

ENTROPY DISTRIBUTION
â€¢ High (>0.7):   ${stats.entropyDistribution.high} (${stats.totalFrames > 0 ? ((stats.entropyDistribution.high / stats.totalFrames) * 100).toFixed(0) : 0}%)
â€¢ Mid (0.4-0.7): ${stats.entropyDistribution.mid} (${stats.totalFrames > 0 ? ((stats.entropyDistribution.mid / stats.totalFrames) * 100).toFixed(0) : 0}%)
â€¢ Low (<0.4):    ${stats.entropyDistribution.low} (${stats.totalFrames > 0 ? ((stats.entropyDistribution.low / stats.totalFrames) * 100).toFixed(0) : 0}%)

MOTION DISTRIBUTION
â€¢ High (>0.3):   ${stats.motionDistribution.high}
â€¢ Mid (0.1-0.3): ${stats.motionDistribution.mid}
â€¢ Low (<0.1):    ${stats.motionDistribution.low}

LUMINANCE
â€¢ Bright: ${stats.luminanceDistribution?.bright || 0}
â€¢ Normal: ${stats.luminanceDistribution?.normal || 0}
â€¢ Dark:   ${stats.luminanceDistribution?.dark || 0}

SCENE TYPES: ${stats.sceneTypes}
${stats.sceneTypeBreakdown ? Object.entries(stats.sceneTypeBreakdown).slice(0, 4).map(([k, v]) => `â€¢ ${k}: ${v}`).join('\n') : ''}

PHASES: ${stats.phases}
${stats.phaseBreakdown ? Object.entries(stats.phaseBreakdown).map(([k, v]) => `â€¢ ${k}: ${v}`).join('\n') : ''}

EVENT TYPES: ${stats.eventTypes}
CUSTOM TAGS: ${stats.customTags}

Commands: find high/low/motion/bright/dark
          find outliers, find trans, near N`;
  }
  
  _compression(c) {
    const stats = c.getCompressionStats();
    
    return `DELTA COMPRESSION (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Original Frames: ${stats.originalFrames}
Keyframes: ${stats.keyframes}
Delta Frames: ${stats.deltaFrames}

Compression Ratio: ${stats.ratio.toFixed(2)}x
Est. Size Reduction: ${((1 - 1/stats.ratio) * 100).toFixed(0)}%

Keyframe Interval: 30 frames
Delta stores only changes:
â€¢ Visual motion delta
â€¢ Entropy delta
â€¢ Luminance delta
â€¢ New causal inferences
â€¢ Phase changes`;
  }
  
  _timeline(c) {
    const timeline = eventStore.getTimeline().slice(-20);
    if (timeline.length === 0) return 'No events recorded yet.';
    
    return `EVENT TIMELINE (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Events: ${eventStore.events.length}

RECENT EVENTS:
${timeline.map(e => `${new Date(e.time).toLocaleTimeString()} | ${e.type}${e.frame !== undefined ? ` (F${e.frame})` : ''}`).join('\n')}

Event sourcing enables:
â€¢ Time travel debugging
â€¢ State reconstruction
â€¢ Audit trail`;
  }
  
  _diffSummary(c) {
    const summary = c.getDiffSummary();
    if (!summary || summary.totalChanges === 0) return 'No diffs computed yet.';
    
    return `SYMBOLIC DIFF SUMMARY (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Changes: ${summary.totalChanges}
Avg Significance: ${summary.avgSignificance?.toFixed(3) || 'â€”'}

TRANSITIONS
â€¢ Scene Changes: ${summary.sceneChanges}
â€¢ Phase Transitions: ${summary.phaseTransitions}

Most Common Change: ${summary.mostCommonChange || 'none'}

Diff tracks semantic changes:
â€¢ Scene type shifts
â€¢ Entropy variations
â€¢ Lighting changes
â€¢ WH updates
â€¢ Causal events`;
  }
  
  _attention(c) {
    const lastFrame = c.frames[c.frames.length - 1];
    if (!lastFrame?.attention) return 'No attention data available.';
    
    const focus = lastFrame.attention.focusPoint;
    const regions = lastFrame.attention.getRegions(0.5);
    
    return `ATTENTION MAP (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Frame: ${lastFrame.index}

FOCUS POINT
â€¢ X: ${(focus.x * 100).toFixed(0)}%
â€¢ Y: ${(focus.y * 100).toFixed(0)}%
â€¢ Weight: ${(focus.weight * 100).toFixed(0)}%

HIGH ATTENTION REGIONS: ${regions.length}
${regions.slice(0, 3).map((r, i) => `Region ${i + 1}: ${r.length} cells`).join('\n')}

Attention based on:
â€¢ Edge strength (40%)
â€¢ Color saturation (30%)
â€¢ Center bias (30%)`;
  }
  
  _findByEntropy(c, level) {
    const frames = c.queryFrames({ entropy: level });
    
    return `FRAMES BY ENTROPY: ${level.toUpperCase()}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${frames.length} frames

${frames.length > 0 ? `Frame indices: ${frames.slice(0, 20).map(f => f.index).join(', ')}${frames.length > 20 ? '...' : ''}` : 'No frames match criteria.'}

Thresholds:
â€¢ High: entropy > 0.7
â€¢ Mid: 0.4 < entropy < 0.7
â€¢ Low: entropy < 0.4`;
  }
  
  _findByMotion(c) {
    const frames = c.queryFrames({ motion: 'high' });
    
    return `HIGH MOTION FRAMES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${frames.length} frames

${frames.length > 0 ? `Frame indices: ${frames.slice(0, 20).map(f => f.index).join(', ')}${frames.length > 20 ? '...' : ''}` : 'No high motion frames found.'}

Threshold: motionDelta > 0.3`;
  }
  
  _findByLuminance(c, level) {
    const frames = symbolicIndex.query({ luminance: level }).map(idx => c.frames[idx]).filter(Boolean);
    
    return `${level.toUpperCase()} FRAMES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${frames.length} frames

${frames.length > 0 ? `Frame indices: ${frames.slice(0, 20).map(f => f.index).join(', ')}${frames.length > 20 ? '...' : ''}` : `No ${level} frames found.`}

Thresholds:
â€¢ Bright: luminance > 0.65
â€¢ Normal: 0.25 < luminance < 0.65
â€¢ Dark: luminance < 0.25`;
  }
  
  _findOutliers(c) {
    const outliers = symbolicIndex.findOutliers(0.25);
    
    return `OUTLIER FRAMES (anomalies)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${outliers.length} outliers

${outliers.length > 0 ? outliers.slice(0, 15).map(o => 
  `F${o.index}: Î”H=${o.entropyDiff.toFixed(3)} Î”M=${o.motionDiff.toFixed(3)}`
).join('\n') : 'No outliers detected.'}

Outliers = frames differing significantly
from their temporal neighbors.
Threshold: Î” > 0.25`;
  }
  
  _findTransitions(c) {
    const transitions = symbolicIndex.findTransitions(0.2);
    
    return `TRANSITION FRAMES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${transitions.length} transitions

${transitions.length > 0 ? `Frame indices: ${transitions.slice(0, 30).join(', ')}${transitions.length > 30 ? '...' : ''}` : 'No transitions detected.'}

Transitions = frames with motion > 0.2
(scene boundaries, camera movement)`;
  }
  
  _findNear(c, frameIndex) {
    if (frameIndex >= c.frames.length) return `Frame ${frameIndex} does not exist.`;
    
    const near = symbolicIndex.findNear(frameIndex, 5);
    const frames = near.map(idx => c.frames[idx]).filter(Boolean);
    
    return `FRAMES NEAR F${frameIndex}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Radius: Â±5 frames

${frames.map(f => {
  const data = symbolicIndex.frameData.get(f.index);
  return `F${f.index}: H=${data?.entropy?.toFixed(2) || 'â€”'} M=${data?.motion?.toFixed(2) || 'â€”'} ${data?.sceneType || ''}`;
}).join('\n')}`;
  }
  
  _searchFrames(c, query) {
    const results = symbolicIndex.query({ text: query });
    
    return `SEARCH: "${query}"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${results.length} frames

${results.length > 0 ? `Frame indices: ${results.slice(0, 20).join(', ')}${results.length > 20 ? '...' : ''}` : 'No frames match.'}

Search uses inverted index on
causal inference types.`;
  }
  
  _phases(c) {
    const stats = symbolicIndex.getStats();
    
    return `THERMODYNAMIC PHASES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Phases: ${stats.phases}

DISTRIBUTION:
${stats.phaseBreakdown ? Object.entries(stats.phaseBreakdown).map(([phase, count]) => 
  `â€¢ ${phase}: ${count} frames (${((count / c.frames.length) * 100).toFixed(0)}%)`
).join('\n') : 'No phase data.'}

Phases: ordered, disordered, critical
Based on statistical mechanics analysis.`;
  }
  
  _tags(c) {
    const stats = symbolicIndex.getStats();
    
    return `CUSTOM TAGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Tags: ${stats.customTags}

${stats.customTags > 0 ? Object.entries(symbolicIndex.byTag).map(([tag, frames]) => 
  `â€¢ ${tag}: ${frames.length} frames`
).join('\n') : 'No custom tags defined.'}

Use API to add tags:
symbolicIndex.tag([0,1,2], 'important')`;
  }
  
  _findSimilar(c, frameIndex) {
    if (frameIndex >= c.frames.length) return `Frame ${frameIndex} does not exist.`;
    
    const similar = c.findSimilar(frameIndex, 5);
    
    return `SIMILAR FRAMES TO F${frameIndex}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Found: ${similar.length} similar frames

${similar.length > 0 ? similar.slice(0, 10).map(s => `F${s.frame.index}: distance ${s.distance}`).join('\n') : 'No similar frames found.'}

Similarity: dHash hamming distance
Threshold: â‰¤ 5 different bits`;
  }
  
  _events(c) {
    const byType = {};
    eventStore.events.forEach(e => {
      byType[e.type] = (byType[e.type] || 0) + 1;
    });
    
    return `EVENT STORE (v2.26)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Events: ${eventStore.events.length}

BY TYPE:
${Object.entries(byType).map(([type, count]) => `â€¢ ${type}: ${count}`).join('\n')}

Commands:
â€¢ timeline - Recent events
â€¢ diff - Change summary`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APPLICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const orch = new Orchestrator();
let queryEngine = null;
const app = { stream: null, video: null, vfCanvas: null, frameCanvas: null, facingMode: 'user', audioCtx: null, audioAnalyser: null, audioData: null, lastVF: null, showWH: false };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNIFIED SENSOR STATE MANAGER - Single Source of Truth
// Enhanced with: retry logic, staleness monitoring, graceful degradation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SensorState = {
  sensors: {
    video:  { enabled: true, required: true,  permission: 'prompt', health: 'init', hasData: false, lastUpdate: 0, note: '', retryCount: 0, maxRetries: 3 },
    audio:  { enabled: true, required: false, permission: 'prompt', health: 'init', hasData: false, lastUpdate: 0, note: '', retryCount: 0, maxRetries: 3 },
    visual: { enabled: true, required: true,  permission: 'granted', health: 'init', hasData: false, lastUpdate: 0, note: '', retryCount: 0, maxRetries: 0 },
    gps:    { enabled: true, required: false, permission: 'prompt', health: 'init', hasData: false, lastUpdate: 0, note: '', retryCount: 0, maxRetries: 5 },
    motion: { enabled: true, required: false, permission: 'prompt', health: 'init', hasData: false, lastUpdate: 0, note: '', retryCount: 0, maxRetries: 2 },
    env:    { enabled: true, required: false, permission: 'granted', health: 'init', hasData: false, lastUpdate: 0, note: 'Derived from video', retryCount: 0, maxRetries: 0 }
  },
  
  // Staleness timeouts per sensor (ms)
  timeouts: { video: 2000, audio: 2000, visual: 2000, gps: 60000, motion: 5000, env: 5000 },
  
  // UI update throttling
  lastUIUpdate: 0,
  uiUpdateInterval: 100,
  pendingUIUpdates: new Set(),
  
  // Staleness check interval
  stalenessCheckerId: null,
  
  // Initialize event listeners and staleness checker
  init() {
    // Listen to coordinator updates and auto-sync state
    bus.on('sensor:update', ({ name, data, timestamp }) => {
      if (this.sensors[name] && data) {
        this.dataReceived(name);
      }
    });
    
    // Listen to errors
    bus.on('sensor:error', ({ name, error }) => {
      if (this.sensors[name]) {
        this.handleError(name, error);
      }
    });
    
    // Start staleness checker (runs every 2 seconds)
    this.stalenessCheckerId = setInterval(() => this.checkStaleness(), 2000);
    
    // Process pending UI updates efficiently
    this.uiUpdateLoop();
    
    Log.ok('sensor', 'SensorState initialized with real-time sync');
  },
  
  // Cleanup
  destroy() {
    if (this.stalenessCheckerId) {
      clearInterval(this.stalenessCheckerId);
      this.stalenessCheckerId = null;
    }
  },
  
  // Check all sensors for staleness
  checkStaleness() {
    const now = U.timestamp();
    Object.entries(this.sensors).forEach(([name, s]) => {
      if (!s.enabled || s.permission === 'denied' || !s.hasData) return;
      
      const age = now - s.lastUpdate;
      const timeout = this.timeouts[name] || 5000;
      const wasActive = s.health === 'healthy';
      
      if (age > timeout && s.health !== 'stale') {
        s.health = 'stale';
        this.pendingUIUpdates.add(name);
        if (wasActive) {
          Log.warn('sensor', `${name} went stale (${Math.round(age/1000)}s old)`);
        }
      } else if (age <= timeout && s.health === 'stale') {
        s.health = 'healthy';
        this.pendingUIUpdates.add(name);
      }
    });
    
    // Update health summary badge
    this.updateHealthBadge();
  },
  
  // Update the sensor health summary badge
  updateHealthBadge() {
    const summary = this.getSummary();
    const badge = document.getElementById('sensor-health-badge');
    if (!badge) return;
    
    badge.textContent = `${summary.healthPercent}%`;
    badge.className = 'sensor-health-badge';
    
    if (summary.healthPercent >= 80) badge.classList.add('good');
    else if (summary.healthPercent >= 50) badge.classList.add('warn');
    else badge.classList.add('bad');
    
    badge.title = `Sensors: ${summary.active} active, ${summary.degraded} degraded, ${summary.failed} failed`;
  },
  
  // Throttled UI update loop
  uiUpdateLoop() {
    const now = U.timestamp();
    if (this.pendingUIUpdates.size > 0 && now - this.lastUIUpdate >= this.uiUpdateInterval) {
      this.pendingUIUpdates.forEach(sensor => {
        const status = this._deriveStatus(sensor);
        this._updateUI(sensor, status);
      });
      this.pendingUIUpdates.clear();
      this.lastUIUpdate = now;
      this.updateHealthBadge();
    }
    requestAnimationFrame(() => this.uiUpdateLoop());
  },
  
  // Update sensor state - SINGLE POINT OF UPDATE
  update(sensor, changes) {
    if (!this.sensors[sensor]) return;
    
    const s = this.sensors[sensor];
    const now = U.timestamp();
    
    // Apply changes
    if ('enabled' in changes) s.enabled = changes.enabled;
    if ('permission' in changes) s.permission = changes.permission;
    if ('health' in changes) s.health = changes.health;
    if ('hasData' in changes) s.hasData = changes.hasData;
    if ('note' in changes) s.note = changes.note;
    if (changes.hasData) {
      s.lastUpdate = now;
      s.retryCount = 0; // Reset retry count on success
    }
    
    // Queue UI update
    this.pendingUIUpdates.add(sensor);
    
    // Emit event for other systems
    const status = this._deriveStatus(sensor);
    bus.emit('sensor:state', { sensor, status, state: s });
    
    return status;
  },
  
  // Handle sensor error with retry logic
  handleError(sensor, error) {
    const s = this.sensors[sensor];
    if (!s) return;
    
    s.retryCount++;
    
    if (s.retryCount >= s.maxRetries && s.maxRetries > 0) {
      s.health = 'failed';
      s.note = `Failed after ${s.retryCount} attempts: ${error}`;
      Log.error('sensor', `${sensor} failed permanently: ${error}`);
    } else if (s.maxRetries > 0) {
      s.health = 'degraded';
      s.note = `Retry ${s.retryCount}/${s.maxRetries}: ${error}`;
      Log.warn('sensor', `${sensor} error (retry ${s.retryCount}): ${error}`);
      // Schedule retry
      setTimeout(() => this.retryInit(sensor), 2000 * s.retryCount);
    } else {
      s.health = 'failed';
      s.note = error;
    }
    
    this.pendingUIUpdates.add(sensor);
  },
  
  // Retry sensor initialization
  retryInit(sensor) {
    const s = this.sensors[sensor];
    if (!s || !s.enabled || s.health === 'healthy' || s.permission === 'denied') return;
    
    Log.info('sensor', `Retrying ${sensor} initialization...`);
    
    switch(sensor) {
      case 'gps': initGPS(); break;
      case 'motion': initMotion(); break;
      case 'audio': initAudio(); break;
    }
  },
  
  // Derive status from state
  _deriveStatus(sensor) {
    const s = this.sensors[sensor];
    
    if (!s.enabled) return 'off';
    if (s.permission === 'denied') return 'denied';
    if (s.health === 'failed') return 'failed';
    if (s.health === 'stale') return 'stale';
    if (s.health === 'degraded') return 'degraded';
    if (s.health === 'init' && !s.hasData) return 'pending';
    if (s.hasData && (s.health === 'healthy' || s.permission === 'granted')) return 'active';
    if (s.hasData) return 'degraded';
    
    return 'pending';
  },
  
  // Get current status
  getStatus(sensor) {
    return this._deriveStatus(sensor);
  },
  
  // Get full state
  get(sensor) {
    return { ...this.sensors[sensor], status: this._deriveStatus(sensor) };
  },
  
  // Get summary of all sensors
  getSummary() {
    const summary = { active: 0, degraded: 0, failed: 0, off: 0, total: 0 };
    Object.keys(this.sensors).forEach(name => {
      const status = this._deriveStatus(name);
      summary.total++;
      if (status === 'active') summary.active++;
      else if (status === 'degraded' || status === 'stale') summary.degraded++;
      else if (status === 'failed' || status === 'denied') summary.failed++;
      else if (status === 'off') summary.off++;
    });
    summary.healthPercent = Math.round((summary.active / (summary.total - summary.off)) * 100) || 0;
    return summary;
  },
  
  // Update ALL UI elements for a sensor
  _updateUI(sensor, status) {
    // 1. Header status dot
    const dot = document.getElementById(`dot-${sensor}`);
    if (dot) {
      dot.classList.remove('active', 'denied', 'off', 'pending', 'stale', 'degraded');
      const dotClass = status === 'active' ? 'active' : 
                       status === 'denied' || status === 'failed' ? 'denied' :
                       status === 'off' ? 'off' :
                       status === 'stale' || status === 'degraded' ? 'stale' : 'pending';
      dot.classList.add(dotClass);
    }
    
    // 2. Sensor card health indicator
    const healthEl = document.getElementById(`health-${sensor}`);
    if (healthEl) {
      healthEl.classList.remove('healthy', 'degraded', 'stale', 'failed', 'init');
      const healthClass = status === 'active' ? 'healthy' :
                          status === 'stale' || status === 'degraded' ? 'degraded' :
                          status === 'denied' || status === 'failed' ? 'failed' : 'init';
      healthEl.classList.add(healthClass);
    }
    
    // 3. Sensor card border
    const card = document.getElementById(`card-${sensor}`);
    if (card) {
      card.classList.remove('healthy', 'degraded', 'stale', 'failed', 'disabled', 'clickable');
      if (status === 'active') card.classList.add('healthy');
      else if (status === 'stale' || status === 'degraded') card.classList.add('degraded');
      else if (status === 'off') card.classList.add('disabled');
      else if (status === 'denied' || status === 'failed') {
        card.classList.add('failed', 'clickable');
        card.onclick = openSettings;
      }
    }
    
    // 4. Settings panel status badge (if open)
    const statusEl = document.getElementById(`status-${sensor}`);
    if (statusEl) {
      const labels = { active: 'Active', denied: 'Denied', off: 'Off', stale: 'Stale', pending: 'Pending', failed: 'Failed', degraded: 'Weak' };
      statusEl.textContent = labels[status] || status;
      statusEl.className = 'sensor-toggle-status';
      if (status === 'active') statusEl.classList.add('granted');
      else if (status === 'denied' || status === 'failed') statusEl.classList.add('denied');
      else if (status === 'stale' || status === 'degraded') statusEl.classList.add('prompt');
      else statusEl.classList.add('off');
    }
    
    // 5. Settings panel note
    const noteEl = document.getElementById(`note-${sensor}`);
    if (noteEl) {
      noteEl.textContent = this.sensors[sensor].note || '';
    }
    
    // 6. GPS manual location section
    if (sensor === 'gps') {
      const manualWrap = document.getElementById('manual-location-wrap');
      if (manualWrap) {
        manualWrap.classList.toggle('visible', status === 'denied' || status === 'failed' || status === 'stale');
      }
    }
  },
  
  // Toggle sensor on/off
  toggle(sensor, enabled) {
    if (this.sensors[sensor]?.required) return false;
    
    this.update(sensor, { enabled, note: enabled ? '' : 'Disabled by user' });
    
    if (!enabled) {
      const valEl = document.getElementById(`val-${sensor}`);
      if (valEl) valEl.textContent = 'Off';
    }
    
    return true;
  },
  
  // Mark sensor as having received data - called automatically via EventBus
  dataReceived(sensor) {
    if (!this.sensors[sensor]) return;
    
    // Only update if permission allows
    if (this.sensors[sensor].permission !== 'denied') {
      this.update(sensor, { hasData: true, health: 'healthy', permission: 'granted' });
    }
  },
  
  // Mark sensor permission
  setPermission(sensor, permission, note = '') {
    this.update(sensor, { permission, note });
  },
  
  // Mark sensor error
  setError(sensor, note = '') {
    this.handleError(sensor, note);
  }
};

// Keep old function name for compatibility but route to unified system
function updateSensorStatus(sensor, status, note = '') {
  const mapping = {
    'granted': { permission: 'granted', health: 'healthy', hasData: true },
    'denied': { permission: 'denied', health: 'failed' },
    'off': { enabled: false },
    'manual': { permission: 'granted', health: 'healthy', hasData: true },
    'prompt': { permission: 'prompt' },
    'stale': { health: 'stale' }
  };
  
  const changes = mapping[status] || {};
  if (note) changes.note = note;
  
  SensorState.update(sensor, changes);
}

function toggleSensor(sensor, enabled) {
  if (!SensorState.toggle(sensor, enabled)) return;
  
  const config = orch.coordinator.sensors.get(sensor);
  if (config) config.enabled = enabled;
  
  if (enabled) {
    // Re-initialize sensor
    if (sensor === 'audio' && !app.audioCtx) initAudio();
    if (sensor === 'gps') initGPS();
    if (sensor === 'motion') initMotion();
    if (sensor === 'env') SensorState.update('env', { hasData: true, health: 'healthy' });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.10 SENSOR CONTROL FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function applySensorProfile(profileName) {
  const success = sensorController.applyProfile(profileName);
  
  if (success) {
    // Update UI buttons
    document.querySelectorAll('.sensor-profile-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.profile === profileName);
    });
    
    // Reinitialize sensors based on profile
    const profile = sensorController.profiles.get(profileName);
    if (profile) {
      profile.sensors.forEach((config, sensor) => {
        if (config.enabled && !SensorState.sensors[sensor].hasData) {
          // Try to init sensor if not yet initialized
          switch(sensor) {
            case 'audio': initAudio(); break;
            case 'gps': initGPS(); break;
            case 'motion': initMotion(); break;
          }
        }
      });
    }
    
    Log.ok('sensor', `Profile applied: ${profileName}`);
    updatePolicyStatus();
  }
}

function resetAllSensors() {
  ['audio', 'gps', 'motion', 'env'].forEach(sensor => {
    sensorMonitor.reset(sensor);
  });
  
  // Clear monitor history
  sensorMonitor.history.forEach((history, sensor) => {
    history.length = 0;
  });
  
  // Re-initialize all sensors
  if (SensorState.sensors.audio.enabled) initAudio();
  if (SensorState.sensors.gps.enabled) initGPS();
  if (SensorState.sensors.motion.enabled) initMotion();
  if (SensorState.sensors.env.enabled) {
    SensorState.update('env', { hasData: true, health: 'healthy' });
  }
  
  Log.ok('sensor', 'All sensors reset');
}

function updatePolicyStatus() {
  const container = document.getElementById('policy-status');
  if (!container) return;
  
  const sensors = ['video', 'audio', 'gps', 'motion'];
  let html = '';
  
  sensors.forEach(sensor => {
    const result = sensorController.checkPolicy(sensor);
    const className = result.compliant ? 'compliant' : 'violation';
    html += `<div class="policy-item ${className}">
      <span class="policy-dot"></span>
      <span>${sensor}</span>
    </div>`;
  });
  
  container.innerHTML = html;
}

function initSensorDashboard() {
  // Start monitoring
  sensorMonitor.start();
  
  // Set up profile buttons
  document.querySelectorAll('.sensor-profile-btn').forEach(btn => {
    btn.onclick = () => applySensorProfile(btn.dataset.profile);
  });
  
  // Initial policy check
  updatePolicyStatus();
  
  Log.ok('sensor', 'Sensor dashboard initialized');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.11 PANEL FUNCTIONS â€” Symbol Mesh, Causal Chains, Mfidel, Narrative
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openMeshPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('mesh', 'No data to visualize');
    return;
  }
  
  symbolMesh.buildFromContainer(container);
  symbolMesh.render();
  
  document.getElementById('mesh-backdrop').classList.add('open');
  document.getElementById('mesh-panel').classList.add('open');
}

function closeMeshPanel() {
  document.getElementById('mesh-backdrop').classList.remove('open');
  document.getElementById('mesh-panel').classList.remove('open');
}

function openChainPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('chain', 'No data to visualize');
    return;
  }
  
  causalChain.buildFromContainer(container);
  causalChain.render();
  
  document.getElementById('chain-backdrop').classList.add('open');
  document.getElementById('chain-panel').classList.add('open');
}

function closeChainPanel() {
  document.getElementById('chain-backdrop').classList.remove('open');
  document.getElementById('chain-panel').classList.remove('open');
}

function openMfidelPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('mfidel', 'No data to encode');
    return;
  }
  
  // Generate signature
  const signature = mfidelMapper.getSignature(container);
  document.getElementById('mfidel-signature').textContent = signature || 'â€”';
  
  // Generate full encoding (truncated for display)
  const fullEncoding = mfidelMapper.encodeContainer(container);
  const displayEncoding = fullEncoding.length > 100 ? 
    fullEncoding.slice(0, 100) + '...' : fullEncoding;
  document.getElementById('mfidel-encoding').textContent = displayEncoding || 'â€”';
  
  // Generate stats
  const stats = mfidelMapper.getStats(fullEncoding);
  const statsHtml = Object.entries(stats)
    .slice(0, 8)
    .map(([key, count]) => `
      <div class="mfidel-stat">
        <span class="mfidel-stat-label">${key}</span>
        <span class="mfidel-stat-value">${count}</span>
      </div>
    `).join('');
  document.getElementById('mfidel-stats').innerHTML = statsHtml || '<div class="mfidel-stat">No symbols</div>';
  
  document.getElementById('mfidel-backdrop').classList.add('open');
  document.getElementById('mfidel-panel').classList.add('open');
}

function closeMfidelPanel() {
  document.getElementById('mfidel-backdrop').classList.remove('open');
  document.getElementById('mfidel-panel').classList.remove('open');
}

function openNarrativePanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('narrative', 'No data to narrate');
    return;
  }
  
  // Generate narrative
  const narrative = narrativeGen.generate(container);
  document.getElementById('narrative-text').textContent = narrative;
  
  // Generate key moments
  const moments = narrativeGen.generateKeyMoments(container);
  const momentsHtml = moments.slice(0, 10).map(m => `
    <div class="narrative-moment">
      <span class="narrative-moment-time">${U.formatTime(m.time)}</span>
      <span class="narrative-moment-type ${m.type}">${m.type}</span>
      <span class="narrative-moment-label">${m.label}</span>
    </div>
  `).join('');
  document.getElementById('narrative-moments').innerHTML = momentsHtml;
  
  document.getElementById('narrative-backdrop').classList.add('open');
  document.getElementById('narrative-panel').classList.add('open');
}

function closeNarrativePanel() {
  document.getElementById('narrative-backdrop').classList.remove('open');
  document.getElementById('narrative-panel').classList.remove('open');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.12 PANEL FUNCTIONS â€” InceptaDive, Ontology, Symbolic Query
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openDivePanel(frameIndex = null) {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('dive', 'No data to explore');
    return;
  }
  
  // Set frame for exploration
  const frame = frameIndex !== null ? 
    container.frames[frameIndex] : 
    container.frames[playbackEngine.currentFrameIndex] || container.frames[0];
  
  inceptaDive.setFrame(frame);
  inceptaDive.render();
  
  document.getElementById('dive-backdrop').classList.add('open');
  document.getElementById('dive-panel').classList.add('open');
}

function closeDivePanel() {
  document.getElementById('dive-backdrop').classList.remove('open');
  document.getElementById('dive-panel').classList.remove('open');
}

function openOntologyPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('ontology', 'No data to browse');
    return;
  }
  
  symbolOntology.countFromContainer(container);
  symbolOntology.render();
  
  document.getElementById('ontology-backdrop').classList.add('open');
  document.getElementById('ontology-panel').classList.add('open');
}

function closeOntologyPanel() {
  document.getElementById('ontology-backdrop').classList.remove('open');
  document.getElementById('ontology-panel').classList.remove('open');
}

function openSqlPanel() {
  document.getElementById('sql-backdrop').classList.add('open');
  document.getElementById('sql-panel').classList.add('open');
  document.getElementById('sql-input').focus();
}

function closeSqlPanel() {
  document.getElementById('sql-backdrop').classList.remove('open');
  document.getElementById('sql-panel').classList.remove('open');
}

function runSymbolicQuery() {
  const input = document.getElementById('sql-input').value.trim();
  if (!input) return;
  
  const container = orch?.getContainer();
  const result = symbolicQuery.parse(input, container);
  const formatted = symbolicQuery.formatResult(result);
  
  document.getElementById('sql-result').textContent = formatted;
}

function setSqlExample(example) {
  document.getElementById('sql-input').value = example;
  document.getElementById('sql-input').focus();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.13 PANEL FUNCTIONS â€” Audio, Motion, Mullu Export, Performance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openAudioPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('audio', 'No data to visualize');
    return;
  }
  
  audioWaveform.extractFromContainer(container);
  audioWaveform.render();
  
  document.getElementById('audio-backdrop').classList.add('open');
  document.getElementById('audio-panel').classList.add('open');
}

function closeAudioPanel() {
  document.getElementById('audio-backdrop').classList.remove('open');
  document.getElementById('audio-panel').classList.remove('open');
}

function openMotionPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('motion', 'No data to visualize');
    return;
  }
  
  motionOverlay.buildFromContainer(container);
  motionOverlay.setCurrentFrame(playbackEngine.currentFrameIndex || 0);
  motionOverlay.render();
  
  document.getElementById('motion-backdrop').classList.add('open');
  document.getElementById('motion-panel').classList.add('open');
}

function closeMotionPanel() {
  document.getElementById('motion-backdrop').classList.remove('open');
  document.getElementById('motion-panel').classList.remove('open');
}

function openMulluPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('mullu', 'No data to export');
    return;
  }
  
  // Generate preview
  const exported = mulluExporter.export(container);
  const preview = JSON.stringify(exported, null, 2).slice(0, 500) + '...';
  document.getElementById('mullu-preview').textContent = preview;
  
  // Update stats
  const json = mulluExporter.toJSON(container);
  const statsHtml = `
    <div class="mullu-stat"><span class="mullu-stat-label">Frames</span><span class="mullu-stat-value">${exported.meta.frameCount}</span></div>
    <div class="mullu-stat"><span class="mullu-stat-label">Symbols</span><span class="mullu-stat-value">${exported.symbolMesh.nodes.length}</span></div>
    <div class="mullu-stat"><span class="mullu-stat-label">Chains</span><span class="mullu-stat-value">${exported.causalChains.chains.length}</span></div>
    <div class="mullu-stat"><span class="mullu-stat-label">Size</span><span class="mullu-stat-value">${(json.length / 1024).toFixed(1)} KB</span></div>
  `;
  document.getElementById('mullu-stats').innerHTML = statsHtml;
  
  document.getElementById('mullu-backdrop').classList.add('open');
  document.getElementById('mullu-panel').classList.add('open');
}

function closeMulluPanel() {
  document.getElementById('mullu-backdrop').classList.remove('open');
  document.getElementById('mullu-panel').classList.remove('open');
}

function downloadMullu() {
  const container = orch?.getContainer();
  if (!container) return;
  
  const filename = `virecai_${Date.now()}.mullu`;
  const result = mulluExporter.download(container, filename);
  
  if (result.success) {
    Log.ok('mullu', `Downloaded ${filename} (${(result.size / 1024).toFixed(1)} KB)`);
  }
}

function copyMulluJson() {
  const container = orch?.getContainer();
  if (!container) return;
  
  const json = mulluExporter.toJSON(container);
  navigator.clipboard.writeText(json).then(() => {
    Log.ok('mullu', 'Copied to clipboard');
  }).catch(() => {
    Log.error('mullu', 'Failed to copy');
  });
}

function togglePerfMonitor() {
  const el = document.getElementById('perf-monitor-float');
  if (el.style.display === 'none') {
    el.style.display = 'block';
    perfMonitor.start();
    setInterval(() => perfMonitor.render('perf-monitor-float'), 1000);
  } else {
    el.style.display = 'none';
    perfMonitor.stop();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.14 PANEL FUNCTIONS â€” Patterns, Help, Settings, Theme
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openPatternPanel() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('patterns', 'No data to analyze');
    return;
  }
  
  // Run pattern detection
  const analysis = patternDetector.analyze(container);
  patternDetector.render('pattern-container');
  
  // Update smart timeline
  smartTimeline.update(container, analysis);
  smartTimeline.render();
  
  document.getElementById('pattern-backdrop').classList.add('open');
  document.getElementById('pattern-panel').classList.add('open');
}

function closePatternPanel() {
  document.getElementById('pattern-backdrop').classList.remove('open');
  document.getElementById('pattern-panel').classList.remove('open');
}

function openHelpPanel() {
  helpOverlay.open();
}

function closeHelpPanel() {
  helpOverlay.close();
}

function goToFrame(frameIndex) {
  if (playbackEngine.totalFrames === 0) return;
  
  const container = orch?.getContainer();
  if (!container) return;
  
  const clamped = Math.max(0, Math.min(container.frames.length - 1, frameIndex));
  playbackEngine.currentFrameIndex = clamped;
  
  const frame = container.frames[clamped];
  if (frame) {
    frameViewer.showFrame(frame);
    updatePlaybackUI();
    
    // Update smart timeline
    smartTimeline.setCurrentFrame(clamped);
    
    // Update motion overlay if open
    if (document.getElementById('motion-panel').classList.contains('open')) {
      motionOverlay.setCurrentFrame(clamped);
      motionOverlay.render();
    }
  }
}

function cycleTheme() {
  themeManager.toggle();
  Log.ok('theme', `Switched to ${themeManager.getCurrent()} theme`);
}

function applyTheme(themeName) {
  if (themeManager.apply(themeName)) {
    Log.ok('theme', `Applied ${themeName} theme`);
  }
}

function updateSmartTimeline() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) return;
  
  const analysis = patternDetector.analyze(container);
  smartTimeline.update(container, analysis);
  smartTimeline.setCurrentFrame(playbackEngine.currentFrameIndex || 0);
  smartTimeline.render();
}

function showSmartTimeline() {
  const wrapper = document.getElementById('smart-timeline-wrapper');
  const analytics = document.getElementById('analytics-panel');
  
  if (analytics && wrapper.style.display === 'none') {
    wrapper.style.display = 'block';
    updateSmartTimeline();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” PROFESSIONAL RECORDING CONTROLS
// Record â†’ Pause â†’ Resume â†’ Stop with full session management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Use the professional RecordingController
function toggleRecording() {
  if (!orch) return;
  // Prevent recording before system is initialized
  const orchState = orch.getState();
  if (orchState === 'idle' || orchState === 'initializing') {
    toast?.warning?.('Please initialize the system first');
    return;
  }
  recordingController.toggle();
}

function pauseRecording() {
  recordingController.pause();
}

function resumeRecording() {
  recordingController.resume();
}

function stopRecording() {
  recordingController.forceStop();
}

function startNewRecording() {
  recordingController.startNew();
}

function updateStatusForRecording() {
  statusDashboard.update('recording', 0, 0);
}

function updateStatusForPaused() {
  const container = orch?.getContainer();
  const frameCount = container?.frames?.length || 0;
  const duration = container?.getDuration?.() || 0;
  
  statusDashboard.update('paused', frameCount, duration);
}

function updateStatusForStopped() {
  const container = orch?.getContainer();
  const frameCount = container?.frames?.length || 0;
  const duration = container?.getDuration?.() || 0;
  
  statusDashboard.update('stopped', frameCount, duration);
  
  if (frameCount > 0) {
    toast.info(`Captured ${frameCount} frames. Press P to playback.`);
  }
}

function updateStatusForPlaying() {
  const container = orch?.getContainer();
  const frameCount = container?.frames?.length || 0;
  const duration = container?.getDuration?.() || 0;
  
  statusDashboard.update('playing', frameCount, duration);
}

function updateStatusForIdle() {
  statusDashboard.update('idle', 0, 0);
  quickActions.render();
}

// Hook into existing save function to mark saved
function markRecordingSaved() {
  statusDashboard.markSaved();
  toast.success('Recording saved');
}

// Show tour command
function showTour() {
  onboarding.reset();
  onboarding.start();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.16 â€” DATA MANAGEMENT FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openDataPanel() {
  dataPanelUI.render('data-container');
  document.getElementById('data-backdrop').classList.add('open');
  document.getElementById('data-panel').classList.add('open');
}

function closeDataPanel() {
  document.getElementById('data-backdrop').classList.remove('open');
  document.getElementById('data-panel').classList.remove('open');
}

async function saveCurrentRecording() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    toast.warning('No recording to save');
    return;
  }
  
  const name = prompt('Recording name:', `Recording ${new Date().toLocaleString()}`);
  if (name === null) return; // Cancelled
  
  try {
    await dataManager.saveRecording(container, name);
    dataPanelUI.render('data-container');
  } catch (err) {
    toast.error('Save failed: ' + err.message);
  }
}

async function loadRecordingById(id) {
  try {
    const recording = await dataManager.loadRecording(id);
    
    // Reconstruct container from serialized data
    if (recording.serialized) {
      // For now, show toast - full reconstruction would need container rebuild
      toast.success(`Loaded: ${recording.name}`);
      closeDataPanel();
      
      // Open playback with loaded data
      if (recording.serialized.frames) {
        toast.info(`${recording.serialized.frames.length} frames ready`);
      }
    }
  } catch (err) {
    toast.error('Load failed: ' + err.message);
  }
}

async function exportRecordingById(id) {
  try {
    const recording = await dataManager.loadRecording(id);
    
    const data = JSON.stringify(recording.serialized, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${recording.name.replace(/[^a-z0-9]/gi, '_')}.mullu`;
    a.click();
    
    URL.revokeObjectURL(url);
    toast.success('Exported successfully');
  } catch (err) {
    toast.error('Export failed: ' + err.message);
  }
}

async function deleteRecordingById(id) {
  if (!confirm('Delete this recording?')) return;
  
  try {
    await dataManager.deleteRecording(id);
    dataPanelUI.render('data-container');
  } catch (err) {
    toast.error('Delete failed: ' + err.message);
  }
}

function importRecordingFile() {
  document.getElementById('import-file-input').click();
}

async function handleFileImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    const data = await dataManager.importFromFile(file);
    toast.success('Import successful');
    // Reset input
    event.target.value = '';
  } catch (err) {
    toast.error('Import failed');
  }
}

async function promptInstallPWA() {
  const installed = await pwaManager.promptInstall();
  if (!installed) {
    toast.info('Install cancelled or not available');
  }
}

function toggleAutoSave() {
  if (dataManager.autoSaveEnabled) {
    dataManager.disableAutoSave();
    toast.info('Auto-save disabled');
  } else {
    dataManager.enableAutoSave();
    toast.success('Auto-save enabled (every 30s)');
  }
}

async function showStorageUsage() {
  const usage = await dataManager.getStorageUsage();
  const usedMB = (usage.usage / 1024 / 1024).toFixed(2);
  const quotaMB = (usage.quota / 1024 / 1024).toFixed(2);
  toast.info(`Storage: ${usedMB} MB / ${quotaMB} MB`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” CAMERA CONTROL FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openCameraPanel() {
  cameraControlsUI.render('camera-container');
  document.getElementById('camera-backdrop').classList.add('open');
  document.getElementById('camera-panel').classList.add('open');
  a11y.announce('Camera settings panel opened');
}

function closeCameraPanel() {
  document.getElementById('camera-backdrop').classList.remove('open');
  document.getElementById('camera-panel').classList.remove('open');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.18 â€” CLIP EDITOR FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openClipEditorPanel() {
  clipEditor.render();
  updateClipTimeline();
  document.getElementById('clip-editor-backdrop').classList.add('open');
  document.getElementById('clip-editor-panel').classList.add('open');
  a11y.announce('Clip editor panel opened');
}

function closeClipEditorPanel() {
  document.getElementById('clip-editor-backdrop').classList.remove('open');
  document.getElementById('clip-editor-panel').classList.remove('open');
}

function updateClipTimeline() {
  const container = orch?.getContainer();
  if (!container || !container.frames.length) return;
  
  const track = document.getElementById('clip-timeline-track');
  if (!track) return;
  
  // Draw clips on timeline
  let clipMarkers = '';
  clipEditor.getClips().forEach(clip => {
    const startPct = (clip.startFrame / container.frames.length) * 100;
    const widthPct = (clip.frameCount / container.frames.length) * 100;
    clipMarkers += `<div class="clip-timeline-clip" style="left: ${startPct}%; width: ${widthPct}%; background: ${clip.color}40; border: 1px solid ${clip.color}; position: absolute; top: 0; height: 100%; border-radius: 3px;"></div>`;
  });
  
  track.innerHTML = clipMarkers;
}

// Setup timeline drag selection
function setupClipTimelineDrag() {
  const track = document.getElementById('clip-timeline-track');
  if (!track) return;
  
  let isDragging = false;
  let startX = 0;
  
  track.addEventListener('mousedown', (e) => {
    isDragging = true;
    const rect = track.getBoundingClientRect();
    startX = (e.clientX - rect.left) / rect.width;
    
    const container = orch?.getContainer();
    const totalFrames = container?.frames?.length || 1;
    clipEditor.selectionStart = Math.floor(startX * totalFrames);
    clipEditor.isSelecting = true;
  });
  
  track.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    
    const rect = track.getBoundingClientRect();
    const endX = (e.clientX - rect.left) / rect.width;
    
    const container = orch?.getContainer();
    const totalFrames = container?.frames?.length || 1;
    clipEditor.selectionEnd = Math.floor(Math.max(0, Math.min(1, endX)) * totalFrames);
    clipEditor._updateSelectionUI();
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      clipEditor.isSelecting = false;
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.18 â€” EXPORT PANEL FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let selectedExportFormat = 'mullu';

function openExportPanel() {
  document.getElementById('export-panel-backdrop').classList.add('open');
  document.getElementById('export-panel').classList.add('open');
  document.getElementById('export-progress').style.display = 'none';
  a11y.announce('Export panel opened');
}

function closeExportPanel() {
  document.getElementById('export-panel-backdrop').classList.remove('open');
  document.getElementById('export-panel').classList.remove('open');
}

function selectExportFormat(format) {
  selectedExportFormat = format;
  
  // Update UI
  document.querySelectorAll('.export-format-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.format === format);
  });
  
  a11y.announce(`Selected ${format} format`);
}

async function doExport() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    toast?.error?.('No recording to export');
    return;
  }
  
  document.getElementById('export-progress').style.display = 'block';
  
  try {
    await exportManager.exportRecording(selectedExportFormat);
    closeExportPanel();
  } catch (err) {
    toast?.error?.('Export failed: ' + err.message);
  }
}

// Quick export functions
function quickExportMullu() {
  exportManager.exportRecording('mullu');
}

function quickExportJSON() {
  exportManager.exportRecording('json');
}

function quickExportCSV() {
  exportManager.exportRecording('csv');
}

function quickExportReport() {
  exportManager.exportRecording('report');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.19 â€” ANNOTATION TIMELINE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openAnnotationPanel() {
  // Initialize renderer if needed
  if (!timelineRenderer) {
    timelineRenderer = new TimelineRenderer(annotationTimeline, 'annotation-timeline-container');
  }
  timelineRenderer.init();
  timelineRenderer.setPlayhead(playbackEngine?.currentFrame || 0);
  markerEditorUI.render('marker-editor-container');
  
  document.getElementById('annotation-backdrop').classList.add('open');
  document.getElementById('annotation-panel').classList.add('open');
  a11y.announce('Annotation timeline opened');
}

function closeAnnotationPanel() {
  document.getElementById('annotation-backdrop').classList.remove('open');
  document.getElementById('annotation-panel').classList.remove('open');
}

function addMarkerAtCurrent() {
  const frame = playbackEngine?.currentFrame || 0;
  const marker = annotationTimeline.addMarker(frame);
  annotationTimeline.selectedMarker = marker;
  markerEditorUI.render('marker-editor-container');
  timelineRenderer?.render();
  toast?.info?.(`Marker added at frame ${frame}`);
}

function selectMarker(markerId) {
  const marker = annotationTimeline.markers.find(m => m.id === markerId);
  if (marker) {
    annotationTimeline.selectedMarker = marker;
    annotationTimeline.selectedRegion = null;
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
  }
}

function setMarkerType(type) {
  if (annotationTimeline.selectedMarker) {
    annotationTimeline.updateMarker(annotationTimeline.selectedMarker.id, { type });
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
  }
}

function updateMarkerLabel(label) {
  if (annotationTimeline.selectedMarker) {
    annotationTimeline.updateMarker(annotationTimeline.selectedMarker.id, { label });
    timelineRenderer?.render();
  }
}

function updateMarkerFrame(frame) {
  if (annotationTimeline.selectedMarker) {
    annotationTimeline.updateMarker(annotationTimeline.selectedMarker.id, { frame });
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
  }
}

function updateMarkerColor(color) {
  if (annotationTimeline.selectedMarker) {
    annotationTimeline.updateMarker(annotationTimeline.selectedMarker.id, { color });
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
  }
}

function gotoMarker(markerId) {
  const marker = annotationTimeline.markers.find(m => m.id === markerId);
  if (marker) {
    playbackEngine?.seek?.(marker.frame);
    timelineRenderer?.setPlayhead(marker.frame);
    updatePlaybackUI?.();
    renderCurrentFrame?.();
  }
}

function deleteSelectedMarker() {
  if (annotationTimeline.selectedMarker) {
    annotationTimeline.deleteMarker(annotationTimeline.selectedMarker.id);
    markerEditorUI.render('marker-editor-container');
    toast?.info?.('Marker deleted');
  }
}

function clearAllMarkers() {
  if (confirm('Delete all markers?')) {
    annotationTimeline.markers = [];
    annotationTimeline.selectedMarker = null;
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    toast?.info?.('All markers cleared');
  }
}

function zoomTimeline(delta) {
  annotationTimeline.setZoom(annotationTimeline.zoom + delta);
  timelineRenderer?.render();
}

function resetTimelineZoom() {
  annotationTimeline.setZoom(1);
  annotationTimeline.setOffset(0);
  timelineRenderer?.render();
}

function importScenesAsRegions() {
  const container = orch?.getContainer();
  if (!container || !container.scenes.length) {
    toast?.warning?.('No scenes detected to import');
    return;
  }
  
  const count = annotationTimeline.importFromScenes(container.scenes);
  markerEditorUI.render('marker-editor-container');
  timelineRenderer?.render();
  toast?.success?.(`Imported ${count} scene regions`);
}

function exportAnnotations() {
  const data = annotationTimeline.exportAnnotations();
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `annotations_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  toast?.success?.('Annotations exported');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.19 â€” NOTES PANEL FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let currentNotesFrame = 0;

function openNotesPanel() {
  currentNotesFrame = playbackEngine?.currentFrame || 0;
  updateNotesUI();
  
  document.getElementById('notes-backdrop').classList.add('open');
  document.getElementById('notes-panel').classList.add('open');
  a11y.announce('Notes panel opened');
}

function closeNotesPanel() {
  document.getElementById('notes-backdrop').classList.remove('open');
  document.getElementById('notes-panel').classList.remove('open');
}

function updateNotesUI() {
  document.getElementById('notes-current-frame').textContent = currentNotesFrame;
  
  const existingNote = annotationTimeline.getNoteAt(currentNotesFrame);
  document.getElementById('notes-textarea').value = existingNote?.text || '';
  
  // Render notes list
  const allNotes = annotationTimeline.getAllNotes();
  const container = document.getElementById('notes-list-container');
  
  if (allNotes.length === 0) {
    container.innerHTML = '<div class="marker-empty">No notes yet</div>';
  } else {
    container.innerHTML = allNotes.map(note => `
      <div class="note-item" onclick="gotoNoteFrame(${note.frame})">
        <span class="note-frame">F${note.frame}</span>
        <span class="note-text">${note.text.substring(0, 80)}${note.text.length > 80 ? '...' : ''}</span>
      </div>
    `).join('');
  }
}

function saveCurrentNote() {
  const text = document.getElementById('notes-textarea').value.trim();
  if (!text) {
    toast?.warning?.('Please enter a note');
    return;
  }
  
  annotationTimeline.updateNote(currentNotesFrame, text);
  updateNotesUI();
  timelineRenderer?.render();
  toast?.success?.(`Note saved for frame ${currentNotesFrame}`);
}

function clearCurrentNote() {
  annotationTimeline.deleteNote(currentNotesFrame);
  document.getElementById('notes-textarea').value = '';
  updateNotesUI();
  timelineRenderer?.render();
  toast?.info?.('Note cleared');
}

function gotoNoteFrame(frame) {
  currentNotesFrame = frame;
  playbackEngine?.seek?.(frame);
  updateNotesUI();
  timelineRenderer?.setPlayhead(frame);
  updatePlaybackUI?.();
  renderCurrentFrame?.();
}

// Quick marker shortcuts
function addChapterMarker() {
  const frame = playbackEngine?.currentFrame || 0;
  annotationTimeline.addMarker(frame, `Chapter ${annotationTimeline.markers.filter(m => m.type === 'chapter').length + 1}`, '#4ecdc4', 'chapter');
  toast?.info?.('Chapter marker added');
}

function addImportantMarker() {
  const frame = playbackEngine?.currentFrame || 0;
  annotationTimeline.addMarker(frame, 'Important', '#ffd700', 'important');
  toast?.info?.('Important marker added');
}

function goToNextMarker() {
  const current = playbackEngine?.currentFrame || 0;
  const next = annotationTimeline.markers.find(m => m.frame > current);
  if (next) {
    playbackEngine?.seek?.(next.frame);
    timelineRenderer?.setPlayhead(next.frame);
    updatePlaybackUI?.();
    renderCurrentFrame?.();
  }
}

function goToPrevMarker() {
  const current = playbackEngine?.currentFrame || 0;
  const prev = [...annotationTimeline.markers].reverse().find(m => m.frame < current);
  if (prev) {
    playbackEngine?.seek?.(prev.frame);
    timelineRenderer?.setPlayhead(prev.frame);
    updatePlaybackUI?.();
    renderCurrentFrame?.();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.20 â€” UNDO/REDO FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function doUndo() {
  if (undoRedo.undo()) {
    updateUndoRedoUI();
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    clipEditor.render();
  }
}

function doRedo() {
  if (undoRedo.redo()) {
    updateUndoRedoUI();
    markerEditorUI.render('marker-editor-container');
    timelineRenderer?.render();
    clipEditor.render();
  }
}

function undoToPoint(count) {
  for (let i = 0; i < count; i++) {
    if (!undoRedo.undo()) break;
  }
  updateUndoRedoUI();
  markerEditorUI.render('marker-editor-container');
  timelineRenderer?.render();
  clipEditor.render();
}

function redoToPoint(count) {
  for (let i = 0; i < count; i++) {
    if (!undoRedo.redo()) break;
  }
  updateUndoRedoUI();
  markerEditorUI.render('marker-editor-container');
  timelineRenderer?.render();
  clipEditor.render();
}

function updateUndoRedoUI() {
  const undoBtn = document.getElementById('undo-btn');
  const redoBtn = document.getElementById('redo-btn');
  
  if (undoBtn) undoBtn.disabled = !undoRedo.canUndo();
  if (redoBtn) redoBtn.disabled = !undoRedo.canRedo();
  
  historyPanel.render();
}

function clearHistory() {
  if (confirm('Clear all edit history?')) {
    undoRedo.clear();
    updateUndoRedoUI();
    toast?.info?.('History cleared');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.20 â€” KEYBOARD CHEATSHEET FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openCheatsheet() {
  keyboardCheatsheet.open();
}

function closeCheatsheet() {
  keyboardCheatsheet.close();
}

function toggleCheatsheet() {
  keyboardCheatsheet.toggle();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.20 â€” HISTORY PANEL FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openHistoryPanel() {
  historyPanel.open();
}

function closeHistoryPanel() {
  historyPanel.close();
}

function toggleHistoryPanel() {
  historyPanel.toggle();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.20 â€” BATCH OPERATIONS FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateBatchUI() {
  const stats = batchOps.getSelectionStats();
  const total = stats.clips + stats.markers + stats.regions;
  
  const bar = document.getElementById('batch-actions-bar');
  const count = document.getElementById('batch-count');
  
  if (total > 0) {
    bar?.classList.add('visible');
    if (count) count.textContent = `${total} selected`;
  } else {
    bar?.classList.remove('visible');
  }
}

function batchDelete() {
  const stats = batchOps.getSelectionStats();
  
  if (stats.clips > 0) batchOps.deleteSelectedClips();
  if (stats.markers > 0) batchOps.deleteSelectedMarkers();
  
  updateBatchUI();
}

function batchExport() {
  batchOps.exportSelectedClips('mullu');
}

function clearBatchSelection() {
  batchOps.clearClipSelection();
  batchOps.clearMarkerSelection();
  batchOps.selectedRegions.clear();
  updateBatchUI();
  toast?.info?.('Selection cleared');
}

function selectAllClips() {
  batchOps.selectAll('clips');
  updateBatchUI();
  toast?.info?.(`Selected ${clipEditor.getClips().length} clips`);
}

function selectAllMarkers() {
  batchOps.selectAll('markers');
  updateBatchUI();
  toast?.info?.(`Selected ${annotationTimeline.markers.length} markers`);
}

function generateMarkersEveryN(n) {
  const count = batchOps.generateMarkersAtInterval(n);
  updateUndoRedoUI();
}

function generateChapters() {
  batchOps.generateChaptersFromScenes();
  updateUndoRedoUI();
}

// Wrap marker operations with undo support
const originalAddMarker = annotationTimeline.addMarker.bind(annotationTimeline);
annotationTimeline.addMarkerWithUndo = function(frame, label, color, type) {
  const action = Actions.addMarker(this, frame, label, color, type);
  return undoRedo.execute(action);
};

const originalDeleteMarker = annotationTimeline.deleteMarker.bind(annotationTimeline);
annotationTimeline.deleteMarkerWithUndo = function(markerId) {
  const action = Actions.deleteMarker(this, markerId);
  undoRedo.execute(action);
  updateUndoRedoUI();
};

// Wrap clip operations with undo support
const originalCreateClip = clipEditor.createClip.bind(clipEditor);
clipEditor.createClipWithUndo = function(start, end, name) {
  const action = Actions.createClip(this, start, end, name);
  const result = undoRedo.execute(action);
  updateUndoRedoUI();
  return result;
};

const originalDeleteClip = clipEditor.deleteClip.bind(clipEditor);
clipEditor.deleteClipWithUndo = function(clipId) {
  const action = Actions.deleteClip(this, clipId);
  undoRedo.execute(action);
  updateUndoRedoUI();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.21 â€” PROJECT MANAGEMENT FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openProjectBrowser() {
  projectBrowserUI.render('project-browser-container');
  document.getElementById('project-backdrop').classList.add('open');
  document.getElementById('project-panel').classList.add('open');
  a11y?.announce?.('Project browser opened');
}

function closeProjectBrowser() {
  document.getElementById('project-backdrop').classList.remove('open');
  document.getElementById('project-panel').classList.remove('open');
}

async function createNewProject() {
  // Populate template dropdown
  const templates = await templateManager.getTemplates();
  const select = document.getElementById('new-project-template');
  select.innerHTML = '<option value="">â€” None â€”</option>' + 
    templates.map(t => `<option value="${t.id}">${t.icon || 'ðŸ“'} ${t.name}</option>`).join('');
  
  document.getElementById('new-project-name').value = '';
  document.getElementById('new-project-desc').value = '';
  
  document.getElementById('new-project-backdrop').classList.add('open');
  document.getElementById('new-project-panel').classList.add('open');
  document.getElementById('new-project-name').focus();
}

function closeNewProjectDialog() {
  document.getElementById('new-project-backdrop').classList.remove('open');
  document.getElementById('new-project-panel').classList.remove('open');
}

async function confirmNewProject() {
  const name = document.getElementById('new-project-name').value.trim() || 'Untitled Project';
  const desc = document.getElementById('new-project-desc').value.trim();
  const templateId = document.getElementById('new-project-template').value;
  
  // Check for unsaved changes
  if (projectManager.hasUnsavedChanges()) {
    if (!confirm('You have unsaved changes. Create new project anyway?')) return;
  }
  
  // Reset current state
  const container = orch?.getContainer();
  if (container) {
    container.frames = [];
    container.symbols.clear();
    container.scenes = [];
  }
  annotationTimeline.clearAll();
  clipEditor.clips = [];
  undoRedo.clear();
  
  // Create new project
  projectManager.createProject(name, desc);
  
  // Apply template if selected
  if (templateId) {
    const templates = await templateManager.getTemplates();
    const template = templates.find(t => t.id === templateId);
    if (template) templateManager.applyTemplate(template);
  }
  
  closeNewProjectDialog();
  closeProjectBrowser();
  projectBrowserUI.render('project-browser-container');
  toast?.success?.(`Created project: ${name}`);
}

async function quickSaveProject() {
  await projectManager.saveProject();
  projectBrowserUI.render('project-browser-container');
}

function exportCurrentProject() {
  projectManager.exportProject();
}

async function loadProjectById(projectId) {
  if (projectManager.hasUnsavedChanges()) {
    if (!confirm('You have unsaved changes. Load another project?')) return;
  }
  
  await projectManager.loadProject(projectId);
  closeProjectBrowser();
  
  // Update UI
  markerEditorUI.render('marker-editor-container');
  timelineRenderer?.render();
  updateUndoRedoUI();
}

async function duplicateProject(projectId) {
  await projectManager.duplicateProject(projectId);
  projectBrowserUI.render('project-browser-container');
}

async function exportProjectById(projectId) {
  const projects = await projectManager.getProjects();
  const project = projects.find(p => p.id === projectId);
  if (project) projectManager.exportProject(project);
}

async function deleteProjectById(projectId) {
  if (confirm('Delete this project? This cannot be undone.')) {
    await projectManager.deleteProject(projectId);
    projectBrowserUI.render('project-browser-container');
  }
}

function triggerProjectImport() {
  document.getElementById('project-import-input').click();
}

async function handleProjectImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    await projectManager.importProject(file);
    projectBrowserUI.render('project-browser-container');
  } catch (err) {
    toast?.error?.('Failed to import project');
  }
  
  event.target.value = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.21 â€” TEMPLATE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function applyTemplateById(templateId) {
  const templates = await templateManager.getTemplates();
  const template = templates.find(t => t.id === templateId);
  if (template) {
    templateManager.applyTemplate(template);
    closeProjectBrowser();
  }
}

function createTemplateFromCurrent() {
  document.getElementById('new-template-name').value = '';
  document.getElementById('new-template-desc').value = '';
  document.getElementById('new-template-icon').value = 'ðŸ“';
  
  document.getElementById('save-template-backdrop').classList.add('open');
  document.getElementById('save-template-panel').classList.add('open');
  document.getElementById('new-template-name').focus();
}

function closeSaveTemplateDialog() {
  document.getElementById('save-template-backdrop').classList.remove('open');
  document.getElementById('save-template-panel').classList.remove('open');
}

async function confirmSaveTemplate() {
  const name = document.getElementById('new-template-name').value.trim();
  const desc = document.getElementById('new-template-desc').value.trim();
  const icon = document.getElementById('new-template-icon').value.trim() || 'ðŸ“';
  
  if (!name) {
    toast?.warning?.('Please enter a template name');
    return;
  }
  
  await templateManager.createTemplate(name, desc, icon);
  closeSaveTemplateDialog();
  projectBrowserUI.switchTab('templates');
  projectBrowserUI.render('project-browser-container');
}

async function deleteTemplateById(templateId) {
  if (confirm('Delete this template?')) {
    await templateManager.deleteTemplate(templateId);
    projectBrowserUI.render('project-browser-container');
  }
}

function triggerTemplateImport() {
  document.getElementById('template-import-input').click();
}

async function handleTemplateImport(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    await templateManager.importTemplate(file);
    projectBrowserUI.render('project-browser-container');
  } catch (err) {
    toast?.error?.('Failed to import template');
  }
  
  event.target.value = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.22 â€” SHARE & COLLABORATION FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openSharePanel() {
  shareUI.render('share-container');
  document.getElementById('share-backdrop').classList.add('open');
  document.getElementById('share-panel').classList.add('open');
  
  // Load recent comments if on comments tab
  const projectId = projectManager.currentProject?.id;
  if (projectId) {
    shareUI.loadRecentComments(projectId);
  }
  
  a11y?.announce?.('Share panel opened');
}

function closeSharePanel() {
  document.getElementById('share-backdrop').classList.remove('open');
  document.getElementById('share-panel').classList.remove('open');
}

function createNewShare() {
  document.getElementById('share-allow-download').checked = true;
  document.getElementById('share-allow-comments').checked = true;
  document.getElementById('share-use-password').checked = false;
  document.getElementById('share-password-field').style.display = 'none';
  document.getElementById('share-password').value = '';
  document.getElementById('share-expires').value = '604800000';
  
  document.getElementById('create-share-backdrop').classList.add('open');
  document.getElementById('create-share-panel').classList.add('open');
  
  // Toggle password field visibility
  document.getElementById('share-use-password').onchange = function() {
    document.getElementById('share-password-field').style.display = this.checked ? 'block' : 'none';
  };
}

function closeCreateShareDialog() {
  document.getElementById('create-share-backdrop').classList.remove('open');
  document.getElementById('create-share-panel').classList.remove('open');
}

async function confirmCreateShare() {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) {
    toast?.error?.('No project loaded');
    return;
  }
  
  const options = {
    allowDownload: document.getElementById('share-allow-download').checked,
    allowComments: document.getElementById('share-allow-comments').checked,
    password: document.getElementById('share-use-password').checked 
      ? document.getElementById('share-password').value 
      : null,
    expiresIn: document.getElementById('share-expires').value 
      ? parseInt(document.getElementById('share-expires').value) 
      : null
  };
  
  const share = await shareManager.createShare(projectId, options);
  
  closeCreateShareDialog();
  shareUI.render('share-container');
  
  // Copy to clipboard
  await navigator.clipboard.writeText(share.url);
  toast?.success?.('Share link created and copied to clipboard!');
}

async function copyShareUrl(shareId) {
  const url = shareManager.getShareUrl(shareId);
  await navigator.clipboard.writeText(url);
  toast?.info?.('Link copied to clipboard');
}

async function deleteShareById(shareId) {
  if (confirm('Delete this share link?')) {
    await shareManager.deleteShare(shareId);
    shareUI.render('share-container');
    toast?.info?.('Share link deleted');
  }
}

// Collaborator functions
function openAddCollaboratorDialog() {
  document.getElementById('collab-name').value = '';
  document.getElementById('collab-email').value = '';
  document.getElementById('collab-permission').value = 'view';
  
  document.getElementById('add-collab-backdrop').classList.add('open');
  document.getElementById('add-collab-panel').classList.add('open');
  document.getElementById('collab-name').focus();
}

function closeAddCollaboratorDialog() {
  document.getElementById('add-collab-backdrop').classList.remove('open');
  document.getElementById('add-collab-panel').classList.remove('open');
}

async function confirmAddCollaborator() {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) {
    toast?.error?.('No project loaded');
    return;
  }
  
  const name = document.getElementById('collab-name').value.trim();
  if (!name) {
    toast?.warning?.('Please enter a name');
    return;
  }
  
  await collaboratorManager.addCollaborator(projectId, {
    name,
    email: document.getElementById('collab-email').value.trim(),
    permission: document.getElementById('collab-permission').value
  });
  
  closeAddCollaboratorDialog();
  shareUI.render('share-container');
  toast?.success?.(`Added collaborator: ${name}`);
}

async function updateCollaboratorPermission(collabId, permission) {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) return;
  
  await collaboratorManager.setPermission(projectId, collabId, permission);
  toast?.info?.(`Permission updated to ${permission}`);
}

async function removeCollaboratorById(collabId) {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) return;
  
  if (confirm('Remove this collaborator?')) {
    await collaboratorManager.removeCollaborator(projectId, collabId);
    shareUI.render('share-container');
    toast?.info?.('Collaborator removed');
  }
}

async function copyInviteLink() {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) {
    toast?.error?.('No project loaded');
    return;
  }
  
  const link = collaboratorManager.generateInviteLink(projectId, 'comment');
  await navigator.clipboard.writeText(link);
  toast?.info?.('Invite link copied to clipboard');
}

// Comments functions
function openCommentsPanel() {
  const frame = playbackEngine?.currentFrame || 0;
  document.getElementById('comment-frame-display').textContent = frame;
  document.getElementById('comment-author-input').value = localStorage.getItem('virecai_comment_author') || '';
  document.getElementById('comment-text-input').value = '';
  
  loadCommentsList();
  
  document.getElementById('comments-backdrop').classList.add('open');
  document.getElementById('comments-panel').classList.add('open');
}

function closeCommentsPanel() {
  document.getElementById('comments-backdrop').classList.remove('open');
  document.getElementById('comments-panel').classList.remove('open');
}

async function loadCommentsList() {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) {
    document.getElementById('comments-list').innerHTML = '<div class="no-comments">No project loaded</div>';
    return;
  }
  
  const comments = await commentSystem.getComments(projectId);
  const rootComments = comments.filter(c => !c.parentId).sort((a, b) => b.created - a.created);
  
  const list = document.getElementById('comments-list');
  
  if (rootComments.length === 0) {
    list.innerHTML = '<div class="no-comments">No comments yet. Be the first to comment!</div>';
    return;
  }
  
  list.innerHTML = rootComments.map(c => {
    const replies = comments.filter(r => r.parentId === c.id);
    return `
      <div class="comment-thread" style="margin-bottom: 12px; background: var(--bg-tertiary); border-radius: 10px; padding: 12px;">
        <div class="comment-main" style="display: flex; gap: 10px;">
          <div class="comment-author-badge" style="background: ${c.authorColor}; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; font-size: 13px; flex-shrink: 0;">
            ${c.author.charAt(0).toUpperCase()}
          </div>
          <div style="flex: 1; min-width: 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
              <span style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${c.author}</span>
              ${c.frame !== null ? `<span onclick="goToCommentFrame(${c.frame})" style="padding: 2px 6px; background: var(--bg-secondary); border-radius: 4px; font-size: 9px; font-family: monospace; color: var(--accent-cyan); cursor: pointer;">F${c.frame}</span>` : ''}
            </div>
            <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.5; margin-bottom: 6px;">${c.text}</div>
            <div style="display: flex; gap: 12px; font-size: 10px; color: var(--text-muted);">
              <span>${new Date(c.created).toLocaleString()}</span>
              ${c.resolved ? '<span style="color: #4ecdc4;">âœ“ Resolved</span>' : ''}
              <span onclick="toggleCommentResolved('${c.id}')" style="cursor: pointer; color: var(--accent-cyan);">${c.resolved ? 'Reopen' : 'Resolve'}</span>
              <span onclick="deleteCommentById('${c.id}')" style="cursor: pointer; color: #ff6b6b;">Delete</span>
            </div>
          </div>
        </div>
        ${replies.length > 0 ? `
          <div class="comment-replies" style="margin-left: 42px; margin-top: 10px; padding-left: 10px; border-left: 2px solid var(--border);">
            ${replies.map(r => `
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <div style="background: ${r.authorColor}; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #fff; font-size: 10px;">${r.author.charAt(0).toUpperCase()}</div>
                <div style="flex: 1;">
                  <span style="font-size: 11px; font-weight: 600; color: var(--text-primary);">${r.author}</span>
                  <div style="font-size: 10px; color: var(--text-secondary);">${r.text}</div>
                </div>
              </div>
            `).join('')}
          </div>
        ` : ''}
      </div>
    `;
  }).join('');
}

async function submitComment() {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) {
    toast?.error?.('No project loaded');
    return;
  }
  
  const author = document.getElementById('comment-author-input').value.trim() || 'Anonymous';
  const text = document.getElementById('comment-text-input').value.trim();
  
  if (!text) {
    toast?.warning?.('Please enter a comment');
    return;
  }
  
  // Save author name for next time
  localStorage.setItem('virecai_comment_author', author);
  
  const frame = playbackEngine?.currentFrame || 0;
  
  await commentSystem.addComment(projectId, { author, text, frame });
  
  document.getElementById('comment-text-input').value = '';
  loadCommentsList();
  toast?.success?.('Comment added');
}

function addCommentAtFrame() {
  closeSharePanel();
  openCommentsPanel();
}

async function toggleCommentResolved(commentId) {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) return;
  
  await commentSystem.toggleResolved(projectId, commentId);
  loadCommentsList();
}

async function deleteCommentById(commentId) {
  const projectId = projectManager.currentProject?.id;
  if (!projectId) return;
  
  if (confirm('Delete this comment and its replies?')) {
    await commentSystem.deleteComment(projectId, commentId);
    loadCommentsList();
    toast?.info?.('Comment deleted');
  }
}

function goToCommentFrame(frame) {
  closeCommentsPanel();
  playbackEngine?.seek?.(frame);
  updatePlaybackUI?.();
  renderCurrentFrame?.();
  toast?.info?.(`Jumped to frame ${frame}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.23 â€” GLOBAL SEARCH FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openSearchPanel() {
  searchUI.render('search-container');
  document.getElementById('search-backdrop').classList.add('open');
  document.getElementById('search-panel').classList.add('open');
  
  // Set up search input handler
  setTimeout(() => {
    const input = document.getElementById('global-search-input');
    if (input) {
      input.focus();
      input.addEventListener('input', debounce((e) => {
        searchUI.performSearch(e.target.value);
      }, 300));
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeSearchPanel();
        }
      });
    }
  }, 100);
  
  a11y?.announce?.('Search panel opened');
}

function closeSearchPanel() {
  document.getElementById('search-backdrop').classList.remove('open');
  document.getElementById('search-panel').classList.remove('open');
}

// Debounce helper
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn.apply(this, args), delay);
  };
}

function clearGlobalSearch() {
  searchUI.clear();
}

function toggleSearchType(type) {
  const types = [...searchUI.selectedTypes];
  const idx = types.indexOf(type);
  if (idx >= 0) {
    types.splice(idx, 1);
  } else {
    types.push(type);
  }
  searchUI.setTypes(types);
}

function applySearchPreset(presetId) {
  filterManager.applyPreset(presetId);
  if (searchUI.currentQuery) {
    searchUI.performSearch(searchUI.currentQuery);
  } else {
    searchUI.render('search-container');
  }
  toast?.info?.(`Applied filter preset`);
}

function clearSearchFilters() {
  filterManager.clearFilters();
  if (searchUI.currentQuery) {
    searchUI.performSearch(searchUI.currentQuery);
  } else {
    searchUI.render('search-container');
  }
}

function setSearchSort(sortBy) {
  searchUI.setSortBy(sortBy);
}

function searchFromHistory(query) {
  searchUI.currentQuery = query;
  searchUI.performSearch(query);
}

function clearSearchHistory() {
  globalSearch.clearHistory();
  searchUI.render('search-container');
  toast?.info?.('Search history cleared');
}

// Saved searches
function saveCurrentSearch() {
  if (!searchUI.currentQuery) return;
  
  document.getElementById('save-search-name').value = '';
  document.getElementById('save-search-query-display').textContent = searchUI.currentQuery;
  
  document.getElementById('save-search-backdrop').classList.add('open');
  document.getElementById('save-search-panel').classList.add('open');
  document.getElementById('save-search-name').focus();
}

function closeSaveSearchDialog() {
  document.getElementById('save-search-backdrop').classList.remove('open');
  document.getElementById('save-search-panel').classList.remove('open');
}

function confirmSaveSearch() {
  const name = document.getElementById('save-search-name').value.trim() || 'Saved Search';
  
  savedSearchManager.save(
    name,
    searchUI.currentQuery,
    filterManager.getFilters(),
    searchUI.selectedTypes
  );
  
  closeSaveSearchDialog();
  searchUI.render('search-container');
  toast?.success?.(`Saved search: ${name}`);
}

function runSavedSearch(searchId) {
  const search = savedSearchManager.get(searchId);
  if (!search) return;
  
  savedSearchManager.incrementUseCount(searchId);
  
  // Apply filters
  filterManager.clearFilters();
  Object.entries(search.filters || {}).forEach(([k, v]) => {
    filterManager.setFilter(k, v);
  });
  
  // Apply types
  if (search.types && search.types.length > 0) {
    searchUI.setTypes(search.types);
  }
  
  // Run search
  searchUI.performSearch(search.query);
}

function deleteSavedSearch(searchId) {
  savedSearchManager.delete(searchId);
  searchUI.render('search-container');
  toast?.info?.('Saved search deleted');
}

// Handle search result click
function handleSearchResult(type, id, frame) {
  closeSearchPanel();
  
  switch (type) {
    case 'project':
      loadProjectById(id);
      break;
    case 'clip':
      openClipEditorPanel();
      // Could highlight the clip
      break;
    case 'marker':
      if (frame !== null) {
        playbackEngine?.seek?.(frame);
        updatePlaybackUI?.();
        renderCurrentFrame?.();
      }
      openAnnotationPanel();
      break;
    case 'comment':
      if (frame !== null) {
        playbackEngine?.seek?.(frame);
        updatePlaybackUI?.();
        renderCurrentFrame?.();
      }
      openCommentsPanel();
      break;
    case 'frame':
      if (frame !== null) {
        playbackEngine?.seek?.(frame);
        updatePlaybackUI?.();
        renderCurrentFrame?.();
      }
      break;
    case 'symbol':
      openMeshPanel();
      break;
  }
  
  toast?.info?.(`Navigated to ${type}: ${id}`);
}

// Quick search (Ctrl+K style)
async function quickSearch(query) {
  if (!query) return [];
  return globalSearch.quickSearch(query, 8);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.25 â€” MENU & INFORMATION FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toggleMainMenu() {
  mainMenu.toggle();
}

function closeMainMenu() {
  mainMenu.close();
}

// Info Panel
function openInfoPanel() {
  closeMainMenu();
  infoPanel.render('info-container');
  document.getElementById('info-backdrop').classList.add('open');
  document.getElementById('info-panel').classList.add('open');
  a11y?.announce?.('System information panel opened');
}

function closeInfoPanel() {
  document.getElementById('info-backdrop').classList.remove('open');
  document.getElementById('info-panel').classList.remove('open');
}

// Dashboard
function openDashboard() {
  closeMainMenu();
  dashboard.render('dashboard-container');
  document.getElementById('dashboard-backdrop').classList.add('open');
  document.getElementById('dashboard-panel').classList.add('open');
  a11y?.announce?.('Dashboard opened');
}

function closeDashboard() {
  document.getElementById('dashboard-backdrop').classList.remove('open');
  document.getElementById('dashboard-panel').classList.remove('open');
}

// About Dialog
function showAboutDialog() {
  closeMainMenu();
  document.getElementById('about-container').innerHTML = aboutDialog.render();
  document.getElementById('about-backdrop').classList.add('open');
  document.getElementById('about-panel').classList.add('open');
  a11y?.announce?.('About dialog opened');
}

function closeAboutDialog() {
  document.getElementById('about-backdrop').classList.remove('open');
  document.getElementById('about-panel').classList.remove('open');
}

// Import Dialog (placeholder)
function showImportDialog() {
  toast?.info?.('Import: Use File > Open Project or drag & drop .virecai files');
}

// Templates Browser (opens project browser with templates tab)
function openTemplatesBrowser() {
  openProjectBrowser();
  // Switch to templates tab after a short delay
  setTimeout(() => {
    const templatesTab = document.querySelector('[onclick*="templates"]');
    if (templatesTab) templatesTab.click();
  }, 100);
}

// Settings Panel
function openSettingsPanel() {
  // Open settings via existing settings manager
  const settingsContent = `
    <div style="padding: 10px;">
      <h3 style="margin: 0 0 16px 0; color: var(--text-primary);">Settings</h3>
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>Theme</span>
          <select onchange="themeManager.apply(this.value)" style="padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary);">
            <option value="dark" ${settingsManager.get('theme') === 'dark' ? 'selected' : ''}>Dark</option>
            <option value="light" ${settingsManager.get('theme') === 'light' ? 'selected' : ''}>Light</option>
            <option value="midnight" ${settingsManager.get('theme') === 'midnight' ? 'selected' : ''}>Midnight</option>
          </select>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>Auto-save</span>
          <span style="color: var(--accent-cyan);">Every 60s</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>Health Monitoring</span>
          <span style="color: var(--accent-cyan);">Every 30s</span>
        </div>
      </div>
    </div>
  `;
  
  const output = document.getElementById('query-output');
  if (output) {
    output.innerHTML = settingsContent;
  }
  switchTab?.('query');
  openPanel?.();
}

// Sensor Panel
function openSensorPanel() {
  switchTab?.('sensors');
  openPanel?.();
}

// Annotations Panel
function openAnnotationsPanel() {
  switchTab?.('annotations');
  openPanel?.();
}

// Collaborators Panel (opens share panel to collaborators tab)
function openCollaboratorsPanel() {
  openSharePanel();
  setTimeout(() => {
    shareUI?.switchTab?.('collaborators');
    shareUI?.render?.('share-container');
  }, 100);
}

// Toggle performance monitor
function togglePerfMonitor() {
  const badge = document.getElementById('perf-badge');
  if (badge) {
    badge.style.display = badge.style.display === 'none' ? 'block' : 'none';
    toast?.info?.(badge.style.display === 'block' ? 'Performance monitor enabled' : 'Performance monitor disabled');
  }
}

// Load project by ID
async function loadProjectById(projectId) {
  try {
    await projectManager.loadProject(projectId);
    toast?.success?.('Project loaded');
    a11y?.announce?.('Project loaded');
  } catch (err) {
    toast?.error?.('Failed to load project');
    console.error('[LoadProject]', err);
  }
}

// Click outside menu to close
document.addEventListener('click', (e) => {
  const menuContainer = document.getElementById('main-menu-container');
  const toggleBtn = document.getElementById('menu-toggle');
  
  if (mainMenu.isOpen && 
      menuContainer && !menuContainer.contains(e.target) &&
      toggleBtn && !toggleBtn.contains(e.target)) {
    closeMainMenu();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.26 â€” STATUS BAR, NOTIFICATIONS & UX FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Notification functions
function toggleNotifications() {
  notificationCenter.toggle();
}

function notify(type, message) {
  notificationCenter.add(type, message);
  // Also track in recent actions
  const icons = { success: 'âœ“', warning: 'âš ', error: 'âœ—', info: 'â„¹' };
  recentActions.add(icons[type] || 'â„¹', message);
}

// Context menu actions
function contextOpenProject(projectId) {
  loadProjectById(projectId);
}

function contextToggleStar(projectId) {
  const isNowStarred = starredManager.toggle(projectId);
  notify('info', isNowStarred ? 'Project starred' : 'Project unstarred');
  projectBrowserUI?.render?.('project-browser-content');
}

function contextDuplicateProject(projectId) {
  projectManager?.duplicateProject?.(projectId);
  notify('success', 'Project duplicated');
}

function contextExportProject(projectId) {
  // Load and export
  loadProjectById(projectId).then(() => {
    openExportPanel();
  });
}

function contextRenameProject(projectId) {
  const newName = prompt('Enter new project name:');
  if (newName && newName.trim()) {
    projectManager?.renameProject?.(projectId, newName.trim());
    notify('success', `Project renamed to "${newName.trim()}"`);
  }
}

function contextDeleteProject(projectId) {
  if (confirm('Delete this project? This cannot be undone.')) {
    projectManager?.deleteProject?.(projectId);
    notify('success', 'Project deleted');
    projectBrowserUI?.render?.('project-browser-content');
  }
}

function contextInspectSymbol(symbolId) {
  openMeshPanel();
  // Highlight the symbol
  toast?.info?.(`Inspecting symbol: ${symbolId}`);
}

function contextEditSymbol(symbolId) {
  openMeshPanel();
  toast?.info?.(`Editing symbol: ${symbolId}`);
}

function contextShowConnections(symbolId) {
  openChainsPanel();
  toast?.info?.(`Showing connections for: ${symbolId}`);
}

function contextCopySymbolId(symbolId) {
  navigator.clipboard?.writeText(symbolId);
  notify('success', 'Symbol ID copied to clipboard');
}

function contextDiveSymbol(symbolId) {
  openDivePanel();
  // Set the symbol as dive target
  toast?.info?.(`InceptaDive on: ${symbolId}`);
}

function contextGoToMarker(markerId) {
  const marker = annotationTimeline?.markers?.find(m => m.id === markerId);
  if (marker && playbackEngine?.seek) {
    playbackEngine.seek(marker.frame);
    notify('info', `Jumped to marker: ${marker.label}`);
  }
}

function contextEditMarker(markerId) {
  const marker = annotationTimeline?.markers?.find(m => m.id === markerId);
  if (marker) {
    annotationTimeline.selectedMarkerId = markerId;
    openAnnotationPanel();
    markerEditorUI?.render?.('marker-editor-container');
  }
}

function contextChangeMarkerColor(markerId) {
  const colors = ['#ff6b6b', '#ffc107', '#22dd64', '#22ddee', '#ee22dd', '#ffffff'];
  const marker = annotationTimeline?.markers?.find(m => m.id === markerId);
  if (marker) {
    const currentIndex = colors.indexOf(marker.color);
    const nextIndex = (currentIndex + 1) % colors.length;
    marker.color = colors[nextIndex];
    annotationTimeline?.render?.('annotation-container');
    notify('info', 'Marker color changed');
  }
}

function contextDeleteMarker(markerId) {
  if (confirm('Delete this marker?')) {
    annotationTimeline?.removeMarker?.(markerId);
    notify('success', 'Marker deleted');
  }
}

// Timeline actions
function addMarkerAtPlayhead() {
  const frame = playbackEngine?.currentFrame || 0;
  annotationTimeline?.addMarker?.({
    id: `marker_${Date.now()}`,
    frame,
    label: `Marker at ${frame}`,
    type: 'marker',
    color: '#22ddee'
  });
  notify('success', 'Marker added');
  recentActions.add('ðŸ“', `Added marker at frame ${frame}`);
}

function addChapterHere() {
  const frame = playbackEngine?.currentFrame || 0;
  const name = prompt('Chapter name:');
  if (name) {
    annotationTimeline?.addMarker?.({
      id: `chapter_${Date.now()}`,
      frame,
      label: name,
      type: 'chapter',
      color: '#ffc107'
    });
    notify('success', `Chapter "${name}" added`);
  }
}

function splitAtPlayhead() {
  const frame = playbackEngine?.currentFrame || 0;
  clipEditor?.createClip?.({
    id: `clip_${Date.now()}`,
    name: `Clip from ${frame}`,
    startFrame: frame,
    endFrame: frame + 100
  });
  notify('success', 'Created clip at playhead');
}

function startRegionSelect() {
  toast?.info?.('Click and drag on timeline to select region');
}

function zoomToFit() {
  toast?.info?.('Zoomed to fit');
}

function showGotoFrame() {
  const frame = prompt('Go to frame:');
  if (frame && !isNaN(parseInt(frame))) {
    playbackEngine?.seek?.(parseInt(frame));
    notify('info', `Jumped to frame ${frame}`);
  }
}

// Star toggle for project cards
function toggleProjectStar(projectId, event) {
  event?.stopPropagation();
  contextToggleStar(projectId);
}

// Floating actions toggle
function toggleFloatingActions() {
  floatingActions.toggle();
}

// Workspace layout switching
function applyWorkspaceLayout(layoutId) {
  workspaceLayouts.apply(layoutId);
}

// Export with preset
function exportWithPreset(presetId) {
  exportPresets.select(presetId);
  const config = exportPresets.getSelectedConfig();
  if (config) {
    // Apply config to export
    toast?.info?.(`Exporting with preset: ${presetId}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.24 â€” SYSTEM HARDENING FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function runDiagnostics() {
  const results = await systemDiagnostics.runAll();
  
  let output = `System Status: ${results.overall.toUpperCase()}\n\n`;
  
  for (const [name, check] of Object.entries(results.checks)) {
    const icon = check.healthy ? 'âœ“' : 'âœ—';
    output += `${icon} ${name}: ${check.details}\n`;
  }
  
  return output;
}

function getSystemHealth() {
  return systemDiagnostics.getSummary();
}

function checkMemory() {
  const report = memoryManager.getReport();
  
  let output = `Memory Status: ${report.status.toUpperCase()}\n`;
  
  if (report.usage.available) {
    output += `Used: ${report.usage.usedMB}MB / ${report.usage.totalMB}MB (${report.usage.percentUsed}%)\n`;
    output += `Limit: ${report.usage.limitMB}MB\n`;
  }
  
  if (report.recommendations.length > 0) {
    output += `\nRecommendations:\n`;
    report.recommendations.forEach(r => output += `â€¢ ${r}\n`);
  }
  
  return output;
}

function forceMemoryCleanup() {
  const cleaned = memoryManager.cleanup();
  return cleaned ? 'Memory cleanup performed' : 'No cleanup needed';
}

async function checkDataIntegrity() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    return 'No recording data to check';
  }
  
  const result = integrityChecker.fullCheck(container);
  
  let output = result.valid ? 'âœ“ Data integrity verified\n' : 'âœ— Issues found\n';
  output += `Frames checked: ${result.stats.framesChecked}\n`;
  output += `Symbols checked: ${result.stats.symbolsChecked}\n`;
  
  if (!result.valid) {
    output += `\nIssues:\n`;
    result.issues.forEach(i => output += `â€¢ ${i}\n`);
  }
  
  return output;
}

async function repairData() {
  const container = orch?.getContainer();
  if (!container) {
    return 'No recording data to repair';
  }
  
  const result = integrityChecker.repair(container);
  
  if (result.repaired) {
    let output = 'Repairs performed:\n';
    result.fixes.forEach(f => output += `â€¢ ${f}\n`);
    return output;
  } else {
    return 'No repairs needed';
  }
}

function validateProject(project) {
  if (!project) {
    project = projectManager?.currentProject;
  }
  
  if (!project) {
    return 'No project to validate';
  }
  
  const result = dataValidator.validate('project', project);
  
  if (result.valid) {
    return 'âœ“ Project data is valid';
  } else {
    let output = 'âœ— Project validation failed:\n';
    result.errors.forEach(e => output += `â€¢ ${e}\n`);
    return output;
  }
}

function getStateHistory() {
  const report = stateValidator.getReport();
  
  let output = `State Transitions: ${report.totalTransitions}\n`;
  output += `Invalid: ${report.invalidTransitions}\n`;
  output += `Current State: ${report.lastState || 'unknown'}\n`;
  
  if (report.recentHistory.length > 0) {
    output += `\nRecent:\n`;
    report.recentHistory.slice(-5).forEach(t => {
      const icon = t.valid ? 'â†’' : 'âš ';
      output += `${icon} ${t.from} â†’ ${t.to}\n`;
    });
  }
  
  return output;
}

function getAutoSaveStatus() {
  const backups = autoSaveManager.getBackups();
  const lastSave = autoSaveManager.getLastSaveTime();
  
  let output = 'Auto-Save Status\n';
  output += `Last save: ${lastSave ? new Date(lastSave).toLocaleTimeString() : 'Never'}\n`;
  output += `Backups: ${backups.length}\n`;
  
  if (backups.length > 0) {
    output += `\nRecent backups:\n`;
    backups.slice(0, 3).forEach(b => {
      output += `â€¢ ${new Date(b.timestamp).toLocaleString()} - ${b.project?.name || 'Unknown'}\n`;
    });
  }
  
  return output;
}

function forceAutoSave() {
  const saved = autoSaveManager.save();
  return saved ? 'Auto-save completed' : 'Auto-save failed';
}

function clearAutoSaveBackups() {
  autoSaveManager.clearBackups();
  return 'Auto-save backups cleared';
}

// Diagnostic panel
function openDiagnosticsPanel() {
  runDiagnostics().then(results => {
    const output = document.getElementById('query-output');
    if (output) {
      output.innerHTML = `<pre style="white-space: pre-wrap; font-size: 11px;">${results}</pre>`;
    }
    switchTab?.('query');
    openPanel?.();
  });
}

async function setCameraResolution(res) {
  await cameraManager.setResolution(res);
  cameraControlsUI.render('camera-container');
  a11y.announce(`Resolution set to ${res.toUpperCase()}`);
}

async function setCameraFPS(fps) {
  await cameraManager.setFPS(fps);
  cameraControlsUI.render('camera-container');
  a11y.announce(`Frame rate set to ${fps} FPS`);
}

async function toggleCameraFacing() {
  const mode = await cameraManager.toggleFacingMode();
  cameraControlsUI.render('camera-container');
  a11y.announce(`Switched to ${mode === 'user' ? 'front' : 'back'} camera`);
}

async function setCameraZoom(level) {
  await cameraManager.setZoom(parseFloat(level));
  a11y.announce(`Zoom set to ${level}x`);
}

async function toggleCameraTorch() {
  const on = await cameraManager.toggleTorch();
  cameraControlsUI.render('camera-container');
  a11y.announce(`Torch ${on ? 'on' : 'off'}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.17 â€” PERFORMANCE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showPerfBadge() {
  const badge = document.getElementById('perf-badge');
  if (badge) {
    badge.style.display = 'block';
    updatePerfBadge();
  }
}

function hidePerfBadge() {
  const badge = document.getElementById('perf-badge');
  if (badge) badge.style.display = 'none';
}

function updatePerfBadge() {
  const badge = document.getElementById('perf-badge');
  if (!badge || badge.style.display === 'none') return;
  
  const metrics = perfOptimizer.getMetrics();
  badge.textContent = `FPS: ${metrics.fps} | Mem: ${metrics.memory.toFixed(0)}MB`;
  
  badge.classList.remove('warning', 'critical');
  if (metrics.fps < 20) {
    badge.classList.add('critical');
  } else if (metrics.fps < 25) {
    badge.classList.add('warning');
  }
  
  requestAnimationFrame(updatePerfBadge);
}

function togglePerfMonitor() {
  const badge = document.getElementById('perf-badge');
  if (badge.style.display === 'none') {
    showPerfBadge();
    toast.info('Performance monitor enabled');
  } else {
    hidePerfBadge();
    toast.info('Performance monitor disabled');
  }
}

function getPerformanceReport() {
  const metrics = perfOptimizer.getMetrics();
  return `PERFORMANCE REPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FPS: ${metrics.fps}
Memory: ${metrics.memory.toFixed(2)} MB
Throttle Level: ${metrics.throttleLevel}
Frame Drops: ${metrics.frameDrops}
Memory Supported: ${metrics.memorySupported}`;
}

function updateSymbolicVisualizations() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) return;
  
  // Update mesh if panel is open
  if (document.getElementById('mesh-panel').classList.contains('open')) {
    symbolMesh.buildFromContainer(container);
    symbolMesh.render();
  }
  
  // Update chains if panel is open
  if (document.getElementById('chain-panel').classList.contains('open')) {
    causalChain.buildFromContainer(container);
    causalChain.render();
  }
  
  // Update dive if panel is open
  if (document.getElementById('dive-panel').classList.contains('open')) {
    inceptaDive.render();
  }
  
  // Update ontology if panel is open
  if (document.getElementById('ontology-panel').classList.contains('open')) {
    symbolOntology.countFromContainer(container);
    symbolOntology.render();
  }
  
  // Update audio if panel is open
  if (document.getElementById('audio-panel').classList.contains('open')) {
    audioWaveform.extractFromContainer(container);
    audioWaveform.render();
  }
  
  // Update motion if panel is open
  if (document.getElementById('motion-panel').classList.contains('open')) {
    motionOverlay.buildFromContainer(container);
    motionOverlay.render();
  }
}

async function checkPermissions() {
  // Camera
  try {
    const cam = await navigator.permissions.query({ name: 'camera' });
    document.getElementById('perm-camera').textContent = cam.state;
    document.getElementById('perm-camera').className = 'perm-status ' + cam.state;
  } catch (e) { document.getElementById('perm-camera').textContent = 'N/A'; }
  
  // Microphone
  try {
    const mic = await navigator.permissions.query({ name: 'microphone' });
    document.getElementById('perm-mic').textContent = mic.state;
    document.getElementById('perm-mic').className = 'perm-status ' + mic.state;
  } catch (e) { document.getElementById('perm-mic').textContent = 'N/A'; }
  
  // Location
  try {
    const geo = await navigator.permissions.query({ name: 'geolocation' });
    document.getElementById('perm-location').textContent = geo.state;
    document.getElementById('perm-location').className = 'perm-status ' + geo.state;
  } catch (e) { document.getElementById('perm-location').textContent = 'N/A'; }
  
  // Motion
  if (window.DeviceMotionEvent) {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      document.getElementById('perm-motion').textContent = 'iOS (tap to enable)';
      document.getElementById('perm-motion').className = 'perm-status prompt';
    } else {
      document.getElementById('perm-motion').textContent = 'Available';
      document.getElementById('perm-motion').className = 'perm-status granted';
    }
  } else {
    document.getElementById('perm-motion').textContent = 'Not supported';
    document.getElementById('perm-motion').className = 'perm-status denied';
  }
}

async function retryPermissions() {
  const gpsState = SensorState.get('gps');
  if (gpsState.status === 'denied' && gpsState.enabled) {
    const isChrome = /Chrome/.test(navigator.userAgent);
    const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
    const isFirefox = /Firefox/.test(navigator.userAgent);
    
    let instructions = 'To enable GPS:\n\n';
    if (isChrome) {
      instructions += '1. Click the ðŸ”’ icon in the address bar\n2. Click "Site settings"\n3. Set Location to "Allow"\n4. Reload the page';
    } else if (isSafari) {
      instructions += '1. Go to Safari â†’ Settings â†’ Websites â†’ Location\n2. Find this site and set to "Allow"\n3. Reload the page';
    } else if (isFirefox) {
      instructions += '1. Click the ðŸ”’ icon in the address bar\n2. Click "Clear cookies and site data" or modify permissions\n3. Reload and allow location';
    } else {
      instructions += '1. Check browser settings for location permissions\n2. Allow location for this site\n3. Reload the page';
    }
    instructions += '\n\nOr use the manual/IP location options below.';
    alert(instructions);
    document.getElementById('manual-location-wrap').classList.add('visible');
  }
  
  // iOS motion
  if (typeof DeviceMotionEvent?.requestPermission === 'function') {
    try {
      const result = await DeviceMotionEvent.requestPermission();
      if (result === 'granted') {
        initMotion();
      }
    } catch (e) {
      SensorState.setPermission('motion', 'denied', 'Permission denied');
    }
  }
  
  await checkPermissions();
}

function openSettings() {
  document.getElementById('settings-panel').classList.add('open');
  document.getElementById('settings-backdrop').classList.add('open');
  checkPermissions();
  
  // Sync toggle switches with current state
  Object.keys(SensorState.sensors).forEach(sensor => {
    const sw = document.getElementById(`switch-${sensor}`);
    if (sw) sw.checked = SensorState.sensors[sensor].enabled;
  });
}

function closeSettings() {
  document.getElementById('settings-panel').classList.remove('open');
  document.getElementById('settings-backdrop').classList.remove('open');
}

function openTheoryPanel() {
  document.getElementById('theory-panel').classList.add('open');
  document.getElementById('theory-backdrop').classList.add('open');
  
  // Update immediately
  updateTheoryPanel();
  
  // Set up periodic refresh while panel is open
  if (!window.theoryPanelInterval) {
    window.theoryPanelInterval = setInterval(() => {
      if (document.getElementById('theory-panel').classList.contains('open')) {
        updateTheoryPanel();
      }
    }, 500);
  }
}

function closeTheoryPanel() {
  document.getElementById('theory-panel').classList.remove('open');
  document.getElementById('theory-backdrop').classList.remove('open');
  
  // Clear interval when panel closes
  if (window.theoryPanelInterval) {
    clearInterval(window.theoryPanelInterval);
    window.theoryPanelInterval = null;
  }
}

function updateTheoryPanel() {
  const container = orch.getContainer();
  const analyzerSummary = theoreticalAnalyzer.getSummary();
  
  DEBUG.theory_log('updateTheoryPanel', {
    hasContainer: !!container,
    framesCount: container?.frames?.length || 0,
    analyzerHistory: analyzerSummary?.totalAnalyses || 0
  });
  
  // Enhanced helpers
  const setVal = (id, value, decimals = 3) => {
    const el = document.getElementById(id);
    if (!el) return;
    const hasValue = value !== null && value !== undefined && !isNaN(value);
    el.textContent = hasValue ? Number(value).toFixed(decimals) : 'â€”';
    // Add visual class based on value
    el.classList.remove('positive', 'negative', 'neutral');
    if (hasValue) {
      const n = Number(value);
      if (n > 0.7) el.classList.add('positive');
      else if (n > 0.4) el.classList.add('neutral');
    }
  };
  
  const setSub = (id, text) => {
    const el = document.getElementById(id);
    if (el) el.textContent = text || '';
  };
  
  const setCardActive = (id, hasData) => {
    const card = document.getElementById(id);
    if (card) {
      card.classList.toggle('has-data', hasData);
    }
  };
  
  // Get data from frame or analyzer history
  let t = null;
  
  if (container && container.frames.length > 0) {
    // Find the most recent frame with theoretical data
    for (let i = container.frames.length - 1; i >= 0 && !t; i--) {
      if (container.frames[i].theoretical) {
        t = container.frames[i].theoretical;
      }
    }
  }
  
  // Fallback to analyzer summary if no frame data
  if (!t && analyzerSummary && analyzerSummary.totalAnalyses > 0) {
    DEBUG.theory_log('Using analyzer summary fallback');
    setVal('td-info-val', analyzerSummary.avgNovelty);
    setVal('td-topo-val', analyzerSummary.avgContinuity);
    setVal('td-dyn-val', analyzerSummary.avgStability);
    setVal('td-group-val', analyzerSummary.avgSymmetry);
    setVal('td-diffgeo-val', analyzerSummary.avgCoherence);
    setVal('td-spectral-val', analyzerSummary.avgFlatness);
    setVal('td-thermo-val', analyzerSummary.avgOrder);
    setVal('td-score', analyzerSummary.avgScore, 0);
    
    const phaseEl = document.getElementById('td-phase');
    if (phaseEl) {
      phaseEl.textContent = analyzerSummary.avgPhase || 'analyzing...';
      phaseEl.className = 'theory-phase-badge ' + (analyzerSummary.avgPhase || 'unknown');
    }
    return;
  }
  
  if (!t) {
    DEBUG.theory_log('No theoretical data available');
    // Show placeholder message
    ['td-info-val', 'td-topo-val', 'td-causal-val', 'td-graph-val', 'td-dyn-val', 
     'td-measure-val', 'td-group-val', 'td-diffgeo-val', 'td-spectral-val', 
     'td-thermo-val', 'td-category-val', 'td-score'].forEach(id => setVal(id, null));
    const phaseEl = document.getElementById('td-phase');
    if (phaseEl) {
      phaseEl.textContent = 'waiting...';
      phaseEl.className = 'theory-phase-badge unknown';
    }
    return;
  }
  
  // Update all 11 theory cards with data
  
  // 1. Information Theory
  setVal('td-info-val', t.information?.entropy?.total);
  setSub('td-info-sub', `Novelty: ${U.formatNum(t.information?.novelty)}`);
  setCardActive('td-info', !!t.information);
  
  // 2. Topology
  setVal('td-topo-val', t.topology?.continuity);
  setSub('td-topo-sub', `${t.topology?.components || 0} comp â€¢ ${t.topology?.stability || 'stable'}`);
  setCardActive('td-topo', !!t.topology);
  
  // 3. Causal Structure
  setVal('td-causal-val', t.causal?.causalStrength);
  setSub('td-causal-sub', `${t.causal?.interventions?.length || 0} interventions`);
  setCardActive('td-causal', !!t.causal);
  
  // 4. Graph Theory
  setVal('td-graph-val', t.graph?.avgClustering);
  setSub('td-graph-sub', `${t.graph?.nodes || 0}N â€¢ ${t.graph?.edges || 0}E`);
  setCardActive('td-graph', !!t.graph);
  
  // 5. Dynamical Systems
  setVal('td-dyn-val', t.dynamics?.stability);
  setSub('td-dyn-sub', `Î»=${U.formatNum(t.dynamics?.lyapunov, 3)} â€¢ ${t.dynamics?.attractors || 0} attr`);
  setCardActive('td-dyn', !!t.dynamics);
  
  // 6. Measure Theory
  setVal('td-measure-val', t.uncertainty?.confidence);
  setSub('td-measure-sub', `Ïƒ=${U.formatNum(t.uncertainty?.fusedUncertainty, 3)}`);
  setCardActive('td-measure', !!t.uncertainty);
  
  // 7. Group Theory
  setVal('td-group-val', t.symmetry?.radialSymmetry);
  setSub('td-group-sub', `H:${U.formatNum(t.symmetry?.reflectionH)} V:${U.formatNum(t.symmetry?.reflectionV)}`);
  setCardActive('td-group', !!t.symmetry);
  
  // 8. Differential Geometry
  setVal('td-diffgeo-val', t.geometry?.meanCurvature, 4);
  setSub('td-diffgeo-sub', `Type: ${t.geometry?.curvatureType || 'flat'}`);
  setCardActive('td-diffgeo', !!t.geometry);
  
  // 9. Spectral Analysis
  setVal('td-spectral-val', t.spectral?.flatness);
  setSub('td-spectral-sub', `Centroid: ${U.formatNum(t.spectral?.centroid)}`);
  setCardActive('td-spectral', !!t.spectral);
  
  // 10. Statistical Mechanics
  setVal('td-thermo-val', t.thermodynamics?.entropy);
  setSub('td-thermo-sub', `E=${U.formatNum(t.thermodynamics?.energy, 3)} â€¢ T=${U.formatNum(t.thermodynamics?.temperature, 4)}`);
  setCardActive('td-thermo', !!t.thermodynamics);
  
  // 11. Category Theory
  setVal('td-category-val', t.category?.connectivity);
  setSub('td-category-sub', `${t.category?.objects || 0} obj â€¢ ${t.category?.morphisms || 0} morph`);
  setCardActive('td-category', !!t.category);
  
  // Phase state with enhanced display
  const phaseEl = document.getElementById('td-phase');
  const phase = t.thermodynamics?.phase || 'unknown';
  if (phaseEl) {
    phaseEl.textContent = phase.toUpperCase();
    phaseEl.className = 'theory-phase-badge ' + phase;
  }
  
  // Thermodynamic details
  setVal('td-temp', t.thermodynamics?.temperature, 4);
  setVal('td-free', t.thermodynamics?.freeEnergy, 4);
  setVal('td-order', t.thermodynamics?.orderParameter);
  
  // Composite score with color coding
  const scoreEl = document.getElementById('td-score');
  if (scoreEl) {
    const score = t.theoreticalScore || 0;
    scoreEl.textContent = score.toFixed(0);
    scoreEl.style.color = score > 70 ? 'var(--success)' : score > 40 ? 'var(--warning)' : 'var(--accent-cyan)';
  }
}

function setManualLocation() {
  const latInput = document.getElementById('manual-lat');
  const lngInput = document.getElementById('manual-lng');
  const lat = parseFloat(latInput.value);
  const lng = parseFloat(lngInput.value);
  
  if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
    alert('Please enter valid coordinates.\nLatitude: -90 to 90\nLongitude: -180 to 180');
    return;
  }
  
  const data = { lat, lng, accuracy: 1000, source: 'manual' };
  orch.coordinator.update('gps', data, U.timestamp(), 0.5);
  const valEl = document.getElementById('val-gps');
  valEl.textContent = `${lat.toFixed(4)}`;
  valEl.title = `Lat: ${lat.toFixed(6)}\nLng: ${lng.toFixed(6)}`;
  document.getElementById('meta-gps-acc').textContent = `${lng.toFixed(4)}`;
  document.getElementById('meta-gps-age').textContent = 'Â±1km';
  SensorState.update('gps', { permission: 'granted', health: 'healthy', hasData: true, note: 'Manual' });
  Log.ok('sensor', `GPS set manually: ${lat}, ${lng}`);
}

async function useIPLocation() {
  try {
    document.getElementById('btn-use-ip-location').textContent = 'â³ Getting location...';
    
    let data = null;
    
    try {
      const resp = await fetch('https://ipapi.co/json/');
      if (resp.ok) {
        const json = await resp.json();
        data = { lat: json.latitude, lng: json.longitude, city: json.city, country: json.country_name };
      }
    } catch (e) {
      try {
        const resp = await fetch('https://ip-api.com/json/');
        if (resp.ok) {
          const json = await resp.json();
          data = { lat: json.lat, lng: json.lon, city: json.city, country: json.country };
        }
      } catch (e2) {}
    }
    
    if (data && data.lat && data.lng) {
      document.getElementById('manual-lat').value = data.lat;
      document.getElementById('manual-lng').value = data.lng;
      
      const gpsData = { lat: data.lat, lng: data.lng, accuracy: 5000, source: 'ip', city: data.city, country: data.country };
      orch.coordinator.update('gps', gpsData, U.timestamp(), 0.8);
      const valEl = document.getElementById('val-gps');
      valEl.textContent = `${data.lat.toFixed(4)}`;
      valEl.title = `Lat: ${data.lat.toFixed(6)}\nLng: ${data.lng.toFixed(6)}\nCity: ${data.city || 'Unknown'}`;
      document.getElementById('meta-gps-acc').textContent = `${data.lng.toFixed(4)}`;
      document.getElementById('meta-gps-age').textContent = data.city ? `~${data.city.slice(0,6)}` : '~IP';
      SensorState.update('gps', { permission: 'granted', health: 'healthy', hasData: true, note: `IP: ${data.city || ''}` });
      Log.ok('sensor', `GPS from IP: ${data.city}, ${data.country}`);
      
      document.getElementById('btn-use-ip-location').textContent = 'âœ“ Location set';
      setTimeout(() => { document.getElementById('btn-use-ip-location').textContent = 'ðŸ“¡ Use IP-based Location'; }, 2000);
    } else {
      throw new Error('Could not get IP location');
    }
  } catch (e) {
    document.getElementById('btn-use-ip-location').textContent = 'âŒ Failed - try manual';
    Log.warn('sensor', 'IP location failed: ' + e.message);
    setTimeout(() => { document.getElementById('btn-use-ip-location').textContent = 'ðŸ“¡ Use IP-based Location'; }, 3000);
  }
}

async function initCamera() {
  try {
    const audioEnabled = SensorState.sensors.audio.enabled;
    app.stream = await navigator.mediaDevices.getUserMedia({ 
      video: { facingMode: app.facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }, 
      audio: audioEnabled 
    });
    app.video = document.getElementById('video');
    app.video.srcObject = app.stream;
    if (app.facingMode === 'user') app.video.classList.add('mirror');
    await app.video.play();
    app.vfCanvas = document.getElementById('vf-canvas');
    app.frameCanvas = document.getElementById('frame-canvas');
    const track = app.stream.getVideoTracks()[0];
    const settings = track.getSettings();
    orch.coordinator.update('video', { active: true, width: settings.width, height: settings.height });
    document.getElementById('val-video').textContent = 'Active';
    document.getElementById('meta-video-fps').textContent = `${orch.config.targetFPS}fps`;
    document.getElementById('meta-video-res').textContent = `${settings.width}Ã—${settings.height}`;
    SensorState.update('video', { permission: 'granted', health: 'healthy', hasData: true });
    Log.ok('sensor', 'Camera initialized');
    return true;
  } catch (e) { 
    orch.coordinator.error('video', e.message); 
    SensorState.update('video', { permission: 'denied', health: 'failed', note: e.message });
    Log.error('sensor', 'Camera: ' + e.message); 
    return false; 
  }
}

async function initAudio() {
  if (!SensorState.sensors.audio.enabled) {
    SensorState.update('audio', { enabled: false, note: 'Disabled by user' });
    document.getElementById('val-audio').textContent = 'Off';
    return false;
  }
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    app.audioCtx = new AC();
    app.audioAnalyser = app.audioCtx.createAnalyser();
    app.audioAnalyser.fftSize = 64;
    app.audioData = new Uint8Array(app.audioAnalyser.frequencyBinCount);
    const source = app.audioCtx.createMediaStreamSource(app.stream);
    source.connect(app.audioAnalyser);
    orch.coordinator.update('audio', { active: true, sampleRate: app.audioCtx.sampleRate });
    document.getElementById('val-audio').textContent = 'Active';
    document.getElementById('meta-audio-freq').textContent = `${app.audioCtx.sampleRate}Hz`;
    SensorState.update('audio', { permission: 'granted', health: 'healthy', hasData: true });
    Log.ok('sensor', 'Audio initialized');
    return true;
  } catch (e) { 
    orch.coordinator.error('audio', e.message); 
    SensorState.update('audio', { permission: 'denied', health: 'failed', note: e.message });
    Log.warn('sensor', 'Audio: ' + e.message); 
    return false; 
  }
}

function initGPS() {
  if (!SensorState.sensors.gps.enabled) {
    SensorState.update('gps', { enabled: false, note: 'Disabled by user' });
    document.getElementById('val-gps').textContent = 'Off';
    return;
  }
  if (!('geolocation' in navigator)) { 
    document.getElementById('val-gps').textContent = 'N/A'; 
    SensorState.update('gps', { permission: 'denied', health: 'failed', note: 'Geolocation not supported' });
    return; 
  }
  
  document.getElementById('val-gps').textContent = 'Locating...';
  SensorState.update('gps', { permission: 'prompt', health: 'init', note: 'Requesting location...' });
  
  const update = pos => {
    const data = { lat: pos.coords.latitude, lng: pos.coords.longitude, accuracy: pos.coords.accuracy, source: 'gps' };
    orch.coordinator.update('gps', data, U.timestamp(), Math.min(0.5, pos.coords.accuracy / 100));
    const valEl = document.getElementById('val-gps');
    valEl.textContent = `${data.lat.toFixed(4)}`;
    valEl.title = `Lat: ${data.lat.toFixed(6)}\nLng: ${data.lng.toFixed(6)}`;
    document.getElementById('meta-gps-acc').textContent = `${data.lng.toFixed(4)}`;
    document.getElementById('meta-gps-age').textContent = `Â±${Math.round(data.accuracy)}m`;
    // SensorState auto-updated via EventBus
  };
  
  const handleError = err => {
    let msg = err.code === 1 ? 'Permission denied' : err.code === 2 ? 'Position unavailable' : err.code === 3 ? 'Timeout' : 'Unknown';
    document.getElementById('val-gps').textContent = 'âš™ï¸ Settings';
    document.getElementById('meta-gps-acc').textContent = 'â€”';
    document.getElementById('meta-gps-age').textContent = msg;
    
    if (err.code === 1) {
      SensorState.update('gps', { permission: 'denied', health: 'failed', note: 'Permission denied' });
    } else {
      SensorState.handleError('gps', msg);
    }
    orch.coordinator.error('gps', msg);
  };
  
  navigator.geolocation.getCurrentPosition(
    pos => { update(pos); Log.ok('sensor', 'GPS acquired'); }, 
    handleError, 
    { enableHighAccuracy: true, timeout: 15000, maximumAge: 30000 }
  );
  
  navigator.geolocation.watchPosition(update, () => {}, { enableHighAccuracy: true, maximumAge: 30000 });
}

function initMotion() {
  if (!SensorState.sensors.motion.enabled) {
    SensorState.update('motion', { enabled: false, note: 'Disabled by user' });
    document.getElementById('val-motion').textContent = 'Off';
    return;
  }
  if (!window.DeviceMotionEvent) { 
    document.getElementById('val-motion').textContent = 'N/A'; 
    SensorState.update('motion', { permission: 'denied', health: 'failed', note: 'Not supported' });
    return; 
  }
  const enable = () => {
    window.addEventListener('devicemotion', e => { 
      const a = e.acceleration || e.accelerationIncludingGravity; 
      if (a) {
        orch.coordinator.update('motion', { accel: { x: a.x || 0, y: a.y || 0, z: a.z || 0 }, rotationRate: e.rotationRate });
        // SensorState auto-updated via EventBus
      }
    });
    window.addEventListener('deviceorientation', e => { 
      const current = orch.coordinator.get('motion') || {}; 
      orch.coordinator.update('motion', { ...current, orientation: { alpha: e.alpha, beta: e.beta, gamma: e.gamma } }); 
      document.getElementById('val-motion').textContent = `${e.beta?.toFixed(0) || 0}Â°`;
      // SensorState auto-updated via EventBus
    });
    SensorState.update('motion', { permission: 'granted', health: 'healthy', hasData: true });
    Log.ok('sensor', 'Motion enabled');
  };
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    document.getElementById('val-motion').textContent = 'Tap âš™ï¸';
    SensorState.update('motion', { permission: 'prompt', note: 'Tap Settings â†’ Retry to enable on iOS' });
  } else {
    enable();
  }
}

function initDevice() {
  if (!SensorState.sensors.env.enabled) {
    SensorState.update('env', { enabled: false, note: 'Disabled by user' });
    document.getElementById('val-env').textContent = 'Off';
    return;
  }
  const info = { userAgent: navigator.userAgent, platform: navigator.platform, screen: { width: screen.width, height: screen.height } };
  orch.coordinator.update('env', { device: info, light: null });
  const name = /iPhone/.test(navigator.userAgent) ? 'iPhone' : /Android/.test(navigator.userAgent) ? 'Android' : 'Device';
  document.getElementById('val-env').textContent = name;
  document.getElementById('meta-env-src').textContent = 'device';
  SensorState.update('env', { permission: 'granted', health: 'healthy', hasData: true, note: 'Derived from video' });
  Log.ok('sensor', 'Device info captured');
}

function mainLoop() {
  // v2.26: Performance monitoring
  perfMonLegacy.tick();
  
  try {
    // Update audio (only if enabled and initialized)
    if (app.audioAnalyser && SensorState.sensors.audio.enabled) {
      app.audioAnalyser.getByteFrequencyData(app.audioData);
      const arr = Array.from(app.audioData);
      const volume = arr.reduce((a,b)=>a+b,0) / arr.length / 255;
      const peak = Math.max(...arr) / 255;
      orch.coordinator.update('audio', { volume, peak, spectrum: arr.slice(0,16), clipping: peak > 0.95 });
      document.getElementById('val-audio').textContent = `${Math.round(volume*100)}%`;
      document.getElementById('meta-audio-clip').textContent = peak > 0.95 ? 'CLIP' : 'OK';
      // SensorState auto-updated via EventBus
    }
  
  // Capture visual fingerprint
  if (app.video && app.vfCanvas && app.video.readyState >= 2) {
    const ctx = app.vfCanvas.getContext('2d');
    ctx.drawImage(app.video, 0, 0, app.vfCanvas.width, app.vfCanvas.height);
    const vf = new VisualFingerprintSymbol(app.vfCanvas, app.lastVF);
    app.lastVF = vf;
    orch.coordinator.update('visual', vf.data);
    orch.coordinator.update('video', { active: true, timestamp: U.timestamp() });
    // SensorState auto-updated via EventBus
    
    // Derive light from visual (if env enabled)
    if (SensorState.sensors.env.enabled) {
      const lightLevel = vf.stats.luminance * 500;
      const currentEnv = orch.coordinator.get('env') || {};
      orch.coordinator.update('env', { ...currentEnv, light: { level: lightLevel, source: 'visual' } });
      document.getElementById('val-env').textContent = `${Math.round(lightLevel)} lux`;
      document.getElementById('meta-env-conf').textContent = `${(vf.confidence*100).toFixed(0)}%`;
      // SensorState auto-updated via EventBus
    }
    
    renderVFGrid(vf.grid, 'vf-grid');
    document.getElementById('vf-lum').textContent = `L:${Math.round(vf.stats.luminance*100)}%`;
    document.getElementById('vf-mot').textContent = `M:${Math.round(vf.motionDelta*100)}%`;
    document.getElementById('vf-hash').textContent = vf.dHash.slice(0,6);
    
    if (app.showWH) {
      document.getElementById('wh-what').textContent = vf.sceneType || 'â€”';
      document.getElementById('wh-how').textContent = vf.wh.how || 'â€”';
      const gps = orch.coordinator.get('gps');
      document.getElementById('wh-where').textContent = gps?.lat ? `${gps.lat.toFixed(2)}Â°,${gps.lng.toFixed(2)}Â°` : (gps?.city || 'â€”');
      document.getElementById('wh-when').textContent = new Date().toLocaleTimeString();
      
      // Theoretical measures from visual fingerprint
      const entropyEl = document.getElementById('wh-entropy');
      const topoEl = document.getElementById('wh-topo');
      const symEl = document.getElementById('wh-symmetry');
      
      if (vf.entropy) {
        entropyEl.textContent = `H=${vf.entropy.total.toFixed(2)} (L:${vf.entropy.luminance.toFixed(2)})`;
      }
      if (vf.topology) {
        topoEl.textContent = `Ï„=${vf.topology.continuity.toFixed(2)} C:${vf.topology.components.count}`;
      }
      
      // Compute symmetry on the fly for preview
      const symmetry = GroupTheory.computeInvariants(vf.grid);
      symEl.textContent = `R:${symmetry.rotation.radialSymmetry.toFixed(2)} H:${symmetry.reflection.horizontal.toFixed(2)}`;
      
      if (orch.getState() === 'recording') {
        const container = orch.getContainer();
        const lastFrame = container?.frames[container.frames.length - 1];
        document.getElementById('wh-why').textContent = lastFrame?.wh.why || 'capture';
        document.getElementById('wh-because').textContent = lastFrame?.wh.because || 'normal_sequence';
        
        // Update with full theoretical analysis from frame
        if (lastFrame?.theoretical) {
          const t = lastFrame.theoretical;
          if (t.information?.entropy) entropyEl.textContent = `H=${t.information.entropy.total.toFixed(2)} I:${(t.information.novelty || 0).toFixed(2)}`;
          if (t.topology) topoEl.textContent = `Ï„=${t.topology.continuity.toFixed(2)} ${t.topology.stability}`;
          if (t.symmetry) symEl.textContent = `R:${t.symmetry.radialSymmetry.toFixed(2)} Îº:${(t.geometry?.meanCurvature || 0).toFixed(3)}`;
        }
      } else {
        document.getElementById('wh-why').textContent = 'preview';
        document.getElementById('wh-because').textContent = 'not_recording';
      }
    }
  }
  
  // Recording pipeline
  if (orch.getState() === 'recording') {
    const frameData = orch.runPipeline();
    if (frameData) {
      let videoFrame = null;
      if (orch.mode === 'full' && app.frameCanvas && app.video.readyState >= 2) {
        const ctx = app.frameCanvas.getContext('2d');
        ctx.drawImage(app.video, 0, 0, app.frameCanvas.width, app.frameCanvas.height);
        videoFrame = new VideoFrameSymbol(app.frameCanvas);
      }
      const processed = orch.processBuffer(videoFrame, app.lastVF);
      updateRecordingUI();
      
      // Debug: Log frame counts
      const frameCount = orch.getContainer()?.frames?.length || 0;
      if (frameCount > 0 && frameCount <= 5) {
        console.log('[MainLoop] Processed frame, container now has', frameCount, 'frames');
      }
      
      // v2.26: Update floating actions with frame count changes
      if (frameCount > 0 && frameCount % 10 === 0) {
        floatingActions?.render?.();
      }
    }
  } else if (recordingController?.getState() === 'recording' && orch.getState() !== 'recording') {
    // State mismatch detected! This means orch failed to start
    console.warn('[v2.26] State mismatch: RecordingController is recording but Orchestrator is not');
    console.warn('[v2.26] Orchestrator state:', orch.getState());
    // Auto-fix: Try to sync states
    if (orch.getState() === 'ready') {
      console.warn('[v2.26] Attempting to restart orchestrator recording...');
      const restarted = orch.startRecording();
      console.warn('[v2.26] Restart result:', restarted);
    }
  }
  
  // Update sensor health
  // Update sensor UI (confidence bars and uncertainty)
  ['video', 'audio', 'visual', 'gps', 'motion', 'env'].forEach(name => {
    const fullHealth = orch.coordinator.getFullHealth(name);
    const confEl = document.getElementById(`conf-${name}`);
    const uncEl = document.getElementById(`unc-${name}`);
    if (confEl) confEl.style.width = (fullHealth.quality * 100) + '%';
    if (uncEl) uncEl.textContent = `Ïƒ: ${(fullHealth.uncertainty * 100).toFixed(1)}%`;
  });
  updateCausalCanvas();
  } catch (err) {
    Log.error('mainLoop', err.message || err);
    console.error('MainLoop error:', err);
  }
  requestAnimationFrame(mainLoop);
}

function updateRecordingUI() {
  const container = orch.getContainer();
  if (!container) return;
  const elapsed = U.timestamp() - orch.startTime;
  const validation = container.getValidation();
  const sensorSummary = SensorState.getSummary();
  
  document.getElementById('rec-time').textContent = U.formatTime(elapsed);
  document.getElementById('rec-frames').textContent = container.frames.length + 'f';
  document.getElementById('info-frames').textContent = container.frames.length + ' frames';
  document.getElementById('info-symbols').textContent = container.symbols.size + ' symbols';
  document.getElementById('info-size').textContent = U.formatSize(container.totalSize);
  
  // Get theoretical analysis summary
  const theorySummary = orch.getTheoreticalSummary();
  
  // Combined reality score: validation weighted by sensor health and theoretical score
  const sensorFactor = sensorSummary.healthPercent / 100;
  const theoryFactor = theorySummary ? theorySummary.avgScore / 100 : 0.5;
  const adjustedScore = Math.round(validation.score * (0.5 + 0.25 * sensorFactor + 0.25 * theoryFactor));
  
  const scoreEl = document.getElementById('metric-score');
  scoreEl.textContent = adjustedScore + '%';
  scoreEl.title = `Base: ${validation.score}% | Sensor: ${sensorSummary.healthPercent}% | Theory: ${theorySummary?.avgScore?.toFixed(0) || 0}%`;
  scoreEl.classList.remove('high', 'medium', 'low');
  if (adjustedScore >= 80) scoreEl.classList.add('high');
  else if (adjustedScore >= 50) scoreEl.classList.add('medium');
  else scoreEl.classList.add('low');
  
  document.getElementById('metric-int').textContent = validation.integrity.score;
  document.getElementById('metric-cont').textContent = validation.continuity.score;
  document.getElementById('metric-qual').textContent = validation.quality.score;
  const causal = container.getCausalSummary();
  document.getElementById('causal-count').textContent = causal.totalInferences + ' inf';
  document.getElementById('causal-depth').textContent = 'd:' + container.getMaxDepth();
  
  // Update theoretical metrics panel
  updateTheoreticalMetrics(container);
}

function updateTheoreticalMetrics(container) {
  const lastFrame = container?.frames[container.frames.length - 1];
  const theory = lastFrame?.theoretical;
  
  // Debug logging (only when DEBUG enabled)
  if (container?.frames?.length > 0 && container.frames.length % 10 === 0) {
    DEBUG.theory_log('Metrics update', {
      frameCount: container.frames.length,
      hasTheory: !!theory,
      score: theory?.theoreticalScore
    });
  }
  
  const setMetric = (id, value, threshold1, threshold2, titleFn) => {
    const el = document.getElementById(id);
    if (!el) return;
    if (value !== null && value !== undefined && !isNaN(value)) {
      const display = typeof value === 'number' ? (Math.abs(value) < 10 ? value.toFixed(2) : value.toFixed(0)) : value;
      el.textContent = display;
      el.className = 'theory-value ' + (value > threshold1 ? 'high' : value > threshold2 ? 'mid' : 'low');
      if (titleFn) el.title = titleFn();
    } else {
      el.textContent = 'â€”';
      el.className = 'theory-value';
    }
  };
  
  // H - Entropy
  setMetric('theory-entropy', 
    theory?.information?.entropy?.total, 0.7, 0.4,
    () => `Lum: ${theory.information.entropy.luminance.toFixed(2)}, Color: ${theory.information.entropy.color.toFixed(2)}`);
  
  // Ï„ - Topology
  setMetric('theory-topology',
    theory?.topology?.continuity, 0.8, 0.5,
    () => `Components: ${theory.topology.components}, Euler: ${theory.topology.euler}`);
  
  // Î» - Lyapunov
  setMetric('theory-lyapunov',
    theory?.dynamics?.stability, 0.7, 0.4,
    () => `Lyapunov: ${theory.dynamics.lyapunov?.toFixed(3) || 0}, Attractors: ${theory.dynamics.attractors}`);
  
  // Î£ - Symmetry
  setMetric('theory-symmetry',
    theory?.symmetry?.radialSymmetry, 0.7, 0.4,
    () => `H-Ref: ${theory.symmetry.reflectionH?.toFixed(2) || 0}, V-Ref: ${theory.symmetry.reflectionV?.toFixed(2) || 0}`);
  
  // Îº - Curvature
  setMetric('theory-curvature',
    theory?.geometry?.meanCurvature, 0.1, 0.03,
    () => `Gaussian: ${theory.geometry.gaussianCurvature?.toFixed(4) || 0}, Type: ${theory.geometry.curvatureType}`);
  
  // âˆ‡ - Gradient
  setMetric('theory-gradient',
    theory?.geometry?.gradientCoherence, 0.6, 0.3,
    () => `Magnitude: ${theory.geometry.gradientMagnitude?.toFixed(3) || 0}, Dir: ${theory.geometry.dominantDirection?.toFixed(0) || 0}Â°`);
  
  // âŠ— - Causal
  setMetric('theory-causal',
    theory?.causal?.causalStrength, 0.6, 0.3,
    () => `Interventions: ${theory.causal.interventions?.length || 0}`);
  
  // Î˜ - Score
  setMetric('theory-score',
    theory?.theoreticalScore, 70, 40,
    () => `8-theory weighted composite score`);
}

function updateCausalCanvas() {
  const canvas = document.getElementById('causal-canvas');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#08080c';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) return;
  const recent = container.frames.slice(-15);
  const barW = canvas.width / 15;
  recent.forEach((f, i) => {
    const h = Math.min(canvas.height, (f.causalInferences.length + 1) * 8);
    ctx.fillStyle = f.causalInferences.length > 0 ? '#8855ff' : '#4a90ff';
    ctx.fillRect(i * barW + 1, canvas.height - h, barW - 2, h);
    if (f.patterns.length > 0) { ctx.fillStyle = '#ff8844'; ctx.fillRect(i * barW + 1, 0, barW - 2, 3); }
  });
}

function renderVFGrid(grid, elementId) {
  const el = document.getElementById(elementId);
  if (!el || !grid) return;
  if (el.children.length !== 64) { el.innerHTML = ''; for (let i = 0; i < 64; i++) { const d = document.createElement('div'); d.className = 'vf-cell'; el.appendChild(d); } }
  let i = 0;
  grid.forEach(row => { row.forEach(cell => { el.children[i].style.backgroundColor = `rgb(${cell.r},${cell.g},${cell.b})`; i++; }); });
}

async function startSystem() {
  const btn = document.getElementById('start-btn');
  btn.disabled = true;
  btn.textContent = 'Initializing...';
  Log.info('system', 'Initializing VIRECAI v2.27...');
  
  try {
    // Initialize unified sensor state system
    SensorState.init();
    
    // Initialize all sensor dots as pending
    ['video', 'audio', 'gps', 'motion', 'env'].forEach(s => {
      const dot = document.getElementById(`dot-${s}`);
      if (dot) {
        dot.classList.remove('active', 'denied', 'off', 'stale', 'degraded');
        dot.classList.add('pending');
      }
    });
    
    btn.textContent = 'Starting camera...';
    await orch.initialize();
    
    const cameraOk = await initCamera();
    if (!cameraOk) { 
      Log.error('system', 'Camera required'); 
      btn.disabled = false; 
      btn.textContent = 'Camera Failed - Retry';
      return; 
    }
    
    btn.textContent = 'Starting audio...';
    await initAudio();
    
    btn.textContent = 'Getting location...';
    initGPS();
    
    btn.textContent = 'Starting sensors...';
    initMotion();
    initDevice();
    
    orch.transition('ready');
    console.log('[startSystem] Orchestrator state after transition:', orch.getState());
    document.getElementById('start-overlay').classList.add('hidden');
    
    // Show quick actions bar and status dashboard now that camera is ready
    document.getElementById('quick-actions-bar').classList.add('visible');
    document.getElementById('status-dashboard').classList.add('visible');
    
    // Initial health badge update
    SensorState.updateHealthBadge();
    
    // v2.26: Initialize sensor dashboard
    initSensorDashboard();
    
    // v2.26: Now initialize UX components AFTER system is ready
    statusBar.initialize();
    floatingActions.initialize();
    breadcrumbs.updateFromContext();
    notificationCenter.render();
    
    Log.ok('system', 'System ready');
    mainLoop();
  } catch (err) {
    Log.error('system', 'Initialization failed: ' + (err.message || err));
    btn.disabled = false;
    btn.textContent = 'Error - Retry';
  }
}

// toggleRecording() is now defined above using RecordingController

function setMode(mode) {
  orch.mode = mode;
  document.getElementById('mode-full').classList.toggle('active', mode === 'full');
  document.getElementById('mode-lite').classList.toggle('active', mode === 'lite');
  const chip = document.getElementById('mode-chip');
  chip.textContent = mode === 'full' ? 'Full' : 'Lite';
  chip.className = 'chip ' + (mode === 'full' ? 'mode-full' : 'mode-lite');
}

function flipCamera() {
  app.facingMode = app.facingMode === 'user' ? 'environment' : 'user';
  if (app.stream) app.stream.getTracks().forEach(t => t.stop());
  app.video.classList.toggle('mirror', app.facingMode === 'user');
  initCamera();
}

function toggleWH() {
  app.showWH = !app.showWH;
  document.getElementById('wh-overlay').classList.toggle('visible', app.showWH);
  document.getElementById('btn-wh').classList.toggle('active', app.showWH);
}

function openPanel() { document.getElementById('panel').classList.add('open'); document.getElementById('panel-backdrop').classList.add('open'); updatePanel(); }
function closePanel() { document.getElementById('panel').classList.remove('open'); document.getElementById('panel-backdrop').classList.remove('open'); }

function switchTab(tabName) {
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
  document.querySelector(`[data-tab="${tabName}"]`)?.classList.add('active');
  document.getElementById(`tab-${tabName}`)?.classList.add('active');
  if (tabName === 'sensors') updateSensorDetails();
  if (tabName === 'causal') updateCausalTab();
  if (tabName === 'history') updateHistoryList();
}

function updatePanel() {
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) return;
  
  // Basic capture info
  document.getElementById('p-mode').textContent = container.mode.toUpperCase();
  document.getElementById('p-frames').textContent = container.frames.length;
  document.getElementById('p-symbols').textContent = container.symbols.size;
  document.getElementById('p-relations').textContent = container.totalRelations;
  document.getElementById('p-size').textContent = U.formatSize(container.totalSize);
  
  // Theoretical analysis
  const framesWithTheory = container.frames.filter(f => f.theoretical);
  const theorySummary = container.getTheoreticalSummary();
  const lastTheory = framesWithTheory.length > 0 ? framesWithTheory[framesWithTheory.length - 1].theoretical : null;
  
  document.getElementById('p-theory-score').textContent = theorySummary?.avgScore?.toFixed(0) || 'â€”';
  document.getElementById('p-theory-frames').textContent = `${framesWithTheory.length}/${container.frames.length}`;
  document.getElementById('p-theory-entropy').textContent = theorySummary?.avgEntropy?.toFixed(3) || 'â€”';
  document.getElementById('p-theory-phase').textContent = lastTheory?.thermodynamics?.phase || 'â€”';
  
  // v2.26 Architecture stats
  const scenes = container.getSceneSummary();
  const compression = container.getCompressionStats();
  
  document.getElementById('p-scenes').textContent = scenes.length;
  document.getElementById('p-moments').textContent = container.moments.length;
  document.getElementById('p-compress').textContent = compression.ratio.toFixed(1) + 'x';
  document.getElementById('p-events').textContent = eventStore.events.length;
  
  // Performance (v2.26 enhanced)
  const perfStats = perfMonLegacy.getStats();
  document.getElementById('p-fps').textContent = perfStats.fps > 0 ? `${perfStats.fps} fps` : `${orch.config.targetFPS} target`;
  document.getElementById('p-syncqual').textContent = (container.metrics.avgSyncQuality * 100).toFixed(0) + '%';
  document.getElementById('p-uncertainty').textContent = (container.metrics.avgUncertainty * 100).toFixed(1) + '%';
  document.getElementById('p-memory').textContent = perfStats.memory > 0 ? `${perfStats.memory} MB` : 'â€”';
}

function updateSensorDetails() {
  const sensors = ['video', 'audio', 'visual', 'gps', 'motion', 'env'];
  const summary = SensorState.getSummary();
  
  let html = `<div style="background:var(--bg-primary);border-radius:6px;padding:8px;margin-bottom:8px;border:1px solid var(--border)">
    <div style="display:flex;justify-content:space-between;margin-bottom:4px">
      <span style="font-size:9px;font-weight:600">SYSTEM HEALTH</span>
      <span style="font-size:9px;font-weight:600;color:${summary.healthPercent >= 80 ? 'var(--success)' : summary.healthPercent >= 50 ? 'var(--warning)' : 'var(--error)'}">${summary.healthPercent}%</span>
    </div>
    <div style="font-size:8px;color:var(--text-secondary)">${summary.active}/${summary.total - summary.off} active â€¢ ${summary.degraded} degraded â€¢ ${summary.failed} failed</div>
  </div>`;
  
  html += sensors.map(name => {
    const state = SensorState.get(name);
    const status = state.status;
    const statusColor = status === 'active' ? 'var(--success)' : 
                        status === 'denied' || status === 'failed' ? 'var(--error)' : 
                        status === 'stale' || status === 'degraded' ? 'var(--warning)' : 'var(--text-muted)';
    const coordHealth = orch.coordinator.getFullHealth(name);
    
    return `<div style="background:var(--bg-primary);border-radius:6px;padding:8px;margin-bottom:6px;border:1px solid var(--border)">
      <div style="display:flex;justify-content:space-between;margin-bottom:4px">
        <span style="font-size:10px;font-weight:600">${name.toUpperCase()}</span>
        <span style="font-size:8px;color:${statusColor};font-weight:600">${status}</span>
      </div>
      <div style="font-size:8px;color:var(--text-secondary)">
        Quality: ${(coordHealth.quality*100).toFixed(0)}% | Ïƒ: ${(coordHealth.uncertainty*100).toFixed(1)}%
      </div>
      ${state.note ? `<div style="font-size:7px;color:var(--text-muted);margin-top:2px">${state.note}</div>` : ''}
      ${state.retryCount > 0 ? `<div style="font-size:7px;color:var(--warning);margin-top:2px">Retries: ${state.retryCount}/${state.maxRetries}</div>` : ''}
    </div>`;
  }).join('');
  
  document.getElementById('sensor-details').innerHTML = html;
}

function updateCausalTab() {
  const container = orch.getContainer();
  if (!container) return;
  const causal = container.getCausalSummary();
  
  // Update counts with visual feedback
  const infEl = document.getElementById('p-inferences');
  const patEl = document.getElementById('p-patterns');
  
  infEl.textContent = causal.totalInferences;
  patEl.textContent = causal.totalPatterns;
  
  // Color code based on activity
  infEl.style.color = causal.totalInferences > 10 ? 'var(--success)' : 
                       causal.totalInferences > 0 ? 'var(--warning)' : 'var(--text-muted)';
  patEl.style.color = causal.totalPatterns > 3 ? 'var(--success)' : 
                       causal.totalPatterns > 0 ? 'var(--warning)' : 'var(--text-muted)';
  
  // Build inference list with enhanced styling
  const listEl = document.getElementById('causal-list');
  if (causal.recentInferences.length === 0) {
    listEl.innerHTML = `
      <div style="text-align:center;padding:16px;color:var(--text-muted)">
        <div style="font-size:20px;margin-bottom:8px">ðŸ”</div>
        <div style="font-size:9px">No causal inferences detected yet.</div>
        <div style="font-size:8px;margin-top:4px">Move the camera or change lighting to trigger detection.</div>
      </div>`;
  } else {
    const items = causal.recentInferences.slice(-8).reverse();
    listEl.innerHTML = items.map((inf, idx) => `
      <div style="padding:6px 8px;margin:4px 0;background:var(--bg-primary);border-radius:4px;border-left:2px solid var(--accent-purple);animation:fadeIn 0.2s ease ${idx * 0.05}s both">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <span style="font-size:9px;font-weight:600;color:var(--accent-purple)">${inf.type.replace(/_/g, ' ')}</span>
          <span style="font-size:7px;color:var(--text-muted)">F${inf.frameIndex}</span>
        </div>
        <div style="font-size:8px;color:var(--text-secondary);margin-top:2px">
          ${inf.cause} â†’ ${inf.effect}
        </div>
        <div style="font-size:7px;color:var(--text-muted);margin-top:1px">
          Conf: ${((inf.confidence || 0.5) * 100).toFixed(0)}%
        </div>
      </div>
    `).join('');
  }
  
  // Add patterns section if any
  if (causal.recentPatterns && causal.recentPatterns.length > 0) {
    listEl.innerHTML += `
      <div style="margin-top:12px;padding-top:8px;border-top:1px solid var(--border)">
        <div style="font-size:8px;color:var(--text-muted);margin-bottom:6px;text-transform:uppercase">Detected Patterns</div>
        ${causal.recentPatterns.slice(-3).map(p => `
          <div style="font-size:8px;padding:4px;background:var(--bg-tertiary);border-radius:3px;margin:2px 0;color:var(--accent-cyan)">
            ${p.type.replace(/_/g, ' ')}
          </div>
        `).join('')}
      </div>
    `;
  }
}

function runQuery() {
  const input = document.getElementById('query-input');
  const result = document.getElementById('query-result');
  if (!queryEngine && orch.getContainer()) queryEngine = new QueryEngine(orch);
  result.textContent = queryEngine ? queryEngine.ask(input.value) : 'No data captured yet.';
}

function downloadVRC() {
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) { alert('No data to export'); return; }
  const vrc = container.toVRC();
  const blob = new Blob([vrc], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `reality_${container.mode}_${container.frames.length}f_${Date.now()}.vrc`;
  a.click();
  URL.revokeObjectURL(url);
  Log.ok('export', 'Reality exported as VRC');
}

function downloadJSON() {
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) { alert('No data to export'); return; }
  
  LegacyExporter.exportToJSON(container, `reality_${container.mode}_${container.frames.length}f_${Date.now()}.json`)
    .then(result => Log.ok('export', `Exported JSON (${U.formatSize(result.size)})`))
    .catch(err => Log.error('export', err.message));
}

async function saveToHistory() {
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) { alert('No data to save'); return; }
  
  try {
    const id = await persistence.saveRecording({
      id: recordingSession.id,
      name: recordingSession.name || `Recording ${new Date().toLocaleString()}`,
      created: recordingSession.startTime || U.timestamp(),
      mode: container.mode,
      frameCount: container.frames.length,
      symbolCount: container.symbols.size,
      duration: container.frames[container.frames.length - 1]?.timestamp || 0,
      size: container.totalSize,
      theoreticalScore: container.getTheoreticalSummary()?.avgScore,
      vrcData: container.toVRC()
    });
    
    Log.ok('save', `Saved to history: ${id.slice(0,8)}...`);
    updateHistoryList();
  } catch (err) {
    Log.error('save', err.message);
  }
}

async function updateHistoryList() {
  try {
    const recordings = await persistence.getAllRecordings();
    const stats = await persistence.getStorageStats();
    
    document.getElementById('p-recording-count').textContent = recordings.length;
    document.getElementById('p-storage-size').textContent = stats.totalSizeFormatted;
    
    const list = document.getElementById('history-list');
    
    if (recordings.length === 0) {
      list.innerHTML = '<div style="text-align:center;color:var(--text-muted);font-size:10px;padding:20px">No saved recordings</div>';
      return;
    }
    
    list.innerHTML = recordings.slice(0, 10).map(r => `
      <div class="history-item" data-id="${r.id}">
        <div class="history-item-header">
          <span class="history-item-name">${r.name || 'Untitled'}</span>
          <span class="history-item-date">${new Date(r.created).toLocaleDateString()}</span>
        </div>
        <div class="history-item-stats">
          <span>ðŸ“¹ ${r.frameCount || 0} frames</span>
          <span>ðŸŽ¯ Î˜${r.theoreticalScore?.toFixed(0) || 'â€”'}</span>
          <span>ðŸ’¾ ${U.formatSize(r.size || 0)}</span>
        </div>
        <div class="history-item-actions">
          <button class="history-item-btn load" onclick="loadRecording('${r.id}')">Load</button>
          <button class="history-item-btn export" onclick="exportRecording('${r.id}')">Export</button>
          <button class="history-item-btn delete" onclick="deleteRecording('${r.id}')">Delete</button>
        </div>
      </div>
    `).join('');
  } catch (err) {
    console.error('Failed to update history:', err);
  }
}

async function loadRecording(id) {
  try {
    Log.info('load', 'Opening recording...');
    await openPlaybackFromHistory(id);
  } catch (err) {
    Log.error('load', err.message);
  }
}

async function exportRecording(id) {
  try {
    const recording = await persistence.getRecording(id);
    if (!recording || !recording.vrcData) {
      Log.error('export', 'Recording not found');
      return;
    }
    
    const blob = new Blob([recording.vrcData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${recording.name.replace(/[^a-z0-9]/gi, '_')}.vrc`;
    a.click();
    URL.revokeObjectURL(url);
    Log.ok('export', 'Exported from history');
  } catch (err) {
    Log.error('export', err.message);
  }
}

async function deleteRecording(id) {
  if (!confirm('Delete this recording? This cannot be undone.')) return;
  
  try {
    await persistence.deleteRecording(id);
    Log.ok('delete', 'Recording deleted');
    updateHistoryList();
  } catch (err) {
    Log.error('delete', err.message);
  }
}

async function clearAllHistory() {
  if (!confirm('Delete ALL saved recordings? This cannot be undone.')) return;
  
  try {
    await persistence.clearAll();
    Log.ok('clear', 'All history cleared');
    updateHistoryList();
  } catch (err) {
    Log.error('clear', err.message);
  }
}

function handleImport(file) {
  if (!file) return;
  
  LegacyExporter.importFromFile(file)
    .then(result => {
      Log.ok('import', `Imported ${result.type} file`);
      if (result.type === 'vrc') {
        alert(`Imported VRC:\nMode: ${result.mode}\nFrames: ${result.data.frameCount}\n\nPlayback coming in v3.0`);
      } else {
        alert(`Imported JSON:\nFrames: ${result.data.frameCount}`);
      }
    })
    .catch(err => {
      Log.error('import', err.message);
      alert('Failed to import file: ' + err.message);
    });
}

function updateTimeline() {
  const container = orch.getContainer();
  if (!container || container.frames.length === 0) return;
  
  const bar = document.getElementById('timeline-bar');
  bar.classList.add('visible');
  
  // Update timeline manager
  timelineManager.update(container);
  
  // Update progress
  const lastFrame = container.frames[container.frames.length - 1];
  const duration = lastFrame?.timestamp || 0;
  
  document.getElementById('timeline-time').textContent = U.formatTime(duration);
  document.getElementById('timeline-frames').textContent = `${container.frames.length} frames`;
  
  // Update markers
  const markersEl = document.getElementById('timeline-markers');
  const trackWidth = document.getElementById('timeline-track').offsetWidth;
  
  if (trackWidth > 0 && timelineManager.totalDuration > 0) {
    markersEl.innerHTML = timelineManager.markers.slice(0, 20).map(m => {
      const pos = (m.time / timelineManager.totalDuration) * 100;
      const cls = m.type === 'SCENE_CHANGE' ? 'scene' : m.type === 'PHASE_TRANSITION' ? 'phase' : '';
      return `<div class="timeline-marker ${cls}" style="left:${pos}%"></div>`;
    }).join('');
  }
}

function hideTimeline() {
  document.getElementById('timeline-bar').classList.remove('visible');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYBACK FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openPlaybackPanel() {
  document.getElementById('playback-backdrop').classList.add('open');
  document.getElementById('playback-panel').classList.add('open');
  
  // Initialize frame viewer
  frameViewer.init();
  
  // If we have a current recording, load it
  const container = orch?.getContainer();
  if (container && container.frames.length > 0) {
    const result = playbackEngine.loadFromContainer(container);
    if (result.success) {
      updatePlaybackUI();
      renderCurrentFrame();
    }
  }
}

function closePlaybackPanel() {
  document.getElementById('playback-backdrop').classList.remove('open');
  document.getElementById('playback-panel').classList.remove('open');
  playbackEngine.stop();
}

async function openPlaybackFromHistory(recordingId) {
  const result = await playbackEngine.load(recordingId);
  if (result.success) {
    openPlaybackPanel();
    updatePlaybackUI();
    renderCurrentFrame();
  }
}

function playbackPlay() {
  if (playbackEngine.isPaused) {
    playbackEngine.resume();
  } else if (playbackEngine.isPlaying) {
    playbackEngine.pause();
  } else {
    playbackEngine.play();
  }
  updatePlaybackControls();
}

function playbackStop() {
  playbackEngine.stop();
  updatePlaybackUI();
  renderCurrentFrame();
}

function playbackNext() {
  playbackEngine.nextFrame();
  updatePlaybackUI();
  renderCurrentFrame();
}

function playbackPrev() {
  playbackEngine.prevFrame();
  updatePlaybackUI();
  renderCurrentFrame();
}

function playbackSeek(value) {
  playbackEngine.seekPercent(parseFloat(value));
  updatePlaybackUI();
  renderCurrentFrame();
}

function playbackSpeed(speed) {
  playbackEngine.setSpeed(parseFloat(speed));
}

function updatePlaybackUI() {
  const state = playbackEngine.getState();
  
  document.getElementById('pb-current-frame').textContent = `F${state.currentFrame}`;
  document.getElementById('pb-time').textContent = state.time;
  document.getElementById('pb-total-frames').textContent = `/ ${state.totalFrames}`;
  document.getElementById('pb-scrub').value = state.progress;
  document.getElementById('pb-scrub').max = 100;
  document.getElementById('playback-overlay').textContent = `F${state.currentFrame} | ${state.time}`;
  
  updatePlaybackControls();
}

function updatePlaybackControls() {
  const state = playbackEngine.getState();
  const playBtn = document.getElementById('pb-play');
  
  if (state.isPlaying && !state.isPaused) {
    playBtn.textContent = 'â¸';
    playBtn.classList.add('active');
  } else {
    playBtn.textContent = 'â–¶';
    playBtn.classList.remove('active');
  }
}

function renderCurrentFrame() {
  const frame = playbackEngine.getCurrentFrame();
  if (!frame) return;
  
  frameViewer.render(frame);
  
  // Update info panel
  const info = frameViewer.renderFrameInfo(frame);
  document.getElementById('pb-info').textContent = info;
}

// Set up playback engine callbacks
playbackEngine.onFrameChange = (index, frame) => {
  updatePlaybackUI();
  renderCurrentFrame();
};

playbackEngine.onPlaybackEnd = () => {
  updatePlaybackControls();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPARE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openComparePanel() {
  document.getElementById('compare-backdrop').classList.add('open');
  document.getElementById('compare-panel').classList.add('open');
  
  // Set max values based on current frames
  const container = orch?.getContainer();
  if (container && container.frames.length > 0) {
    const max = container.frames.length - 1;
    document.getElementById('compare-input-a').max = max;
    document.getElementById('compare-input-b').max = max;
    document.getElementById('compare-input-b').value = Math.min(1, max);
  }
}

function closeComparePanel() {
  document.getElementById('compare-backdrop').classList.remove('open');
  document.getElementById('compare-panel').classList.remove('open');
}

function runComparison() {
  const container = orch?.getContainer();
  if (!container || container.frames.length < 2) {
    document.getElementById('compare-result').textContent = 'Need at least 2 frames to compare.';
    return;
  }
  
  const indexA = parseInt(document.getElementById('compare-input-a').value) || 0;
  const indexB = parseInt(document.getElementById('compare-input-b').value) || 1;
  
  if (indexA >= container.frames.length || indexB >= container.frames.length) {
    document.getElementById('compare-result').textContent = 'Invalid frame index.';
    return;
  }
  
  // Get frame data
  const frameA = container.frames[indexA];
  const frameB = container.frames[indexB];
  
  // Set up comparison
  comparisonView.setFrames(
    {
      index: frameA.index,
      timestamp: frameA.timestamp,
      visual: frameA.getLayer('visual'),
      theoretical: frameA.theoretical,
      causalInferences: frameA.causalInferences
    },
    {
      index: frameB.index,
      timestamp: frameB.timestamp,
      visual: frameB.getLayer('visual'),
      theoretical: frameB.theoretical,
      causalInferences: frameB.causalInferences
    }
  );
  
  // Render frames
  renderCompareFrame('compare-canvas-a', frameA.getLayer('visual')?.grid);
  renderCompareFrame('compare-canvas-b', frameB.getLayer('visual')?.grid);
  
  // Show comparison
  document.getElementById('compare-result').textContent = comparisonView.getSummary();
}

function renderCompareFrame(canvasId, grid) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || !grid) return;
  
  const ctx = canvas.getContext('2d');
  const cellW = canvas.width / grid[0].length;
  const cellH = canvas.height / grid.length;
  
  for (let y = 0; y < grid.length; y++) {
    for (let x = 0; x < grid[0].length; x++) {
      const cell = grid[y][x];
      ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
      ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANALYTICS FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openAnalyticsPanel() {
  document.getElementById('analytics-backdrop').classList.add('open');
  document.getElementById('analytics-panel').classList.add('open');
  
  // Initialize and update visualizations
  const container = orch?.getContainer();
  if (container && container.frames.length > 0) {
    updateAnalytics(container);
  }
}

function closeAnalyticsPanel() {
  document.getElementById('analytics-backdrop').classList.remove('open');
  document.getElementById('analytics-panel').classList.remove('open');
}

function updateAnalytics(container) {
  if (!container || container.frames.length === 0) return;
  
  // Initialize if needed
  if (!metricsGraph.canvas) metricsGraph.init();
  if (!filmstripView.container) filmstripView.init();
  if (!sceneTimeline.container) sceneTimeline.init();
  
  // Update all visualizations
  metricsGraph.updateFromContainer(container);
  filmstripView.updateFromContainer(container);
  sceneTimeline.updateFromContainer(container);
  
  // Update annotation count
  document.getElementById('annotation-count').textContent = annotationManager.getCount();
  updateAnnotationList();
}

function toggleMetricLegend(metric) {
  metricsGraph.toggleMetric(metric);
  
  // Update legend UI
  document.querySelectorAll('.metrics-legend-item').forEach(item => {
    if (item.dataset.metric === metric) {
      item.classList.toggle('active');
    }
  });
}

function addAnnotation() {
  const frameInput = document.getElementById('annotation-frame');
  const textInput = document.getElementById('annotation-text');
  
  const frameIndex = parseInt(frameInput.value);
  const text = textInput.value.trim();
  
  if (isNaN(frameIndex) || frameIndex < 0) {
    Log.warn('annotation', 'Invalid frame number');
    return;
  }
  
  if (!text) {
    Log.warn('annotation', 'Enter annotation text');
    return;
  }
  
  const container = orch?.getContainer();
  if (container && frameIndex >= container.frames.length) {
    Log.warn('annotation', 'Frame index out of range');
    return;
  }
  
  annotationManager.add(frameIndex, text);
  
  // Clear inputs
  frameInput.value = '';
  textInput.value = '';
  
  // Update UI
  document.getElementById('annotation-count').textContent = annotationManager.getCount();
  updateAnnotationList();
  
  Log.ok('annotation', `Added note at F${frameIndex}`);
}

function removeAnnotation(frameIndex) {
  annotationManager.remove(frameIndex);
  document.getElementById('annotation-count').textContent = annotationManager.getCount();
  updateAnnotationList();
}

function updateAnnotationList() {
  const list = document.getElementById('annotation-list');
  const annotations = annotationManager.getAll();
  
  if (annotations.length === 0) {
    list.innerHTML = '<div style="text-align:center;color:var(--text-muted);font-size:9px;padding:10px">No annotations yet</div>';
    return;
  }
  
  list.innerHTML = annotations.map(a => `
    <div class="annotation-item">
      <span class="annotation-item-frame">F${a.frameIndex}</span>
      <span class="annotation-item-text">${a.text}</span>
      <span class="annotation-item-delete" onclick="removeAnnotation(${a.frameIndex})">âœ•</span>
    </div>
  `).join('');
}

function handleMetricsGraphClick(e) {
  const canvas = document.getElementById('metrics-canvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  
  const frameIndex = metricsGraph.frameAtPosition(x * (canvas.width / rect.width));
  if (frameIndex >= 0) {
    // Jump to frame in playback
    playbackEngine.seek(frameIndex);
    updatePlaybackUI();
    renderCurrentFrame();
    
    // Highlight in visualizations
    metricsGraph.setHoveredFrame(frameIndex);
    filmstripView.selectFrame(frameIndex);
    filmstripView.scrollToFrame(frameIndex);
  }
}

function handleMetricsGraphHover(e) {
  const canvas = document.getElementById('metrics-canvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  
  const frameIndex = metricsGraph.frameAtPosition(x * (canvas.width / rect.width));
  metricsGraph.setHoveredFrame(frameIndex);
}

// Connect filmstrip to playback
filmstripView.onFrameSelect = (frameIndex) => {
  if (playbackEngine.frames.length === 0) {
    const container = orch?.getContainer();
    if (container) playbackEngine.loadFromContainer(container);
  }
  
  playbackEngine.seek(frameIndex);
  updatePlaybackUI();
  renderCurrentFrame();
  metricsGraph.setHoveredFrame(frameIndex);
};

// Connect scene timeline to playback
sceneTimeline.onSceneClick = (sceneIndex, startFrame, endFrame) => {
  if (playbackEngine.frames.length === 0) {
    const container = orch?.getContainer();
    if (container) playbackEngine.loadFromContainer(container);
  }
  
  playbackEngine.seek(startFrame);
  updatePlaybackUI();
  renderCurrentFrame();
  openPlaybackPanel();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.8 FUNCTIONS â€” Clip Export, Heatmap, Tags, Search
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openClipPanel() {
  document.getElementById('clip-backdrop').classList.add('open');
  document.getElementById('clip-panel').classList.add('open');
  
  const container = orch?.getContainer();
  if (container && container.frames.length > 0) {
    document.getElementById('clip-start').value = 0;
    document.getElementById('clip-start').max = container.frames.length - 1;
    document.getElementById('clip-end').value = container.frames.length - 1;
    document.getElementById('clip-end').max = container.frames.length - 1;
    updateClipPreview();
  }
}

function closeClipPanel() {
  document.getElementById('clip-backdrop').classList.remove('open');
  document.getElementById('clip-panel').classList.remove('open');
}

function updateClipPreview() {
  const container = orch?.getContainer();
  if (!container) return;
  
  const start = parseInt(document.getElementById('clip-start').value) || 0;
  const end = parseInt(document.getElementById('clip-end').value) || 0;
  
  clipExporter.setContainer(container);
  clipExporter.setRange(start, end);
  
  const preview = clipExporter.getPreview();
  if (preview) {
    document.getElementById('clip-frame-count').textContent = preview.count;
    document.getElementById('clip-duration').textContent = U.formatTime(preview.duration);
    document.getElementById('clip-entropy').textContent = preview.avgEntropy.toFixed(3);
    document.getElementById('clip-motion').textContent = preview.avgMotion.toFixed(3);
  }
}

async function exportClipJSON() {
  const container = orch?.getContainer();
  if (!container) return;
  
  const start = parseInt(document.getElementById('clip-start').value) || 0;
  const end = parseInt(document.getElementById('clip-end').value) || 0;
  
  clipExporter.setContainer(container);
  clipExporter.setRange(start, end);
  
  const filename = `clip_F${start}-F${end}_${Date.now()}.json`;
  const result = await clipExporter.exportAsJSON(filename);
  
  if (result.success) {
    Log.ok('export', `Clip exported: ${result.frameCount} frames`);
    closeClipPanel();
  } else {
    Log.error('export', result.error);
  }
}

async function exportClipImage() {
  const container = orch?.getContainer();
  if (!container) return;
  
  const start = parseInt(document.getElementById('clip-start').value) || 0;
  const end = parseInt(document.getElementById('clip-end').value) || 0;
  
  clipExporter.setContainer(container);
  clipExporter.setRange(start, end);
  
  const filename = `clip_F${start}-F${end}_${Date.now()}.png`;
  const result = await clipExporter.exportAsGIF(filename);
  
  if (result.success) {
    Log.ok('export', `Clip image exported: ${result.frameCount} frames`);
    closeClipPanel();
  } else {
    Log.error('export', result.error);
  }
}

function setHeatmapMode(mode) {
  heatmapOverlay.setMode(mode);
  
  // Update button states
  document.querySelectorAll('.heatmap-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  
  // Re-render current frame with overlay
  renderCurrentFrame();
}

function renderQuickTags(frameIndex) {
  const container = document.getElementById('quick-tags');
  if (!container) return;
  
  container.innerHTML = quickTags.predefinedTags.map(tag => {
    const isActive = quickTags.hasTag(frameIndex, tag.name);
    return `
      <div class="quick-tag ${isActive ? 'active' : ''}" 
           style="background:${tag.color}20;color:${tag.color}"
           onclick="toggleQuickTag(${frameIndex}, '${tag.name}')">
        <span class="quick-tag-icon">${tag.icon}</span>
        <span>${tag.name}</span>
      </div>
    `;
  }).join('');
}

function toggleQuickTag(frameIndex, tagName) {
  const added = quickTags.toggleTag(frameIndex, tagName);
  renderQuickTags(frameIndex);
  Log.info('tag', `${added ? 'Added' : 'Removed'} "${tagName}" on F${frameIndex}`);
}

function showSearchResults(query) {
  const container = orch?.getContainer();
  if (!container) return;
  
  // Parse query and find matching frames
  let results = [];
  
  if (query.startsWith('tag:')) {
    const tagName = query.slice(4).trim();
    results = quickTags.getFramesWithTag(tagName);
  } else if (query.startsWith('scene:')) {
    const sceneType = query.slice(6).trim();
    results = symbolicIndex.query({ sceneType });
  } else if (query.startsWith('entropy>')) {
    const threshold = parseFloat(query.slice(8)) || 0.5;
    results = symbolicIndex.query({ entropy: 'high' });
  } else if (query.startsWith('motion>')) {
    const threshold = parseFloat(query.slice(7)) || 0.2;
    results = symbolicIndex.query({ motion: 'high' });
  } else {
    // Text search
    results = symbolicIndex.query({ text: query });
  }
  
  searchResults.init();
  searchResults.setResults(results, container, query);
  searchResults.onResultClick = (frameIndex) => {
    playbackEngine.seek(frameIndex);
    updatePlaybackUI();
    renderCurrentFrame();
    openPlaybackPanel();
  };
}

// Enhanced renderCurrentFrame with heatmap overlay
const originalRenderCurrentFrame = renderCurrentFrame;
function renderCurrentFrameWithHeatmap() {
  const frame = playbackEngine.getCurrentFrame();
  if (!frame) return;
  
  frameViewer.render(frame);
  
  // Apply heatmap overlay if active
  if (heatmapOverlay.mode !== 'none') {
    const overlay = heatmapOverlay.generateOverlay(frame);
    if (overlay) {
      const canvas = document.getElementById('playback-canvas');
      heatmapOverlay.renderToCanvas(canvas, overlay);
    }
  }
  
  // Update info panel
  const info = frameViewer.renderFrameInfo(frame);
  document.getElementById('pb-info').textContent = info;
  
  // Update quick tags
  renderQuickTags(playbackEngine.currentFrame);
}

// Override renderCurrentFrame
renderCurrentFrame = renderCurrentFrameWithHeatmap;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V2.9 FUNCTIONS â€” Report, Bookmarks, Command Palette
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openReportPanel() {
  document.getElementById('report-backdrop').classList.add('open');
  document.getElementById('report-panel').classList.add('open');
}

function closeReportPanel() {
  document.getElementById('report-backdrop').classList.remove('open');
  document.getElementById('report-panel').classList.remove('open');
}

function toggleReportSection(section) {
  reportGenerator.toggleSection(section);
  
  // Update button states
  document.querySelectorAll('.report-section-btn').forEach(btn => {
    if (btn.dataset.section === section) {
      btn.classList.toggle('active');
    }
  });
}

async function exportReport(format) {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) {
    Log.warn('report', 'No data to report');
    return;
  }
  
  const result = await reportGenerator.download(container, format);
  
  if (result.success) {
    Log.ok('report', `Report exported: ${result.filename}`);
    closeReportPanel();
  } else {
    Log.error('report', result.error);
  }
}

function addBookmarkAtCurrent() {
  const frameIndex = playbackEngine.currentFrame;
  const result = bookmarkManager.add(frameIndex);
  
  if (result.success) {
    Log.ok('bookmark', `Bookmarked F${frameIndex}`);
    updateBookmarksList();
    updateTimelineMarkers();
  } else {
    Log.warn('bookmark', result.error);
  }
}

function removeBookmark(id) {
  bookmarkManager.remove(id);
  updateBookmarksList();
  updateTimelineMarkers();
}

function goToNextBookmark() {
  const next = bookmarkManager.getNext(playbackEngine.currentFrame);
  if (next) {
    playbackEngine.seek(next.frameIndex);
    updatePlaybackUI();
    renderCurrentFrame();
  }
}

function goToPrevBookmark() {
  const prev = bookmarkManager.getPrev(playbackEngine.currentFrame);
  if (prev) {
    playbackEngine.seek(prev.frameIndex);
    updatePlaybackUI();
    renderCurrentFrame();
  }
}

function updateBookmarksList() {
  const list = document.getElementById('bookmarks-list');
  if (!list) return;
  
  const bookmarks = bookmarkManager.getAll();
  
  if (bookmarks.length === 0) {
    list.innerHTML = '<div style="text-align:center;color:var(--text-muted);font-size:9px;padding:10px">No bookmarks yet. Press B to add.</div>';
    return;
  }
  
  list.innerHTML = bookmarks.map(b => `
    <div class="bookmark-item" onclick="goToBookmark(${b.frameIndex})">
      <span class="bookmark-dot" style="background:${b.color}"></span>
      <span class="bookmark-name">${b.name}</span>
      <span class="bookmark-frame">F${b.frameIndex}</span>
      <span class="bookmark-delete" onclick="event.stopPropagation();removeBookmark('${b.id}')">âœ•</span>
    </div>
  `).join('');
}

function goToBookmark(frameIndex) {
  playbackEngine.seek(frameIndex);
  updatePlaybackUI();
  renderCurrentFrame();
}

function updateTimelineMarkers() {
  const container = orch?.getContainer();
  if (!container || container.frames.length === 0) return;
  
  timelineMarkers.render('timeline-markers-v2', container.frames.length);
}

function autoDetectMarkers() {
  const container = orch?.getContainer();
  if (!container) return;
  
  timelineMarkers.autoDetect(container);
  updateTimelineMarkers();
  Log.ok('markers', `Detected ${timelineMarkers.markers.length} markers`);
}

// Command palette keyboard handler
function handleCommandPaletteKey(e) {
  if (!commandPalette.isOpen) return;
  
  switch (e.key) {
    case 'ArrowDown':
      e.preventDefault();
      commandPalette.selectNext();
      break;
    case 'ArrowUp':
      e.preventDefault();
      commandPalette.selectPrev();
      break;
    case 'Enter':
      e.preventDefault();
      commandPalette.execute();
      break;
    case 'Escape':
      e.preventDefault();
      commandPalette.close();
      break;
  }
}

// Initialize bookmarks section in analytics panel
function initBookmarksSection() {
  const analyticsContent = document.querySelector('.analytics-content');
  if (!analyticsContent) return;
  
  // Check if already exists
  if (document.getElementById('bookmarks-section')) return;
  
  const section = document.createElement('div');
  section.id = 'bookmarks-section';
  section.className = 'analytics-section';
  section.innerHTML = `
    <div class="analytics-section-title">Bookmarks (<span id="bookmark-count">0</span>)</div>
    <div class="bookmarks-wrap">
      <div id="bookmarks-list"></div>
    </div>
  `;
  
  analyticsContent.appendChild(section);
  updateBookmarksList();
}

// Add timeline markers container
function initTimelineMarkersContainer() {
  const timeline = document.getElementById('timeline-track');
  if (!timeline || document.getElementById('timeline-markers-v2')) return;
  
  const markersContainer = document.createElement('div');
  markersContainer.id = 'timeline-markers-v2';
  timeline.appendChild(markersContainer);
}

document.addEventListener('DOMContentLoaded', () => {
  Log.info('system', 'VIRECAI v2.27 â€” Complete Symbolic Reality');
  document.getElementById('start-btn').onclick = startSystem;
  document.getElementById('btn-record').onclick = toggleRecording;
  document.getElementById('btn-flip').onclick = flipCamera;
  document.getElementById('btn-wh').onclick = toggleWH;
  document.getElementById('btn-settings').onclick = openSettings;
  document.getElementById('settings-close').onclick = closeSettings;
  document.getElementById('settings-backdrop').onclick = closeSettings;
  document.getElementById('btn-retry-permissions').onclick = retryPermissions;
  document.getElementById('btn-report').onclick = openPanel;
  document.getElementById('panel-close').onclick = closePanel;
  document.getElementById('panel-backdrop').onclick = closePanel;
  document.getElementById('query-btn').onclick = runQuery;
  document.getElementById('btn-download').onclick = downloadVRC;
  document.getElementById('btn-download-json').onclick = downloadJSON;
  document.getElementById('btn-save').onclick = saveToHistory;
  document.getElementById('btn-clear-history').onclick = clearAllHistory;
  document.getElementById('btn-import').onclick = () => document.getElementById('import-input').click();
  document.getElementById('import-input').onchange = e => handleImport(e.target.files[0]);
  document.getElementById('mode-full').onclick = () => setMode('full');
  document.getElementById('mode-lite').onclick = () => setMode('lite');
  document.querySelectorAll('.panel-tab').forEach(tab => { tab.onclick = () => switchTab(tab.dataset.tab); });
  document.getElementById('query-input').onkeypress = e => { if (e.key === 'Enter') runQuery(); };
  
  // Playback panel handlers
  document.getElementById('playback-close').onclick = closePlaybackPanel;
  document.getElementById('playback-backdrop').onclick = closePlaybackPanel;
  document.getElementById('pb-play').onclick = playbackPlay;
  document.getElementById('pb-stop').onclick = playbackStop;
  document.getElementById('pb-next').onclick = playbackNext;
  document.getElementById('pb-prev').onclick = playbackPrev;
  document.getElementById('pb-scrub').oninput = e => playbackSeek(e.target.value);
  document.getElementById('pb-speed').onchange = e => playbackSpeed(e.target.value);
  
  // Compare panel handlers
  document.getElementById('compare-close').onclick = closeComparePanel;
  document.getElementById('compare-backdrop').onclick = closeComparePanel;
  document.getElementById('compare-btn').onclick = runComparison;
  
  // Analytics panel handlers
  document.getElementById('analytics-close').onclick = closeAnalyticsPanel;
  document.getElementById('analytics-backdrop').onclick = closeAnalyticsPanel;
  document.getElementById('annotation-add').onclick = addAnnotation;
  document.getElementById('annotation-text').onkeypress = e => { if (e.key === 'Enter') addAnnotation(); };
  
  // Metrics graph interaction
  document.getElementById('metrics-canvas').onclick = handleMetricsGraphClick;
  document.getElementById('metrics-canvas').onmousemove = handleMetricsGraphHover;
  document.getElementById('metrics-canvas').onmouseleave = () => metricsGraph.setHoveredFrame(-1);
  
  // Metrics legend toggles
  document.querySelectorAll('.metrics-legend-item').forEach(item => {
    item.onclick = () => toggleMetricLegend(item.dataset.metric);
  });
  
  // Heatmap controls
  document.querySelectorAll('.heatmap-btn').forEach(btn => {
    btn.onclick = () => setHeatmapMode(btn.dataset.mode);
  });
  
  // Clip panel handlers
  document.getElementById('clip-close').onclick = closeClipPanel;
  document.getElementById('clip-backdrop').onclick = closeClipPanel;
  document.getElementById('clip-start').oninput = updateClipPreview;
  document.getElementById('clip-end').oninput = updateClipPreview;
  document.getElementById('clip-export-json').onclick = exportClipJSON;
  document.getElementById('clip-export-image').onclick = exportClipImage;
  
  // Report panel handlers
  document.getElementById('report-close').onclick = closeReportPanel;
  document.getElementById('report-backdrop').onclick = closeReportPanel;
  document.getElementById('report-html').onclick = () => exportReport('html');
  document.getElementById('report-md').onclick = () => exportReport('markdown');
  document.getElementById('report-json').onclick = () => exportReport('json');
  document.querySelectorAll('.report-section-btn').forEach(btn => {
    btn.onclick = () => toggleReportSection(btn.dataset.section);
  });
  
  // v2.26 Symbol Mesh panel handlers
  document.getElementById('mesh-close').onclick = closeMeshPanel;
  document.getElementById('mesh-backdrop').onclick = closeMeshPanel;
  
  // v2.26 Causal Chain panel handlers
  document.getElementById('chain-close').onclick = closeChainPanel;
  document.getElementById('chain-backdrop').onclick = closeChainPanel;
  
  // v2.26 Mfidel panel handlers
  document.getElementById('mfidel-close').onclick = closeMfidelPanel;
  document.getElementById('mfidel-backdrop').onclick = closeMfidelPanel;
  
  // v2.26 Narrative panel handlers
  document.getElementById('narrative-close').onclick = closeNarrativePanel;
  document.getElementById('narrative-backdrop').onclick = closeNarrativePanel;
  
  // v2.26 InceptaDive panel handlers
  document.getElementById('dive-close').onclick = closeDivePanel;
  document.getElementById('dive-backdrop').onclick = closeDivePanel;
  
  // v2.26 Ontology panel handlers
  document.getElementById('ontology-close').onclick = closeOntologyPanel;
  document.getElementById('ontology-backdrop').onclick = closeOntologyPanel;
  
  // v2.26 Symbolic Query panel handlers
  document.getElementById('sql-close').onclick = closeSqlPanel;
  document.getElementById('sql-backdrop').onclick = closeSqlPanel;
  document.getElementById('sql-run').onclick = runSymbolicQuery;
  document.getElementById('sql-input').onkeydown = e => {
    if (e.key === 'Enter') runSymbolicQuery();
  };
  
  // v2.26 Audio panel handlers
  document.getElementById('audio-close').onclick = closeAudioPanel;
  document.getElementById('audio-backdrop').onclick = closeAudioPanel;
  
  // v2.26 Motion panel handlers
  document.getElementById('motion-close').onclick = closeMotionPanel;
  document.getElementById('motion-backdrop').onclick = closeMotionPanel;
  
  // v2.26 Mullu export panel handlers
  document.getElementById('mullu-close').onclick = closeMulluPanel;
  document.getElementById('mullu-backdrop').onclick = closeMulluPanel;
  document.getElementById('mullu-download').onclick = downloadMullu;
  document.getElementById('mullu-copy').onclick = copyMulluJson;
  
  // v2.26 Pattern panel handlers
  document.getElementById('pattern-close').onclick = closePatternPanel;
  document.getElementById('pattern-backdrop').onclick = closePatternPanel;
  
  // v2.26 Help panel handlers
  document.getElementById('help-close').onclick = closeHelpPanel;
  document.getElementById('help-backdrop').onclick = closeHelpPanel;
  
  // v2.26 Data panel handlers
  document.getElementById('data-close').onclick = closeDataPanel;
  document.getElementById('data-backdrop').onclick = closeDataPanel;
  document.getElementById('import-file-input').onchange = handleFileImport;
  
  // v2.26 Camera panel handlers
  document.getElementById('camera-close').onclick = closeCameraPanel;
  document.getElementById('camera-backdrop').onclick = closeCameraPanel;
  
  // v2.26 Clip editor panel handlers
  document.getElementById('clip-editor-close').onclick = closeClipEditorPanel;
  document.getElementById('clip-editor-backdrop').onclick = closeClipEditorPanel;
  setupClipTimelineDrag();
  
  // v2.26 Export panel handlers
  document.getElementById('export-panel-close').onclick = closeExportPanel;
  document.getElementById('export-panel-backdrop').onclick = closeExportPanel;
  
  // v2.26 Annotation panel handlers
  document.getElementById('annotation-close').onclick = closeAnnotationPanel;
  document.getElementById('annotation-backdrop').onclick = closeAnnotationPanel;
  
  // v2.26 Notes panel handlers
  document.getElementById('notes-close').onclick = closeNotesPanel;
  document.getElementById('notes-backdrop').onclick = closeNotesPanel;
  
  // v2.26 Cheatsheet panel handlers
  document.getElementById('cheatsheet-close').onclick = closeCheatsheet;
  document.getElementById('cheatsheet-backdrop').onclick = closeCheatsheet;
  
  // v2.26 History panel handlers
  document.getElementById('history-close').onclick = closeHistoryPanel;
  document.getElementById('history-backdrop').onclick = closeHistoryPanel;
  
  // v2.26 Project panel handlers
  document.getElementById('project-close').onclick = closeProjectBrowser;
  document.getElementById('project-backdrop').onclick = closeProjectBrowser;
  document.getElementById('new-project-close').onclick = closeNewProjectDialog;
  document.getElementById('new-project-backdrop').onclick = closeNewProjectDialog;
  document.getElementById('save-template-close').onclick = closeSaveTemplateDialog;
  document.getElementById('save-template-backdrop').onclick = closeSaveTemplateDialog;
  
  // v2.26 File import handlers
  document.getElementById('project-import-input').addEventListener('change', handleProjectImport);
  document.getElementById('template-import-input').addEventListener('change', handleTemplateImport);
  
  // v2.26 Share panel handlers
  document.getElementById('share-close').onclick = closeSharePanel;
  document.getElementById('share-backdrop').onclick = closeSharePanel;
  document.getElementById('create-share-close').onclick = closeCreateShareDialog;
  document.getElementById('create-share-backdrop').onclick = closeCreateShareDialog;
  document.getElementById('add-collab-close').onclick = closeAddCollaboratorDialog;
  document.getElementById('add-collab-backdrop').onclick = closeAddCollaboratorDialog;
  document.getElementById('comments-close').onclick = closeCommentsPanel;
  document.getElementById('comments-backdrop').onclick = closeCommentsPanel;
  
  // v2.26 Search panel handlers
  document.getElementById('search-close').onclick = closeSearchPanel;
  document.getElementById('search-backdrop').onclick = closeSearchPanel;
  document.getElementById('save-search-close').onclick = closeSaveSearchDialog;
  document.getElementById('save-search-backdrop').onclick = closeSaveSearchDialog;
  
  // v2.26 Info, Dashboard, About panel handlers
  document.getElementById('info-close').onclick = closeInfoPanel;
  document.getElementById('info-backdrop').onclick = closeInfoPanel;
  document.getElementById('dashboard-close').onclick = closeDashboard;
  document.getElementById('dashboard-backdrop').onclick = closeDashboard;
  document.getElementById('about-close').onclick = closeAboutDialog;
  document.getElementById('about-backdrop').onclick = closeAboutDialog;
  
  // v2.26 Initialize undo/redo UI
  updateUndoRedoUI();
  
  // v2.26 Timeline selection event
  document.addEventListener('timeline:select', (e) => {
    if (e.detail.type === 'marker') {
      markerEditorUI.render('marker-editor-container');
    }
  });
  
  // Apply saved theme on load
  const savedTheme = settingsManager.get('theme');
  if (savedTheme) themeManager.apply(savedTheme);
  
  // V2.17 â€” Initialize all components
  statusDashboard.render();
  quickActions.render();
  
  // V2.25 â€” Initialize main menu (hidden by default)
  mainMenu.render('main-menu-container');
  
  // V2.26 â€” UX components will be initialized AFTER system init in initAll()
  // Do NOT render floatingActions, statusBar here - they should wait for camera
  
  // Initialize accessibility
  a11y.initializePageA11y();
  
  // Start performance monitoring
  perfOptimizer.startMonitoring();
  
  // Initialize data manager
  dataManager.init().then(() => {
    console.log('[v2.26] DataManager initialized');
    
    // Check for draft recovery
    dataManager.loadDraft().then(draft => {
      if (draft && draft.serialized?.frames?.length > 0) {
        toast.info(`Draft found: ${draft.serialized.frames.length} frames. Type "recover" to restore.`);
      }
    });
  }).catch(err => {
    console.warn('[v2.26] DataManager init failed:', err);
  });
  
  // Enable auto-save by default
  if (settingsManager.get('autoSave')) {
    dataManager.enableAutoSave();
  }
  
  // PWA setup
  pwaManager._updateOnlineIndicator();
  
  // Mobile adaptation
  if (mobileAdapter.isMobile) {
    mobileAdapter.showMobileWarning();
  }
  
  // Show onboarding for first-time users
  if (onboarding.shouldShow()) {
    setTimeout(() => onboarding.start(), 500);
  }
  
  // Command palette handlers
  document.getElementById('command-backdrop').onclick = () => commandPalette.close();
  document.getElementById('command-input').oninput = e => commandPalette.filter(e.target.value);
  document.getElementById('command-input').onkeydown = handleCommandPaletteKey;
  document.getElementById('command-list').onclick = e => {
    const item = e.target.closest('.command-item');
    if (item) {
      commandPalette.selectedIndex = parseInt(item.dataset.index);
      commandPalette.execute();
    }
  };
  
  // Initialize v2.26 components
  initBookmarksSection();
  initTimelineMarkersContainer();
  
  // Initialize search results
  searchResults.init();
  
  // Timeline click to open playback
  document.getElementById('timeline-track').onclick = (e) => {
    const rect = e.target.getBoundingClientRect();
    const percent = ((e.clientX - rect.left) / rect.width) * 100;
    if (playbackEngine.totalFrames > 0) {
      playbackSeek(percent);
      openPlaybackPanel();
    } else {
      const container = orch?.getContainer();
      if (container && container.frames.length > 0) {
        playbackEngine.loadFromContainer(container);
        playbackSeek(percent);
        openPlaybackPanel();
      }
    }
  };
  
  // Theory panel handlers
  document.getElementById('theory-card').onclick = openTheoryPanel;
  document.getElementById('theory-close').onclick = closeTheoryPanel;
  document.getElementById('theory-backdrop').onclick = closeTheoryPanel;
  
  // Listen for theoretical analysis completion to update UI
  bus.on('frame:theoretical', ({ index, score }) => {
    DEBUG.theory_log('Frame theoretical complete:', index, score);
    // Update theory panel if open
    if (document.getElementById('theory-panel').classList.contains('open')) {
      updateTheoryPanel();
    }
  });
  
  // Sensor toggle handlers
  document.getElementById('switch-audio').onchange = e => toggleSensor('audio', e.target.checked);
  document.getElementById('switch-gps').onchange = e => toggleSensor('gps', e.target.checked);
  document.getElementById('switch-motion').onchange = e => toggleSensor('motion', e.target.checked);
  document.getElementById('switch-env').onchange = e => toggleSensor('env', e.target.checked);
  
  // Manual location handlers
  document.getElementById('btn-set-manual-location').onclick = setManualLocation;
  document.getElementById('btn-use-ip-location').onclick = useIPLocation;
  document.getElementById('manual-lat').onkeypress = e => { if (e.key === 'Enter') setManualLocation(); };
  document.getElementById('manual-lng').onkeypress = e => { if (e.key === 'Enter') setManualLocation(); };
  
  // Enhanced keyboard shortcuts
  document.addEventListener('keydown', e => { 
    if (e.target.matches('input, textarea')) return;
    
    // Check if playback panel is open
    const playbackOpen = document.getElementById('playback-panel').classList.contains('open');
    
    if (playbackOpen) {
      // Playback-specific shortcuts
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          playbackPlay();
          return;
        case 'ArrowLeft':
          e.preventDefault();
          playbackPrev();
          return;
        case 'ArrowRight':
          e.preventDefault();
          playbackNext();
          return;
        case 'Home':
          e.preventDefault();
          playbackEngine.seek(0);
          updatePlaybackUI();
          renderCurrentFrame();
          return;
        case 'End':
          e.preventDefault();
          playbackEngine.seek(playbackEngine.totalFrames - 1);
          updatePlaybackUI();
          renderCurrentFrame();
          return;
        case 'Escape':
          closePlaybackPanel();
          return;
      }
    }
    
    switch(e.code) {
      case 'Space':
        // Only allow recording if system is initialized (not on splash screen)
        if (orch.getState() !== 'idle' && orch.getState() !== 'initializing') {
          e.preventDefault();
          toggleRecording();
        }
        break;
      case 'KeyW':
        toggleWH();
        break;
      case 'KeyT':
        // Open theory panel
        if (orch.getState() !== 'idle') openTheoryPanel();
        break;
      case 'KeyR':
        // Open report/analysis panel
        if (orch.getState() !== 'idle') openPanel();
        break;
      case 'KeyS':
        // Open settings
        openSettings();
        break;
      case 'KeyF':
        // Flip camera
        if (orch.getState() !== 'idle') flipCamera();
        break;
      case 'KeyP':
        // Open playback panel
        if (orch.getState() !== 'idle') openPlaybackPanel();
        break;
      case 'KeyC':
        // Open compare panel
        if (orch.getState() !== 'idle') openComparePanel();
        break;
      case 'KeyA':
        // Open analytics panel
        if (orch.getState() !== 'idle') openAnalyticsPanel();
        break;
      case 'KeyX':
        // Open clip export panel
        if (orch.getState() !== 'idle') openClipPanel();
        break;
      case 'KeyG':
        // Open report panel
        if (orch.getState() !== 'idle') openReportPanel();
        break;
      case 'KeyS':
        // Open symbol mesh panel (v2.26)
        if (orch.getState() !== 'idle') openMeshPanel();
        break;
      case 'KeyD':
        // Open causal chains panel (v2.26)
        if (orch.getState() !== 'idle') openChainPanel();
        break;
      case 'KeyN':
        // Open narrative panel (v2.26)
        if (orch.getState() !== 'idle') openNarrativePanel();
        break;
      case 'KeyI':
        // Open InceptaDive explorer (v2.26)
        if (orch.getState() !== 'idle') openDivePanel();
        break;
      case 'KeyO':
        // Open Symbol Ontology browser (v2.26)
        if (orch.getState() !== 'idle') openOntologyPanel();
        break;
      case 'KeyQ':
        // Open Symbolic Query panel (v2.26)
        if (orch.getState() !== 'idle') openSqlPanel();
        break;
      case 'KeyU':
        // Open Audio waveform panel (v2.26)
        if (orch.getState() !== 'idle') openAudioPanel();
        break;
      case 'KeyJ':
        // Open Motion trajectory panel (v2.26)
        if (orch.getState() !== 'idle') openMotionPanel();
        break;
      case 'KeyE':
        // Open Mullu export panel (v2.26)
        if (orch.getState() !== 'idle') openMulluPanel();
        break;
      case 'KeyY':
        // Open Pattern detection panel (v2.26)
        if (orch.getState() !== 'idle') openPatternPanel();
        break;
      case 'KeyV':
        // Open Camera settings panel (v2.26)
        openCameraPanel();
        break;
      case 'KeyX':
        // Open Clip editor panel (v2.26)
        if (orch.getState() !== 'idle') openClipEditorPanel();
        break;
      case 'KeyZ':
        // Open Annotation timeline panel (v2.26)
        if (orch.getState() !== 'idle') openAnnotationPanel();
        break;
      case 'KeyN':
        // Open Notes panel or Narrative panel
        if (e.shiftKey) {
          if (orch.getState() !== 'idle') openNotesPanel();
        } else {
          if (orch.getState() !== 'idle') openNarrativePanel();
        }
        break;
      case 'KeyG':
        // Open Data manager panel (v2.26)
        openDataPanel();
        break;
      case 'KeyM':
        // Add marker at current frame (v2.26)
        if (orch.getState() !== 'idle' && playbackEngine?.totalFrames > 0) {
          addMarkerAtCurrent();
        } else {
          // Auto-detect markers
          if (orch.getState() !== 'idle') autoDetectMarkers();
        }
        break;
      case 'KeyS':
        // Save recording (Ctrl+S) (v2.26)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          saveCurrentRecording();
        }
        break;
      case 'KeyE':
        // Export panel (Ctrl+E) (v2.26)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          openExportPanel();
        } else {
          // Just E opens Mullu panel
          if (orch.getState() !== 'idle') openMulluPanel();
        }
        break;
      case 'KeyZ':
        // Undo (Ctrl+Z) or Annotation panel (Z)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          doUndo();
        } else {
          if (orch.getState() !== 'idle') openAnnotationPanel();
        }
        break;
      case 'KeyY':
        // Redo (Ctrl+Y) or Pattern panel (Y)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          doRedo();
        } else {
          if (orch.getState() !== 'idle') openPatternPanel();
        }
        break;
      case 'KeyH':
        // History panel (Ctrl+H) (v2.26)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          toggleHistoryPanel();
        }
        break;
      case 'KeyP':
        // Project browser (Ctrl+P) or Playback panel (P)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          openProjectBrowser();
        } else {
          if (orch.getState() !== 'idle') openPlaybackPanel();
        }
        break;
      case 'KeyN':
        // New project (Ctrl+N), Notes (Shift+N), or Narrative (N)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          createNewProject();
        } else if (e.shiftKey) {
          if (orch.getState() !== 'idle') openNotesPanel();
        } else {
          if (orch.getState() !== 'idle') openNarrativePanel();
        }
        break;
      case 'KeyS':
        // Share panel (Ctrl+Shift+S), Save (Ctrl+S), or Symbol Mesh (S)
        if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
          e.preventDefault();
          openSharePanel();
        } else if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          saveCurrentRecording();
        } else {
          if (orch.getState() !== 'idle') openMeshPanel();
        }
        break;
      case 'KeyK':
        // Global Search (Ctrl+K)
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          openSearchPanel();
        }
        break;
      case 'KeyF':
        // Find in current (Ctrl+F) - open search panel
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          openSearchPanel();
        }
        break;
      case 'KeyM':
        // Menu (Alt+M) or Auto-detect markers (M)
        if (e.altKey) {
          e.preventDefault();
          toggleMainMenu();
        } else if (orch.getState() !== 'idle') {
          autoDetectMarkers();
        }
        break;
      case 'KeyI':
        // Info Panel (Alt+I) or InceptaDive (I)
        if (e.altKey) {
          e.preventDefault();
          openInfoPanel();
        } else if (orch.getState() !== 'idle') {
          openDivePanel();
        }
        break;
      case 'KeyD':
        // Dashboard (Alt+D) or Causal Chains (D)
        if (e.altKey) {
          e.preventDefault();
          openDashboard();
        } else if (orch.getState() !== 'idle') {
          openChainsPanel();
        }
        break;
      case 'Slash':
        // Cheatsheet (?) - v2.27: Show keyboard shortcuts
        if (e.shiftKey) {
          e.preventDefault();
          keyboardShortcuts.toggle();
        }
        break;
      case 'F1':
        // Open Help/Shortcuts overlay (v2.27)
        e.preventDefault();
        keyboardShortcuts.toggle();
        break;
      case 'KeyL':
        // Cycle theme (v2.26)
        cycleTheme();
        break;
      case 'KeyB':
        // Add bookmark at current frame (in playback mode)
        if (playbackEngine.totalFrames > 0) addBookmarkAtCurrent();
        break;
      case 'BracketLeft':
        // Previous bookmark
        goToPrevBookmark();
        break;
      case 'BracketRight':
        // Next bookmark
        goToNextBookmark();
        break;
      case 'Escape':
        // First check if recording - stop it
        if (recordingController.getState() === 'recording' || recordingController.getState() === 'paused') {
          recordingController.forceStop();
          return;
        }
        // Close all panels
        if (commandPalette.isOpen) {
          commandPalette.close();
          return;
        }
        if (helpOverlay.isOpen) {
          helpOverlay.close();
          return;
        }
        closePanel();
        closeSettings();
        closeTheoryPanel();
        closePlaybackPanel();
        closeComparePanel();
        closeAnalyticsPanel();
        closeClipPanel();
        closeReportPanel();
        closeMeshPanel();
        closeChainPanel();
        closeMfidelPanel();
        closeNarrativePanel();
        closeDivePanel();
        closeOntologyPanel();
        closeSqlPanel();
        closeAudioPanel();
        closeMotionPanel();
        closeMulluPanel();
        closePatternPanel();
        closeDataPanel();
        closeCameraPanel();
        closeClipEditorPanel();
        closeExportPanel();
        closeAnnotationPanel();
        closeNotesPanel();
        closeCheatsheet();
        closeHistoryPanel();
        closeProjectBrowser();
        closeNewProjectDialog();
        closeSaveTemplateDialog();
        closeSharePanel();
        closeCreateShareDialog();
        closeAddCollaboratorDialog();
        closeCommentsPanel();
        closeSearchPanel();
        closeSaveSearchDialog();
        closeInfoPanel();
        closeDashboard();
        closeAboutDialog();
        closeMainMenu();
        break;
      case 'Slash':
        // Focus query input
        if (document.getElementById('panel').classList.contains('open')) {
          e.preventDefault();
          switchTab('query');
          document.getElementById('query-input').focus();
        }
        break;
    }
  });
  Log.ok('system', 'UI initialized');
});
</script>
</body>
</html>
