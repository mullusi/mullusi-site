<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mullu SGI — Symbolic General Intelligence</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #000;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            cursor: crosshair;
        }
        
        canvas { position: fixed; top: 0; left: 0; }
        #bgCanvas { z-index: 0; }
        #mainCanvas { z-index: 1; }
        #fxCanvas { z-index: 2; }
        #topCanvas { z-index: 3; pointer-events: none; }
        
        .hud {
            position: fixed;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            color: #fff;
        }
        
        /* Animated border frame */
        .border-frame {
            position: absolute;
            inset: 15px;
            border: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: none;
        }
        
        .border-frame::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 0;
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #0ff, transparent);
            animation: border-scan-h 4s linear infinite;
        }
        
        .border-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: -1px;
            width: 1px;
            height: 100px;
            background: linear-gradient(180deg, transparent, #f0f, transparent);
            animation: border-scan-v 4s linear infinite;
        }
        
        @keyframes border-scan-h {
            0% { left: 0; }
            100% { left: calc(100% - 100px); }
        }
        
        @keyframes border-scan-v {
            0% { top: 0; }
            100% { top: calc(100% - 100px); }
        }
        
        /* Corner decorations */
        .corner {
            position: absolute;
            width: 60px;
            height: 60px;
        }
        
        .corner::before, .corner::after {
            content: '';
            position: absolute;
            background: #0ff;
        }
        
        .corner.tl { top: 15px; left: 15px; }
        .corner.tr { top: 15px; right: 15px; transform: scaleX(-1); }
        .corner.bl { bottom: 15px; left: 15px; transform: scaleY(-1); }
        .corner.br { bottom: 15px; right: 15px; transform: scale(-1); }
        
        .corner::before { width: 30px; height: 2px; top: 0; left: 0; }
        .corner::after { width: 2px; height: 30px; top: 0; left: 0; }
        
        /* Top section */
        .top-section {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 25px 40px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
        }
        
        .logo-area {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .logo-symbol {
            width: 50px;
            height: 50px;
            position: relative;
            animation: logo-rotate 20s linear infinite;
        }
        
        @keyframes logo-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .logo-symbol::before {
            content: '';
            position: absolute;
            inset: 5px;
            border: 2px solid #0ff;
            transform: rotate(45deg);
            animation: logo-pulse 2s ease-in-out infinite;
        }
        
        .logo-symbol::after {
            content: 'ሙ';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #0ff;
            animation: logo-rotate 20s linear infinite reverse;
        }
        
        @keyframes logo-pulse {
            0%, 100% { box-shadow: 0 0 20px #0ff, inset 0 0 15px rgba(0,255,255,0.3); }
            50% { box-shadow: 0 0 40px #0ff, 0 0 60px rgba(0,255,255,0.3), inset 0 0 25px rgba(0,255,255,0.5); }
        }
        
        .logo-text {
            display: flex;
            flex-direction: column;
        }
        
        .logo-main {
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            font-weight: 700;
            letter-spacing: 0.4em;
            background: linear-gradient(135deg, #0ff 0%, #f0f 50%, #ff0 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-flow 3s ease infinite;
        }
        
        @keyframes gradient-flow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .logo-sub {
            font-size: 0.7em;
            letter-spacing: 0.5em;
            color: rgba(255,255,255,0.3);
            margin-top: 2px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 25px;
        }
        
        .status-item {
            text-align: center;
            padding: 10px 20px;
            background: rgba(0,255,255,0.02);
            border: 1px solid rgba(0,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .status-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.1), transparent);
            animation: status-shine 3s ease-in-out infinite;
        }
        
        @keyframes status-shine {
            0% { left: -100%; }
            50%, 100% { left: 100%; }
        }
        
        .status-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            font-weight: 500;
        }
        
        .status-label {
            font-size: 0.65em;
            letter-spacing: 0.3em;
            color: rgba(255,255,255,0.4);
            margin-top: 5px;
        }
        
        /* Left panel */
        .left-panel {
            position: absolute;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            width: 220px;
        }
        
        .panel-header {
            font-size: 0.7em;
            letter-spacing: 0.4em;
            color: rgba(255,255,255,0.3);
            padding-bottom: 10px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-header::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #0ff;
            animation: blink 1s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border-left: 3px solid;
            position: relative;
            transition: all 0.3s;
        }
        
        .layer-item::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .layer-item::before {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            background: currentColor;
            border-radius: 2px;
            animation: bar-fill 2s ease-in-out infinite;
        }
        
        @keyframes bar-fill {
            0%, 100% { width: 10px; }
            50% { width: 28px; }
        }
        
        .layer-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            position: relative;
        }
        
        .layer-icon::after {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            border: 1px solid currentColor;
            opacity: 0.3;
            animation: ripple 1.5s ease-out infinite;
        }
        
        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        .layer-info {
            flex: 1;
        }
        
        .layer-name {
            font-size: 0.8em;
            letter-spacing: 0.15em;
        }
        
        .layer-detail {
            font-size: 0.65em;
            color: rgba(255,255,255,0.3);
            margin-top: 2px;
        }
        
        /* Right panel */
        .right-panel {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            width: 260px;
        }
        
        .flow-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .flow-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.05);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }
        
        .flow-item.active {
            border-color: rgba(0,255,255,0.3);
            background: rgba(0,255,255,0.05);
        }
        
        .flow-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        
        .flow-num {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7em;
            color: rgba(255,255,255,0.2);
            width: 25px;
        }
        
        .flow-name {
            flex: 1;
            font-size: 0.8em;
            letter-spacing: 0.1em;
        }
        
        .flow-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        
        .flow-item.complete .flow-status {
            background: #0f8;
            box-shadow: 0 0 10px #0f8;
        }
        
        .flow-item.active .flow-status {
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
            animation: pulse-status 1s ease-in-out infinite;
        }
        
        @keyframes pulse-status {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        /* Center display */
        .center-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        
        .center-rings {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto;
        }
        
        .ring {
            position: absolute;
            border: 1px solid;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .ring-1 { width: 100px; height: 100px; border-color: rgba(0,255,255,0.3); animation: spin 10s linear infinite; }
        .ring-2 { width: 150px; height: 150px; border-color: rgba(255,0,255,0.2); animation: spin 15s linear infinite reverse; }
        .ring-3 { width: 200px; height: 200px; border-color: rgba(255,255,0,0.15); animation: spin 20s linear infinite; }
        .ring-4 { width: 250px; height: 250px; border-color: rgba(0,255,136,0.1); animation: spin 25s linear infinite reverse; }
        
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .center-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 3em;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff, 0 0 90px rgba(0,255,255,0.5);
        }
        
        .center-label {
            position: absolute;
            top: calc(50% + 170px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            letter-spacing: 0.4em;
            color: rgba(255,255,255,0.4);
            font-family: 'Orbitron', sans-serif;
        }
        
        .center-sublabel {
            position: absolute;
            top: calc(50% + 190px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6em;
            letter-spacing: 0.3em;
            color: rgba(255,255,255,0.2);
        }
        
        /* Bottom section */
        .bottom-section {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 300px;
            padding: 20px 40px 25px;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 60px;
        }
        
        .waveform-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .waveform {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 40px;
        }
        
        .wave-bar {
            width: 3px;
            background: linear-gradient(180deg, #0ff, #f0f);
            border-radius: 2px;
            transition: height 0.05s ease-out;
        }
        
        .waveform-label {
            font-size: 0.6em;
            letter-spacing: 0.3em;
            color: rgba(255,255,255,0.3);
        }
        
        /* Interactive hint */
        .hint {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.2);
            animation: hint-fade 3s ease-in-out infinite;
        }
        
        @keyframes hint-fade {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.5; }
        }
        
        /* Architect credit - Enhanced Holographic Display */
        .architect-credit {
            position: absolute;
            bottom: 25px;
            right: 40px;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px 30px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(0,255,255,0.4);
            backdrop-filter: blur(20px);
            animation: architect-glow 3s ease-in-out infinite;
            cursor: pointer;
            transition: all 0.4s ease;
            z-index: 100;
            overflow: visible;
        }
        
        /* Outer Fidel orbit container */
        .architect-fidel-field {
            position: absolute;
            top: 50%;
            left: -60px;
            width: 200px;
            height: 200px;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: 1;
        }
        
        /* Individual orbiting Fidel */
        .orbit-fidel {
            position: absolute;
            font-family: 'Nyala', 'Abyssinica SIL', serif;
            font-size: 1.2em;
            color: #0ff;
            text-shadow: 0 0 10px currentColor;
            opacity: 0.7;
            transition: opacity 0.3s, text-shadow 0.3s, transform 0.15s;
            will-change: transform;
        }
        
        .orbit-fidel.pulse {
            opacity: 1;
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
            transform: scale(1.3);
        }
        
        /* Fidel stream - vertical cascade */
        .fidel-stream {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .architect-credit:hover .fidel-stream {
            opacity: 1;
        }
        
        .stream-fidel {
            font-family: 'Nyala', 'Abyssinica SIL', serif;
            font-size: 0.9em;
            color: rgba(0,255,255,0.6);
            text-shadow: 0 0 8px currentColor;
            animation: stream-float 2s ease-in-out infinite;
        }
        
        .stream-fidel:nth-child(1) { animation-delay: 0s; }
        .stream-fidel:nth-child(2) { animation-delay: 0.15s; }
        .stream-fidel:nth-child(3) { animation-delay: 0.3s; }
        .stream-fidel:nth-child(4) { animation-delay: 0.45s; }
        .stream-fidel:nth-child(5) { animation-delay: 0.6s; }
        .stream-fidel:nth-child(6) { animation-delay: 0.75s; }
        .stream-fidel:nth-child(7) { animation-delay: 0.9s; }
        
        @keyframes stream-float {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
            50% { transform: translateY(-5px) scale(1.1); opacity: 1; }
        }
        
        /* Corner Fidel accents */
        .fidel-corner {
            position: absolute;
            font-family: 'Nyala', 'Abyssinica SIL', serif;
            font-size: 1.5em;
            opacity: 0.4;
            transition: all 0.3s ease;
        }
        
        .fidel-corner.top-left { top: -25px; left: -25px; color: #0ff; }
        .fidel-corner.top-right { top: -25px; right: -25px; color: #f0f; }
        .fidel-corner.bottom-left { bottom: -25px; left: -25px; color: #ff0; }
        .fidel-corner.bottom-right { bottom: -25px; right: -25px; color: #0f8; }
        
        .architect-credit:hover .fidel-corner {
            opacity: 0.9;
            text-shadow: 0 0 15px currentColor;
        }
        
        .fidel-corner.top-left { animation: corner-orbit-tl 8s linear infinite; }
        .fidel-corner.top-right { animation: corner-orbit-tr 8s linear infinite; }
        .fidel-corner.bottom-left { animation: corner-orbit-bl 8s linear infinite; }
        .fidel-corner.bottom-right { animation: corner-orbit-br 8s linear infinite; }
        
        @keyframes corner-orbit-tl {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(5px, 5px) rotate(90deg); }
            50% { transform: translate(0, 10px) rotate(180deg); }
            75% { transform: translate(-5px, 5px) rotate(270deg); }
        }
        
        @keyframes corner-orbit-tr {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-5px, 5px) rotate(-90deg); }
            50% { transform: translate(0, 10px) rotate(-180deg); }
            75% { transform: translate(5px, 5px) rotate(-270deg); }
        }
        
        @keyframes corner-orbit-bl {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(5px, -5px) rotate(90deg); }
            50% { transform: translate(0, -10px) rotate(180deg); }
            75% { transform: translate(-5px, -5px) rotate(270deg); }
        }
        
        @keyframes corner-orbit-br {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-5px, -5px) rotate(-90deg); }
            50% { transform: translate(0, -10px) rotate(-180deg); }
            75% { transform: translate(5px, -5px) rotate(-270deg); }
        }
        
        /* Decorative border patterns */
        .architect-credit::before {
            content: '';
            position: absolute;
            inset: -3px;
            border: 1px dashed rgba(0,255,255,0.2);
            pointer-events: none;
            animation: border-rotate 20s linear infinite;
        }
        
        .architect-credit::after {
            content: '';
            position: absolute;
            inset: -8px;
            border: 1px dotted rgba(255,0,255,0.15);
            pointer-events: none;
            animation: border-rotate 30s linear infinite reverse;
        }
        
        @keyframes border-rotate {
            from { border-radius: 5px 15px 5px 15px; }
            to { border-radius: 15px 5px 15px 5px; }
        }
        
        .architect-credit:hover {
            transform: scale(1.05);
            border-color: #0ff;
            box-shadow: 0 0 40px rgba(0,255,255,0.4), 0 0 80px rgba(255,0,255,0.2);
        }
        
        .architect-credit.active {
            transform: scale(1.1);
            border-color: #f0f;
        }
        
        @keyframes architect-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,255,0.15), inset 0 0 20px rgba(0,255,255,0.05); }
            50% { box-shadow: 0 0 40px rgba(0,255,255,0.3), 0 0 60px rgba(255,0,255,0.15), inset 0 0 30px rgba(255,0,255,0.05); }
        }
        
        /* Photo container with holographic rings */
        .architect-photo-container {
            position: relative;
            width: 80px;
            height: 80px;
        }
        
        .architect-photo {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #0ff;
            object-fit: cover;
            box-shadow: 0 0 25px rgba(0,255,255,0.5);
            animation: photo-pulse 4s ease-in-out infinite;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
        }
        
        .architect-credit:hover .architect-photo {
            border-color: #fff;
            box-shadow: 0 0 40px rgba(255,255,255,0.6);
        }
        
        @keyframes photo-pulse {
            0%, 100% { border-color: #0ff; box-shadow: 0 0 25px rgba(0,255,255,0.5); }
            33% { border-color: #0f8; box-shadow: 0 0 30px rgba(0,255,136,0.5); }
            66% { border-color: #f0f; box-shadow: 0 0 30px rgba(255,0,255,0.5); }
        }
        
        /* Holographic orbital rings */
        .photo-ring {
            position: absolute;
            border-radius: 50%;
            border: 1px solid;
            pointer-events: none;
        }
        
        .photo-ring-1 {
            width: 90px;
            height: 90px;
            top: -10px;
            left: -10px;
            border-color: rgba(0,255,255,0.4);
            animation: ring-orbit-1 6s linear infinite;
        }
        
        .photo-ring-2 {
            width: 100px;
            height: 100px;
            top: -15px;
            left: -15px;
            border-color: rgba(255,0,255,0.3);
            border-style: dashed;
            animation: ring-orbit-2 8s linear infinite reverse;
        }
        
        .photo-ring-3 {
            width: 110px;
            height: 110px;
            top: -20px;
            left: -20px;
            border-color: rgba(255,255,0,0.2);
            border-style: dotted;
            animation: ring-orbit-3 10s linear infinite;
        }
        
        @keyframes ring-orbit-1 {
            0% { transform: rotateX(60deg) rotateZ(0deg); }
            100% { transform: rotateX(60deg) rotateZ(360deg); }
        }
        
        @keyframes ring-orbit-2 {
            0% { transform: rotateX(70deg) rotateY(20deg) rotateZ(0deg); }
            100% { transform: rotateX(70deg) rotateY(20deg) rotateZ(360deg); }
        }
        
        @keyframes ring-orbit-3 {
            0% { transform: rotateX(50deg) rotateY(-30deg) rotateZ(0deg); }
            100% { transform: rotateX(50deg) rotateY(-30deg) rotateZ(360deg); }
        }
        
        /* Orbiting particles around photo */
        .photo-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #0ff;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 6px #0ff;
        }
        
        .photo-particle:nth-child(1) { animation: particle-orbit-1 3s linear infinite; }
        .photo-particle:nth-child(2) { animation: particle-orbit-2 4s linear infinite; background: #f0f; box-shadow: 0 0 6px #f0f; }
        .photo-particle:nth-child(3) { animation: particle-orbit-3 5s linear infinite; background: #ff0; box-shadow: 0 0 6px #ff0; }
        .photo-particle:nth-child(4) { animation: particle-orbit-4 3.5s linear infinite; background: #0f8; box-shadow: 0 0 6px #0f8; }
        .photo-particle:nth-child(5) { animation: particle-orbit-5 4.5s linear infinite; background: #f80; box-shadow: 0 0 6px #f80; }
        
        @keyframes particle-orbit-1 {
            0% { transform: rotate(0deg) translateX(45px) rotate(0deg); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: rotate(360deg) translateX(45px) rotate(-360deg); opacity: 1; }
        }
        @keyframes particle-orbit-2 {
            0% { transform: rotate(72deg) translateX(50px) rotate(-72deg); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: rotate(432deg) translateX(50px) rotate(-432deg); opacity: 1; }
        }
        @keyframes particle-orbit-3 {
            0% { transform: rotate(144deg) translateX(55px) rotate(-144deg); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: rotate(504deg) translateX(55px) rotate(-504deg); opacity: 1; }
        }
        @keyframes particle-orbit-4 {
            0% { transform: rotate(216deg) translateX(48px) rotate(-216deg); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: rotate(576deg) translateX(48px) rotate(-576deg); opacity: 1; }
        }
        @keyframes particle-orbit-5 {
            0% { transform: rotate(288deg) translateX(52px) rotate(-288deg); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: rotate(648deg) translateX(52px) rotate(-648deg); opacity: 1; }
        }
        
        /* Holographic scanline effect */
        .photo-scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 3;
        }
        
        .photo-scanline::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.8), transparent);
            animation: scanline-move 2s linear infinite;
        }
        
        @keyframes scanline-move {
            0% { top: -10%; }
            100% { top: 110%; }
        }
        
        /* Energy burst on click */
        .photo-energy-burst {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: radial-gradient(circle, #fff, #0ff);
            pointer-events: none;
            opacity: 0;
            z-index: 4;
        }
        
        .photo-energy-burst.active {
            animation: energy-burst 0.8s ease-out forwards;
        }
        
        @keyframes energy-burst {
            0% { width: 10px; height: 10px; opacity: 1; }
            100% { width: 300px; height: 300px; opacity: 0; }
        }
        
        .architect-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .architect-role {
            font-size: 0.55em;
            letter-spacing: 0.35em;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
        }
        
        .architect-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4em;
            font-weight: 700;
            letter-spacing: 0.3em;
            background: linear-gradient(90deg, #0ff, #f0f, #ff0, #0ff);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: name-gradient 4s linear infinite;
            text-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        
        @keyframes name-gradient {
            0% { background-position: 0% 50%; }
            100% { background-position: 300% 50%; }
        }
        
        /* Architect title with Ge'ez */
        .architect-title-geez {
            font-size: 0.7em;
            color: #f0f;
            letter-spacing: 0.15em;
            opacity: 0.7;
        }
        
        /* Connection line to system (drawn via canvas) */
        .architect-connector {
            position: absolute;
            bottom: 100%;
            right: 50%;
            width: 2px;
            height: 0;
            background: linear-gradient(to top, #0ff, transparent);
            transition: height 0.5s ease;
            pointer-events: none;
        }
        
        .architect-credit:hover .architect-connector {
            height: 50px;
        }
        
        /* ═══════════════════════════════════════════════════════════════ */
        /* HELP PANEL                                                       */
        /* ═══════════════════════════════════════════════════════════════ */
        
        .help-toggle {
            position: fixed;
            bottom: 25px;
            left: 25px;
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(0,255,255,0.4);
            border-radius: 50%;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 200;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .help-toggle:hover {
            background: rgba(0,255,255,0.15);
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0,255,255,0.4);
            transform: scale(1.1);
        }
        
        .help-panel {
            position: fixed;
            bottom: 70px;
            left: 25px;
            width: 280px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(0,255,255,0.3);
            backdrop-filter: blur(15px);
            padding: 15px;
            z-index: 190;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .help-panel.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .help-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
            color: #0ff;
            margin-bottom: 12px;
            letter-spacing: 0.15em;
            border-bottom: 1px solid rgba(0,255,255,0.2);
            padding-bottom: 8px;
        }
        
        .help-section {
            margin-bottom: 12px;
        }
        
        .help-section-title {
            font-size: 0.65em;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 6px;
        }
        
        .help-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 0.75em;
        }
        
        .help-key {
            background: rgba(0,255,255,0.15);
            border: 1px solid rgba(0,255,255,0.3);
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #0ff;
            min-width: 50px;
            text-align: center;
        }
        
        .help-desc {
            color: rgba(255,255,255,0.7);
            flex: 1;
            margin-left: 12px;
        }
        
        /* ═══════════════════════════════════════════════════════════════ */
        /* METRICS OVERLAY                                                  */
        /* ═══════════════════════════════════════════════════════════════ */
        
        .metrics-panel {
            position: fixed;
            top: 100px;
            right: 25px;
            width: 180px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,136,0,0.3);
            backdrop-filter: blur(10px);
            padding: 12px;
            z-index: 150;
            opacity: 0;
            transform: translateX(20px);
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .metrics-panel.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }
        
        .metrics-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7em;
            color: #f80;
            margin-bottom: 10px;
            letter-spacing: 0.15em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .metrics-title::before {
            content: '◈';
            color: #f80;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,136,0,0.1);
            font-size: 0.7em;
        }
        
        .metric-label {
            color: rgba(255,255,255,0.5);
        }
        
        .metric-value {
            color: #f80;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }
        
        .metric-bar {
            height: 4px;
            background: rgba(255,136,0,0.2);
            margin-top: 3px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .metric-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #f80, #ff0);
            transition: width 0.3s ease;
        }
        
        /* FPS Counter */
        .fps-counter {
            position: fixed;
            top: 25px;
            right: 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7em;
            color: #0f8;
            background: rgba(0,0,0,0.5);
            padding: 4px 10px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .fps-counter.visible {
            opacity: 1;
        }
        
        .fps-counter.warning {
            color: #ff0;
            border-color: rgba(255,255,0,0.3);
        }
        
        .fps-counter.critical {
            color: #f00;
            border-color: rgba(255,0,0,0.3);
        }
        
        /* ═══════════════════════════════════════════════════════════════ */
        /* SCREENSHOT FLASH                                                 */
        /* ═══════════════════════════════════════════════════════════════ */
        
        .screenshot-flash {
            position: fixed;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9998;
        }
        
        .screenshot-flash.active {
            animation: flash 0.3s ease-out;
        }
        
        @keyframes flash {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        
        .screenshot-toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(0,255,136,0.9);
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.3s ease;
        }
        
        .screenshot-toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Structure Depth Indicator */
        .structure-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .depth-level {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 8px 10px;
            background: rgba(255,255,255,0.02);
            border-left: 2px solid var(--level-color);
        }
        
        .depth-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7em;
            color: var(--level-color);
            min-width: 25px;
        }
        
        .depth-name {
            flex: 1;
            font-size: 0.75em;
            color: rgba(255,255,255,0.6);
        }
        
        .depth-nested {
            display: flex;
            gap: 3px;
        }
        
        .nested-dot {
            width: 6px;
            height: 6px;
            background: var(--level-color);
            border-radius: 50%;
            opacity: 0.6;
            animation: nested-pulse 1.5s ease-in-out infinite;
        }
        
        .nested-dot:nth-child(2) { animation-delay: 0.2s; }
        .nested-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes nested-pulse {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.3); opacity: 1; }
        }
        
        .depth-arrow {
            color: rgba(255,255,255,0.2);
            font-size: 0.8em;
        }
        
        /* Properties Grid */
        .properties-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .prop-item {
            font-size: 0.7em;
            color: rgba(255,255,255,0.5);
            padding: 5px 8px;
            background: rgba(255,255,255,0.02);
            border-left: 1px solid rgba(0,255,255,0.3);
            transition: all 0.3s;
        }
        
        .prop-item:hover {
            background: rgba(0,255,255,0.1);
            color: #0ff;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s, visibility 1s;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 4em;
            font-weight: 700;
            color: #0ff;
            text-shadow: 0 0 50px #0ff;
            animation: loading-pulse 1.5s ease-in-out infinite;
            margin-bottom: 40px;
        }
        
        @keyframes loading-pulse {
            0%, 100% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1); }
        }
        
        .loading-bar-container {
            width: 300px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0ff, #f0f, #ff0);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .loading-text {
            font-size: 0.8em;
            letter-spacing: 0.3em;
            color: rgba(255,255,255,0.4);
        }
        
        .loading-items {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.7em;
            color: rgba(255,255,255,0.3);
            font-family: monospace;
        }
        
        .loading-item {
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.3s;
        }
        
        .loading-item.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        .loading-item .check {
            color: #0f8;
            margin-right: 10px;
        }
        
        /* Nebula Background Effect */
        .nebula {
            position: fixed;
            inset: 0;
            z-index: -1;
            opacity: 0.3;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0,255,255,0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255,0,255,0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255,255,0,0.1) 0%, transparent 60%);
            animation: nebula-drift 20s ease-in-out infinite;
        }
        
        @keyframes nebula-drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(5deg); }
        }
        
        /* Scanline overlay */
        .scanlines {
            position: fixed;
            inset: 0;
            z-index: 1000;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.15) 2px,
                rgba(0,0,0,0.15) 4px
            );
            opacity: 0.25;
            animation: scanline-flicker 8s linear infinite;
        }
        
        @keyframes scanline-flicker {
            0%, 100% { opacity: 0.25; }
            50% { opacity: 0.2; }
            52% { opacity: 0.35; }
            54% { opacity: 0.25; }
        }
        
        /* Vignette - Enhanced */
        .vignette {
            position: fixed;
            inset: 0;
            z-index: 999;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 30%, rgba(0,0,10,0.4) 60%, rgba(0,0,5,0.85) 100%);
        }
        
        /* ═══════════════════════════════════════════════════════════════ */
        /* POST-PROCESSING EFFECTS                                         */
        /* ═══════════════════════════════════════════════════════════════ */
        
        /* Chromatic Aberration Overlay */
        .chromatic-aberration {
            position: fixed;
            inset: 0;
            z-index: 998;
            pointer-events: none;
            opacity: 0;
            mix-blend-mode: screen;
            animation: chromatic-pulse 10s ease-in-out infinite;
        }
        
        .chromatic-aberration::before,
        .chromatic-aberration::after {
            content: '';
            position: absolute;
            inset: 0;
            background: inherit;
        }
        
        .chromatic-aberration::before {
            background: linear-gradient(90deg, rgba(255,0,0,0.03) 0%, transparent 50%, rgba(0,255,255,0.03) 100%);
            transform: translateX(-2px);
        }
        
        .chromatic-aberration::after {
            background: linear-gradient(90deg, rgba(0,255,255,0.03) 0%, transparent 50%, rgba(255,0,0,0.03) 100%);
            transform: translateX(2px);
        }
        
        @keyframes chromatic-pulse {
            0%, 100% { opacity: 0.3; }
            30% { opacity: 0.5; }
            60% { opacity: 0.2; }
        }
        
        /* Bloom / Glow Overlay */
        .bloom-overlay {
            position: fixed;
            inset: 0;
            z-index: 997;
            pointer-events: none;
            background: radial-gradient(circle at 50% 50%, rgba(0,255,255,0.05) 0%, transparent 50%);
            filter: blur(40px);
            animation: bloom-breathe 6s ease-in-out infinite;
        }
        
        @keyframes bloom-breathe {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1);
            }
            50% { 
                opacity: 0.9;
                transform: scale(1.05);
            }
        }
        
        /* Film Grain */
        .film-grain {
            position: fixed;
            inset: 0;
            z-index: 1001;
            pointer-events: none;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            animation: grain-shift 0.5s steps(10) infinite;
        }
        
        @keyframes grain-shift {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-1%, -1%); }
            20% { transform: translate(1%, 1%); }
            30% { transform: translate(-1%, 1%); }
            40% { transform: translate(1%, -1%); }
            50% { transform: translate(-1%, 0); }
            60% { transform: translate(1%, 0); }
            70% { transform: translate(0, -1%); }
            80% { transform: translate(0, 1%); }
            90% { transform: translate(-1%, -1%); }
        }
        
        /* Atmospheric Glow - Edge highlights */
        .atmosphere-glow {
            position: fixed;
            inset: 0;
            z-index: 996;
            pointer-events: none;
            box-shadow: 
                inset 0 0 100px rgba(0,255,255,0.03),
                inset 0 0 200px rgba(255,0,255,0.02),
                inset 0 0 300px rgba(0,0,0,0.5);
            animation: atmosphere-shift 15s ease-in-out infinite;
        }
        
        @keyframes atmosphere-shift {
            0%, 100% {
                box-shadow: 
                    inset 0 0 100px rgba(0,255,255,0.03),
                    inset 0 0 200px rgba(255,0,255,0.02),
                    inset 0 0 300px rgba(0,0,0,0.5);
            }
            33% {
                box-shadow: 
                    inset 0 0 100px rgba(255,0,255,0.03),
                    inset 0 0 200px rgba(255,255,0,0.02),
                    inset 0 0 300px rgba(0,0,0,0.5);
            }
            66% {
                box-shadow: 
                    inset 0 0 100px rgba(0,255,136,0.03),
                    inset 0 0 200px rgba(0,255,255,0.02),
                    inset 0 0 300px rgba(0,0,0,0.5);
            }
        }
        
        /* Corner Brackets - Enhanced HUD */
        .corner-bracket {
            position: fixed;
            width: 60px;
            height: 60px;
            z-index: 1002;
            pointer-events: none;
        }
        
        .corner-bracket::before,
        .corner-bracket::after {
            content: '';
            position: absolute;
            background: linear-gradient(90deg, #0ff, transparent);
        }
        
        .corner-bracket::before {
            width: 100%;
            height: 2px;
            top: 0;
            left: 0;
        }
        
        .corner-bracket::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 0;
            background: linear-gradient(180deg, #0ff, transparent);
        }
        
        .corner-bracket.top-left { top: 20px; left: 20px; }
        .corner-bracket.top-right { 
            top: 20px; right: 20px; 
            transform: scaleX(-1);
        }
        .corner-bracket.bottom-left { 
            bottom: 20px; left: 20px; 
            transform: scaleY(-1);
        }
        .corner-bracket.bottom-right { 
            bottom: 20px; right: 20px; 
            transform: scale(-1, -1);
        }
        
        .corner-bracket.top-left::before,
        .corner-bracket.top-left::after {
            animation: corner-pulse-tl 4s ease-in-out infinite;
        }
        
        .corner-bracket.top-right::before,
        .corner-bracket.top-right::after {
            animation: corner-pulse-tr 4s ease-in-out infinite 1s;
        }
        
        .corner-bracket.bottom-left::before,
        .corner-bracket.bottom-left::after {
            animation: corner-pulse-bl 4s ease-in-out infinite 2s;
        }
        
        .corner-bracket.bottom-right::before,
        .corner-bracket.bottom-right::after {
            animation: corner-pulse-br 4s ease-in-out infinite 3s;
        }
        
        @keyframes corner-pulse-tl {
            0%, 100% { opacity: 0.5; filter: drop-shadow(0 0 5px #0ff); }
            50% { opacity: 1; filter: drop-shadow(0 0 15px #0ff); }
        }
        
        @keyframes corner-pulse-tr {
            0%, 100% { opacity: 0.5; filter: drop-shadow(0 0 5px #f0f); }
            50% { opacity: 1; filter: drop-shadow(0 0 15px #f0f); }
        }
        
        @keyframes corner-pulse-bl {
            0%, 100% { opacity: 0.5; filter: drop-shadow(0 0 5px #ff0); }
            50% { opacity: 1; filter: drop-shadow(0 0 15px #ff0); }
        }
        
        @keyframes corner-pulse-br {
            0%, 100% { opacity: 0.5; filter: drop-shadow(0 0 5px #0f8); }
            50% { opacity: 1; filter: drop-shadow(0 0 15px #0f8); }
        }
        
        /* Data Stream Lines */
        .data-stream {
            position: fixed;
            z-index: 995;
            pointer-events: none;
            overflow: hidden;
        }
        
        .data-stream.left {
            top: 0;
            left: 30px;
            width: 2px;
            height: 100%;
        }
        
        .data-stream.right {
            top: 0;
            right: 30px;
            width: 2px;
            height: 100%;
        }
        
        .data-stream::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 80px;
            background: linear-gradient(180deg, transparent, #0ff, transparent);
            animation: data-flow 3s linear infinite;
        }
        
        .data-stream.right::before {
            animation-delay: -1.5s;
            background: linear-gradient(180deg, transparent, #f0f, transparent);
        }
        
        @keyframes data-flow {
            0% { top: -80px; opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { top: 100%; opacity: 0; }
        }

        /* Floating Ge'ez characters */
        .floating-chars {
            position: fixed;
            inset: 0;
            z-index: 50;
            pointer-events: none;
            overflow: hidden;
            display: none; /* Disabled - Fidels now orbit architect */
        }
        
        .float-char {
            position: absolute;
            font-size: 1.5em;
            color: rgba(0,255,255,0.4);
            text-shadow: 0 0 10px currentColor;
            pointer-events: none;
            z-index: 1;
            will-change: transform, opacity, left, top, color, font-size;
            font-family: 'Nyala', 'Abyssinica SIL', serif;
        }
        
        /* Structure of Structures Panel */
        .structure-panel {
            position: absolute;
            left: 25px;
            bottom: 120px;
            width: 280px;
            max-height: 320px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(0,255,255,0.3);
            padding: 15px;
            backdrop-filter: blur(15px);
            overflow: hidden;
            transition: all 0.5s ease;
        }
        
        .structure-panel.expanded {
            width: 350px;
            max-height: 450px;
        }
        
        .structure-title {
            font-size: 0.7em;
            letter-spacing: 0.3em;
            color: rgba(0,255,255,0.8);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid rgba(0,255,255,0.2);
            padding-bottom: 8px;
        }
        
        .structure-title::before {
            content: '◇';
            color: #0ff;
            animation: diamond-spin 4s linear infinite;
        }
        
        @keyframes diamond-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .structure-concept {
            font-size: 0.6em;
            color: rgba(255,255,255,0.4);
            margin-bottom: 10px;
            line-height: 1.6;
            font-style: italic;
        }
        
        .structure-tree {
            font-family: monospace;
            font-size: 0.7em;
            color: rgba(255,255,255,0.6);
            line-height: 1.9;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .structure-tree::-webkit-scrollbar {
            width: 4px;
        }
        
        .structure-tree::-webkit-scrollbar-track {
            background: rgba(0,255,255,0.05);
        }
        
        .structure-tree::-webkit-scrollbar-thumb {
            background: rgba(0,255,255,0.3);
        }
        
        .structure-tree .level-0 { color: #fff; font-weight: bold; }
        .structure-tree .level-1 { color: #0ff; padding-left: 12px; }
        .structure-tree .level-2 { color: #0f8; padding-left: 24px; }
        .structure-tree .level-3 { color: #ff0; padding-left: 36px; }
        .structure-tree .level-4 { color: #f80; padding-left: 48px; }
        .structure-tree .level-5 { color: #f0f; padding-left: 60px; }
        
        .structure-line {
            opacity: 0.7;
            transition: all 0.3s;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .structure-line:hover {
            opacity: 1;
            background: rgba(0,255,255,0.1);
            text-shadow: 0 0 10px currentColor;
        }
        
        .structure-line.active {
            opacity: 1;
            background: rgba(0,255,255,0.2);
            border-left: 2px solid currentColor;
        }
        
        .structure-line .branch {
            color: rgba(255,255,255,0.25);
        }
        
        .structure-line .symbol {
            font-size: 1.1em;
            margin-right: 4px;
        }
        
        .structure-line .node-count {
            font-size: 0.85em;
            color: rgba(255,255,255,0.3);
            margin-left: 5px;
        }
        
        .structure-depth {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(0,255,255,0.1);
        }
        
        .depth-label {
            font-size: 0.55em;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.3);
            margin-bottom: 6px;
        }
        
        .depth-bars {
            display: flex;
            gap: 3px;
            height: 20px;
            align-items: flex-end;
        }
        
        .depth-bar {
            width: 8px;
            background: linear-gradient(to top, #0ff, #f0f);
            border-radius: 2px;
            transition: height 0.3s ease;
        }
        
        /* Zoom indicator */
        .zoom-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border: 1px solid rgba(0,255,255,0.3);
            backdrop-filter: blur(10px);
        }
        
        .zoom-indicator.active {
            opacity: 1;
        }
        
        .zoom-level {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            color: #0ff;
            letter-spacing: 0.2em;
            margin-bottom: 8px;
        }
        
        .zoom-path {
            font-size: 0.7em;
            color: rgba(255,255,255,0.5);
            letter-spacing: 0.1em;
        }
        
        .zoom-path span {
            color: #0ff;
        }
        
        /* Structure DNA Panel */
        .structure-dna-panel {
            position: absolute;
            right: 25px;
            top: 180px;
            width: 200px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,136,0,0.3);
            padding: 12px;
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.4s ease;
        }
        
        .structure-dna-panel.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .dna-title {
            font-size: 0.65em;
            letter-spacing: 0.25em;
            color: #f80;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255,136,0,0.2);
        }
        
        .dna-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.6em;
        }
        
        .dna-label {
            color: rgba(255,255,255,0.4);
            letter-spacing: 0.1em;
        }
        
        .dna-value {
            color: #f80;
            font-family: monospace;
        }
        
        .dna-helix {
            height: 30px;
            margin-top: 10px;
            background: linear-gradient(90deg, 
                transparent 0%, rgba(255,136,0,0.2) 25%, 
                rgba(0,255,255,0.2) 50%, rgba(255,136,0,0.2) 75%, 
                transparent 100%);
            position: relative;
            overflow: hidden;
        }
        
        .dna-helix::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px, transparent 10px,
                rgba(255,136,0,0.4) 10px, rgba(255,136,0,0.4) 12px,
                transparent 12px, transparent 22px
            );
            animation: dna-scroll 2s linear infinite;
        }
        
        @keyframes dna-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Wh-Logic Panel */
        .wh-logic-panel {
            position: absolute;
            left: 25px;
            top: 180px;
            width: 160px;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(0,255,136,0.3);
            padding: 12px;
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.4s ease;
        }
        
        .wh-logic-panel.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .wh-title {
            font-size: 0.65em;
            letter-spacing: 0.25em;
            color: #0f8;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0,255,136,0.2);
        }
        
        .wh-gates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .wh-gate {
            font-size: 0.55em;
            padding: 6px;
            background: rgba(0,255,136,0.05);
            border: 1px solid rgba(0,255,136,0.1);
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .wh-gate:hover {
            background: rgba(0,255,136,0.15);
            border-color: rgba(0,255,136,0.4);
        }
        
        .wh-gate.active {
            background: rgba(0,255,136,0.25);
            border-color: #0f8;
            box-shadow: 0 0 10px rgba(0,255,136,0.3);
        }
        
        .wh-symbol {
            display: block;
            font-size: 1.2em;
            color: #0f8;
            margin-bottom: 2px;
        }
        
        .wh-active-query {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(0,255,136,0.1);
            font-size: 0.5em;
            color: rgba(255,255,255,0.4);
            text-align: center;
            min-height: 30px;
        }
        
        /* Causal Chain Panel */
        .causal-chain-panel {
            position: absolute;
            bottom: 320px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,0,0.3);
            padding: 15px 25px;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: all 0.4s ease;
        }
        
        .causal-chain-panel.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .causal-title {
            font-size: 0.6em;
            letter-spacing: 0.3em;
            color: #ff0;
            text-align: center;
            margin-bottom: 12px;
        }
        
        .causal-flow {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .causal-node {
            padding: 8px 15px;
            font-size: 0.6em;
            letter-spacing: 0.1em;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        .causal-node.cause {
            background: rgba(0,255,255,0.15);
            border: 1px solid #0ff;
            color: #0ff;
        }
        
        .causal-node.mechanism {
            background: rgba(255,255,0,0.15);
            border: 1px solid #ff0;
            color: #ff0;
        }
        
        .causal-node.effect {
            background: rgba(255,0,255,0.15);
            border: 1px solid #f0f;
            color: #f0f;
        }
        
        .causal-node.active {
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.1);
        }
        
        .causal-arrow {
            color: rgba(255,255,255,0.3);
            font-size: 1.5em;
            animation: arrow-pulse 1s ease-in-out infinite;
        }
        
        @keyframes arrow-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; color: #ff0; }
        }
        
        .causal-inversion {
            margin-top: 10px;
            text-align: center;
            font-size: 0.55em;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,0,0.1);
        }
        
        .inversion-label {
            color: rgba(255,255,255,0.4);
            margin-right: 10px;
        }
        
        .inversion-status {
            color: #0f8;
        }
        
        /* Fractal depth rings */
        @keyframes depth-pulse {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.02); }
        }
        
        /* Nested structure mini-view */
        .nested-preview {
            position: absolute;
            right: 25px;
            bottom: 120px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,0,255,0.3);
            backdrop-filter: blur(10px);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .nested-preview.active {
            opacity: 1;
        }
        
        .nested-preview-title {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.55em;
            letter-spacing: 0.2em;
            color: rgba(255,0,255,0.6);
        }
        
        .nested-preview canvas {
            width: 100%;
            height: 100%;
        }
        /* Touch device specific styles */
        body.touch-device .architect-credit {
            cursor: pointer;
        }
        
        body.touch-device .control-panel button {
            min-height: 48px;
            padding: 12px 18px;
        }
        
        body.touch-device .node-label {
            font-size: 1.1em;
        }
        
        /* Mobile menu button */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 15px;
            right: 15px;
            width: 44px;
            height: 44px;
            background: rgba(0,20,40,0.9);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 8px;
            color: #0ff;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 1100;
            backdrop-filter: blur(10px);
        }
        
        .mobile-menu-btn:active {
            background: rgba(0,255,255,0.2);
        }
        
        @media screen and (max-width: 768px) {
            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* ═══════════════════════════════════════════════════════════════ */
        /* MOBILE RESPONSIVE STYLES                                        */
        /* ═══════════════════════════════════════════════════════════════ */
        
        /* Touch device detection */
        @media (hover: none) and (pointer: coarse) {
            .architect-credit {
                /* Always show on touch devices */
                opacity: 1 !important;
            }
            
            .control-panel button,
            .metrics-panel {
                min-height: 44px;
                min-width: 44px;
            }
        }
        
        /* Small phones */
        @media screen and (max-width: 480px) {
            .title-container h1 {
                font-size: 1.8em;
            }
            
            .title-container .subtitle {
                font-size: 0.7em;
                letter-spacing: 2px;
            }
            
            .control-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                padding: 10px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            
            .control-panel button {
                padding: 10px 14px;
                font-size: 0.7em;
                flex: 1 1 auto;
                min-width: 80px;
            }
            
            .metrics-panel {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
                font-size: 0.65em;
                padding: 8px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }
            
            .metrics-panel > div {
                flex: 0 0 auto;
            }
            
            .help-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                bottom: auto;
                max-height: 60vh;
                font-size: 0.75em;
                padding: 15px;
                display: none;
            }
            
            .help-panel.visible {
                display: block;
            }
            
            .help-panel h3 {
                font-size: 1.1em;
            }
            
            .architect-credit {
                bottom: 140px;
                right: 10px;
                left: 10px;
                padding: 12px;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .architect-photo-container {
                width: 60px !important;
                height: 60px !important;
                margin-bottom: 10px;
            }
            
            .architect-photo {
                width: 60px !important;
                height: 60px !important;
            }
            
            .architect-info {
                margin-left: 0;
            }
            
            .mfidel-frame {
                inset: -25px !important;
                font-size: 0.7em !important;
            }
            
            #mfidelMainChar {
                font-size: 2em !important;
            }
            
            #mfidelFamilyRow {
                font-size: 0.5em !important;
            }
            
            /* Corner brackets - hide on small screens */
            .corner-bracket {
                display: none;
            }
            
            /* Data streams - hide on small screens */
            .data-stream {
                display: none;
            }
            
            /* Simplify post-processing on mobile */
            .chromatic-aberration,
            .film-grain {
                display: none;
            }
        }
        
        /* Tablets and medium screens */
        @media screen and (min-width: 481px) and (max-width: 768px) {
            .title-container h1 {
                font-size: 2.2em;
            }
            
            .control-panel {
                bottom: 15px;
                left: 15px;
                padding: 12px;
            }
            
            .control-panel button {
                padding: 10px 16px;
                font-size: 0.75em;
            }
            
            .metrics-panel {
                font-size: 0.7em;
            }
            
            .help-panel {
                max-width: 350px;
                font-size: 0.8em;
            }
            
            .architect-credit {
                bottom: 15px;
                right: 15px;
                padding: 14px 18px;
            }
            
            .architect-photo-container {
                width: 65px !important;
                height: 65px !important;
            }
            
            .mfidel-frame {
                inset: -30px !important;
            }
        }
        
        /* Landscape phone orientation */
        @media screen and (max-height: 480px) and (orientation: landscape) {
            .title-container {
                top: 5px;
            }
            
            .title-container h1 {
                font-size: 1.6em;
            }
            
            .title-container .subtitle {
                font-size: 0.6em;
            }
            
            .control-panel {
                bottom: 5px;
                left: 5px;
                padding: 8px;
                flex-direction: row;
            }
            
            .control-panel button {
                padding: 8px 12px;
                font-size: 0.65em;
            }
            
            .metrics-panel {
                top: 5px;
                right: 5px;
                font-size: 0.6em;
                padding: 6px;
            }
            
            .help-panel {
                max-height: 80vh;
                max-width: 300px;
                font-size: 0.7em;
            }
            
            .architect-credit {
                bottom: 5px;
                right: 5px;
                padding: 10px;
                transform: scale(0.85);
                transform-origin: bottom right;
            }
        }
        
        /* Large screens */
        @media screen and (min-width: 1200px) {
            .title-container h1 {
                font-size: 3.5em;
            }
            
            .architect-credit {
                padding: 18px 25px;
            }
            
            .architect-photo-container {
                width: 80px !important;
                height: 80px !important;
            }
        }
        
        /* High DPI / Retina displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .architect-photo {
                image-rendering: -webkit-optimize-contrast;
            }
        }
        
        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .floating-char,
            .photo-ring,
            .photo-particle {
                animation: none !important;
            }
        }
        
        /* Dark mode enhancement */
        @media (prefers-color-scheme: dark) {
            body {
                background: #000;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">ሙ MULLU</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text">INITIALIZING SYMBOLIC ENGINE</div>
        <div class="loading-items">
            <div class="loading-item" id="load1"><span class="check">✓</span> Loading perception layer...</div>
            <div class="loading-item" id="load2"><span class="check">✓</span> Initializing symbol registry...</div>
            <div class="loading-item" id="load3"><span class="check">✓</span> Building nested structures...</div>
            <div class="loading-item" id="load4"><span class="check">✓</span> Mapping structure of structures...</div>
            <div class="loading-item" id="load5"><span class="check">✓</span> Activating meta-orchestration...</div>
            <div class="loading-item" id="load6"><span class="check">✓</span> System ready.</div>
        </div>
    </div>
    
    <!-- Visual Overlays -->
    <div class="nebula"></div>
    <!-- Help Toggle Button -->
    <button class="help-toggle" id="helpToggle" title="Keyboard Shortcuts">?</button>
    
    <!-- Help Panel -->
    <!-- Mobile Menu Button -->
    <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="Toggle menu">☰</button>
    
    <div class="help-panel" id="helpPanel">>
        <div class="help-title">⌨ CONTROLS</div>
        
        <div class="help-section">
            <div class="help-section-title">Navigation</div>
            <div class="help-row"><span class="help-key">Click</span><span class="help-desc">Select node / Energize</span></div>
            <div class="help-row"><span class="help-key">Hold</span><span class="help-desc">Dive into structure</span></div>
            <div class="help-row"><span class="help-key">Z</span><span class="help-desc">Zoom into selected</span></div>
            <div class="help-row"><span class="help-key">X</span><span class="help-desc">Zoom out</span></div>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">Visualization</div>
            <div class="help-row"><span class="help-key">S</span><span class="help-desc">Structure fractals</span></div>
            <div class="help-row"><span class="help-key">W</span><span class="help-desc">Wh-Logic gates</span></div>
            <div class="help-row"><span class="help-key">C</span><span class="help-desc">Causal chains</span></div>
            <div class="help-row"><span class="help-key">D</span><span class="help-desc">Cycle depth level</span></div>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">Effects & Tools</div>
            <div class="help-row"><span class="help-key">SPACE</span><span class="help-desc">Lightning storm</span></div>
            <div class="help-row"><span class="help-key">E</span><span class="help-desc">Toggle effects</span></div>
            <div class="help-row"><span class="help-key">G</span><span class="help-desc">Toggle grain</span></div>
            <div class="help-row"><span class="help-key">V</span><span class="help-desc">Toggle vignette</span></div>
            <div class="help-row"><span class="help-key">M</span><span class="help-desc">Metrics panel</span></div>
            <div class="help-row"><span class="help-key">F</span><span class="help-desc">FPS counter</span></div>
            <div class="help-row"><span class="help-key">P</span><span class="help-desc">Screenshot</span></div>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">Architect</div>
            <div class="help-row"><span class="help-key">Photo</span><span class="help-desc">Click to connect</span></div>
        </div>
    </div>
    
    <!-- Metrics Panel -->
    <div class="metrics-panel" id="metricsPanel">
        <div class="metrics-title">SYSTEM METRICS</div>
        <div class="metric-row">
            <span class="metric-label">Symbols</span>
            <span class="metric-value" id="metricSymbols">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Connections</span>
            <span class="metric-value" id="metricConnections">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Particles</span>
            <span class="metric-value" id="metricParticles">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Active Effects</span>
            <span class="metric-value" id="metricEffects">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Causal Depth</span>
            <span class="metric-value" id="metricDepth">0</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">Wh-Entropy</span>
            <span class="metric-value" id="metricEntropy">—</span>
        </div>
        <div class="metric-row" style="flex-direction: column; align-items: stretch;">
            <div style="display: flex; justify-content: space-between;">
                <span class="metric-label">System Load</span>
                <span class="metric-value" id="metricLoad">0%</span>
            </div>
            <div class="metric-bar">
                <div class="metric-bar-fill" id="metricLoadBar" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <!-- FPS Counter -->
    <div class="fps-counter" id="fpsCounter">60 FPS</div>
    
    <!-- Screenshot Flash -->
    <div class="screenshot-flash" id="screenshotFlash"></div>
    <div class="screenshot-toast" id="screenshotToast">📸 Screenshot saved!</div>

    <div class="scanlines"></div>
    <div class="vignette"></div>
    
    <!-- Post-Processing Effects -->
    <div class="chromatic-aberration"></div>
    <div class="bloom-overlay"></div>
    <div class="film-grain"></div>
    <div class="atmosphere-glow"></div>
    
    <!-- Corner Brackets HUD -->
    <div class="corner-bracket top-left"></div>
    <div class="corner-bracket top-right"></div>
    <div class="corner-bracket bottom-left"></div>
    <div class="corner-bracket bottom-right"></div>
    
    <!-- Data Stream Lines -->
    <div class="data-stream left"></div>
    <div class="data-stream right"></div>
    <div class="floating-chars" id="floatingChars"></div>
    
    <canvas id="bgCanvas"></canvas>
    <canvas id="mainCanvas"></canvas>
    <canvas id="fxCanvas"></canvas>
    <canvas id="topCanvas"></canvas>
    
    <div class="hud">
        <div class="border-frame"></div>
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
        
        <div class="top-section">
            <div class="logo-area">
                <div class="logo-symbol"></div>
                <div class="logo-text">
                    <div class="logo-main">MULLU</div>
                    <div class="logo-sub">SYMBOLIC GENERAL INTELLIGENCE</div>
                </div>
            </div>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-value" style="color: #0ff;" id="stat1">0</div>
                    <div class="status-label">SYMBOLS</div>
                </div>
                <div class="status-item">
                    <div class="status-value" style="color: #0f8;" id="stat2">0</div>
                    <div class="status-label">BONDS</div>
                </div>
                <div class="status-item">
                    <div class="status-value" style="color: #ff0;" id="stat3">5</div>
                    <div class="status-label">LAYERS</div>
                </div>
                <div class="status-item">
                    <div class="status-value" style="color: #f0f;" id="stat4">0.00</div>
                    <div class="status-label">COHERENCE</div>
                </div>
            </div>
        </div>
        
        <div class="left-panel">
            <div class="panel-header">SYMBOLIC STRUCTURES</div>
            <div class="layer-list">
                <div class="layer-item" style="border-color: #0ff; color: #0ff;">
                    <div class="layer-icon" style="background: #0ff;"></div>
                    <div class="layer-info">
                        <div class="layer-name">PERCEPTION</div>
                        <div class="layer-detail">identity · boundary</div>
                    </div>
                </div>
                <div class="layer-item" style="border-color: #0f8; color: #0f8;">
                    <div class="layer-icon" style="background: #0f8;"></div>
                    <div class="layer-info">
                        <div class="layer-name">TOKENIZATION</div>
                        <div class="layer-detail">behavior · state</div>
                    </div>
                </div>
                <div class="layer-item" style="border-color: #ff0; color: #ff0;">
                    <div class="layer-icon" style="background: #ff0;"></div>
                    <div class="layer-info">
                        <div class="layer-name">ABSTRACTION</div>
                        <div class="layer-detail">relation · property</div>
                    </div>
                </div>
                <div class="layer-item" style="border-color: #f80; color: #f80;">
                    <div class="layer-icon" style="background: #f80;"></div>
                    <div class="layer-info">
                        <div class="layer-name">REASONING</div>
                        <div class="layer-detail">transform · inference</div>
                    </div>
                </div>
                <div class="layer-item" style="border-color: #f0f; color: #f0f;">
                    <div class="layer-icon" style="background: #f0f;"></div>
                    <div class="layer-info">
                        <div class="layer-name">META-COGNITION</div>
                        <div class="layer-detail">orchestration · reflection</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-header" style="margin-top: 20px;">NESTED PROPERTIES</div>
            <div class="properties-grid">
                <div class="prop-item">⬡ identity</div>
                <div class="prop-item">◇ behavior</div>
                <div class="prop-item">△ property</div>
                <div class="prop-item">○ boundary</div>
                <div class="prop-item">□ structure</div>
                <div class="prop-item">✦ relation</div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="panel-header">PROCESSING PIPELINE</div>
            <div class="flow-list">
                <div class="flow-item complete" id="flow1">
                    <span class="flow-num">01</span>
                    <span class="flow-name">Symbol Detection</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item complete" id="flow2">
                    <span class="flow-num">02</span>
                    <span class="flow-name">Relation Mapping</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item active" id="flow3">
                    <span class="flow-num">03</span>
                    <span class="flow-name">Causal Analysis</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item" id="flow4">
                    <span class="flow-num">04</span>
                    <span class="flow-name">Structure Nesting</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item" id="flow5">
                    <span class="flow-num">05</span>
                    <span class="flow-name">Meta Orchestration</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item" id="flow6">
                    <span class="flow-num">06</span>
                    <span class="flow-name">Inversion Check</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item" id="flow7">
                    <span class="flow-num">07</span>
                    <span class="flow-name">Blocker Analysis</span>
                    <div class="flow-status"></div>
                </div>
                <div class="flow-item" id="flow8">
                    <span class="flow-num">08</span>
                    <span class="flow-name">Output Generation</span>
                    <div class="flow-status"></div>
                </div>
            </div>
            
            <div class="panel-header" style="margin-top: 20px;">STRUCTURE DEPTH</div>
            <div class="structure-indicator">
                <div class="depth-level" style="--level-color: #0ff;">
                    <span class="depth-label">L0</span>
                    <span class="depth-name">Symbol</span>
                    <div class="depth-nested">
                        <div class="nested-dot"></div>
                        <div class="nested-dot"></div>
                        <div class="nested-dot"></div>
                    </div>
                </div>
                <div class="depth-arrow">↓</div>
                <div class="depth-level" style="--level-color: #0f8;">
                    <span class="depth-label">L1</span>
                    <span class="depth-name">Property</span>
                    <div class="depth-nested">
                        <div class="nested-dot"></div>
                        <div class="nested-dot"></div>
                    </div>
                </div>
                <div class="depth-arrow">↓</div>
                <div class="depth-level" style="--level-color: #ff0;">
                    <span class="depth-label">L2</span>
                    <span class="depth-name">Metadata</span>
                    <div class="depth-nested">
                        <div class="nested-dot"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="center-display">
            <div class="center-rings">
                <div class="ring ring-1"></div>
                <div class="ring ring-2"></div>
                <div class="ring ring-3"></div>
                <div class="ring ring-4"></div>
                <div class="center-core">ሙ</div>
            </div>
            <div class="center-label">STRUCTURE OF STRUCTURES</div>
            <div class="center-sublabel">NESTED SYMBOLIC ARCHITECTURE</div>
        </div>
        
        <div class="architect-credit">
            <img src="data:image/webp;base64,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" alt="Architect" class="architect-photo">
            <div class="architect-info">
                <div class="architect-role">ARCHITECT</div>
                <div class="architect-name">TAMIRAT</div>
            </div>
        </div>
        
        <div class="bottom-section">
            <div class="waveform-container">
                <div class="waveform" id="wave1"></div>
                <div class="waveform-label">INPUT STREAM</div>
            </div>
            <div class="waveform-container">
                <div class="waveform" id="wave2"></div>
                <div class="waveform-label">PROCESSING</div>
            </div>
            <div class="waveform-container">
                <div class="waveform" id="wave3"></div>
                <div class="waveform-label">OUTPUT STREAM</div>
            </div>
        </div>
        
        <!-- Structure DNA/Metadata Panel -->
        <div class="structure-dna-panel" id="structureDNA">
            <div class="dna-title">◇ STRUCTURE DNA</div>
            <div class="dna-content">
                <div class="dna-row">
                    <span class="dna-label">IDENTITY</span>
                    <span class="dna-value" id="dnaIdentity">—</span>
                </div>
                <div class="dna-row">
                    <span class="dna-label">BEHAVIOR</span>
                    <span class="dna-value" id="dnaBehavior">—</span>
                </div>
                <div class="dna-row">
                    <span class="dna-label">PROPERTY</span>
                    <span class="dna-value" id="dnaProperty">—</span>
                </div>
                <div class="dna-row">
                    <span class="dna-label">BOUNDARY</span>
                    <span class="dna-value" id="dnaBoundary">—</span>
                </div>
                <div class="dna-row">
                    <span class="dna-label">CHILDREN</span>
                    <span class="dna-value" id="dnaChildren">—</span>
                </div>
                <div class="dna-row">
                    <span class="dna-label">DEPTH</span>
                    <span class="dna-value" id="dnaDepth">—</span>
                </div>
            </div>
            <div class="dna-helix" id="dnaHelix"></div>
        </div>
        
        <!-- Wh-Logic Overlay -->
        <div class="wh-logic-panel" id="whLogicPanel">
            <div class="wh-title">WH-LOGIC GATES</div>
            <div class="wh-gates">
                <div class="wh-gate" data-wh="what"><span class="wh-symbol">?ምን</span> WHAT</div>
                <div class="wh-gate" data-wh="why"><span class="wh-symbol">?ለምን</span> WHY</div>
                <div class="wh-gate" data-wh="how"><span class="wh-symbol">?እንዴት</span> HOW</div>
                <div class="wh-gate" data-wh="when"><span class="wh-symbol">?መቼ</span> WHEN</div>
                <div class="wh-gate" data-wh="where"><span class="wh-symbol">?የት</span> WHERE</div>
                <div class="wh-gate" data-wh="who"><span class="wh-symbol">?ማን</span> WHO</div>
            </div>
            <div class="wh-active-query" id="whActiveQuery">SELECT A STRUCTURE</div>
        </div>
        
        <!-- Causal Chain Visualizer -->
        <div class="causal-chain-panel" id="causalPanel">
            <div class="causal-title">CAUSAL CHAIN</div>
            <div class="causal-flow" id="causalFlow">
                <div class="causal-node cause">CAUSE</div>
                <div class="causal-arrow">→</div>
                <div class="causal-node mechanism">MECHANISM</div>
                <div class="causal-arrow">→</div>
                <div class="causal-node effect">EFFECT</div>
            </div>
            <div class="causal-inversion" id="causalInversion">
                <span class="inversion-label">⟲ INVERSION</span>
                <span class="inversion-status">READY</span>
            </div>
        </div>
        
        <div class="nested-preview" id="nestedPreview">
            <div class="nested-preview-title">INTERNAL STRUCTURE</div>
            <canvas id="nestedCanvas" width="180" height="180"></canvas>
        </div>
        
        <div class="zoom-indicator" id="zoomIndicator">
            <div class="zoom-level" id="zoomLevel">DEPTH 0</div>
            <div class="zoom-path" id="zoomPath"><span>MULLU</span> → Perception → Symbol</div>
        </div>
        
        <div class="hint">[ CLICK = EXPAND · S = STRUCTURES · W = WH-LOGIC · C = CAUSAL · Z/X = ZOOM · SPACE = STORM ]</div>
    </div>

    <script>
        // ============ SETUP ============
        const bgCanvas = document.getElementById('bgCanvas');
        const mainCanvas = document.getElementById('mainCanvas');
        const fxCanvas = document.getElementById('fxCanvas');
        const topCanvas = document.getElementById('topCanvas');
        
        const bgCtx = bgCanvas.getContext('2d');
        const ctx = mainCanvas.getContext('2d');
        const fxCtx = fxCanvas.getContext('2d');
        const topCtx = topCanvas.getContext('2d');
        
        let W = window.innerWidth;
        let H = window.innerHeight;
        let cx = W / 2;
        let cy = H / 2;
        let t = 0;
        let mouseX = cx;
        let mouseY = cy;
        let lastTime = performance.now();
        
        // Data structures
        let nodes = [];
        let connections = [];
        let particles = [];
        let energyWaves = [];
        let dataStreams = [];
        let explosions = [];
        let lightnings = [];
        let auroraWaves = [];
        let showAllStructures = false;
        let selectedNode = null;
        let holdTimer = null;
        let showWhLogic = false;
        let showCausalChain = false;
        let activeWhGate = null;
        let causalFlowPhase = 0;
        let currentDepth = 0;
        let structureZoomLevel = 0;
        
        // Nested canvas for internal structure preview
        const nestedCanvas = document.getElementById('nestedCanvas');
        const nestedCtx = nestedCanvas.getContext('2d');
        
        const colors = ['#00ffff', '#00ff88', '#ffff00', '#ff8800', '#ff00ff'];
        const geezChars = ['ሀ', 'ለ', 'ሐ', 'መ', 'ሠ', 'ረ', 'ሰ', 'ሸ', 'ቀ', 'በ', 'ተ', 'ኀ', 'ነ', 'አ', 'ከ', 'ወ', 'ዐ', 'ዘ', 'የ', 'ደ', 'ገ', 'ጠ', 'ጰ', 'ጸ', 'ፀ', 'ፈ', 'ፐ'];
        
        function resize() {
            W = bgCanvas.width = mainCanvas.width = fxCanvas.width = topCanvas.width = window.innerWidth;
            H = bgCanvas.height = mainCanvas.height = fxCanvas.height = topCanvas.height = window.innerHeight;
            cx = W / 2;
            cy = H / 2;
        }
        
        window.addEventListener('resize', resize);
        resize();
        
        // ============ NODE CLASS ============
        class Node {
            constructor(layer, index, total) {
                this.layer = layer;
                this.index = index;
                this.angle = (index / total) * Math.PI * 2 + Math.random() * 0.2;
                this.baseRadius = 100 + layer * 65;
                this.radius = this.baseRadius;
                this.orbitSpeed = (0.15 - layer * 0.025) * (layer % 2 === 0 ? 1 : -1);
                this.size = 12 - layer * 1.5;
                this.color = colors[layer];
                this.char = geezChars[Math.floor(Math.random() * geezChars.length)];
                this.pulse = Math.random() * Math.PI * 2;
                this.energy = 1;
                this.targetEnergy = 1;
                
                // Initialize position
                this.x = cx + Math.cos(this.angle) * this.radius;
                this.y = cy + Math.sin(this.angle) * this.radius * 0.55;
                this.z = Math.sin(this.angle);
                
                // STRUCTURE OF STRUCTURES - Internal sub-nodes
                this.subNodes = [];
                this.subConnections = [];
                this.expanded = false;
                this.expandProgress = 0;
                this.structureName = this.generateStructureName();
                
                // Create internal structure (3-6 sub-nodes per node)
                const subCount = 3 + Math.floor(Math.random() * 4);
                for (let i = 0; i < subCount; i++) {
                    this.subNodes.push({
                        angle: (i / subCount) * Math.PI * 2,
                        orbitRadius: 0.4 + Math.random() * 0.3,
                        speed: (Math.random() - 0.5) * 2,
                        size: 0.2 + Math.random() * 0.2,
                        char: geezChars[Math.floor(Math.random() * geezChars.length)],
                        color: colors[(layer + 1 + i) % colors.length],
                        pulse: Math.random() * Math.PI * 2
                    });
                }
                
                // Create sub-connections
                for (let i = 0; i < this.subNodes.length; i++) {
                    const next = (i + 1) % this.subNodes.length;
                    this.subConnections.push({from: i, to: next});
                    if (Math.random() < 0.3 && this.subNodes.length > 3) {
                        const random = Math.floor(Math.random() * this.subNodes.length);
                        if (random !== i && random !== next) {
                            this.subConnections.push({from: i, to: random});
                        }
                    }
                }
            }
            
            generateStructureName() {
                const prefixes = ['Symbol', 'Gate', 'Chain', 'Node', 'Link', 'Core', 'Meta', 'Flow'];
                const suffixes = ['α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ'];
                return prefixes[Math.floor(Math.random() * prefixes.length)] + '-' + 
                       suffixes[Math.floor(Math.random() * suffixes.length)] + 
                       this.layer + this.index;
            }
            
            update(dt) {
                this.angle += this.orbitSpeed * dt;
                this.pulse += 3 * dt;
                
                // Mouse influence
                const dx = mouseX - cx;
                const dy = mouseY - cy;
                const mouseDist = Math.sqrt(dx * dx + dy * dy);
                const mouseInfluence = Math.max(0, 1 - mouseDist / 300) * 30;
                
                // Wobble and breathing
                const wobble = Math.sin(t * 1.5 + this.angle * 2 + this.layer) * 15;
                const breathe = Math.sin(t * 0.5) * 10;
                
                this.radius = this.baseRadius + wobble + breathe + mouseInfluence;
                
                this.x = cx + Math.cos(this.angle) * this.radius;
                this.y = cy + Math.sin(this.angle) * this.radius * 0.55;
                this.z = Math.sin(this.angle);
                
                // Energy decay
                this.energy += (this.targetEnergy - this.energy) * 0.1;
                if (this.targetEnergy > 1) this.targetEnergy -= dt * 2;
                
                // Expansion animation
                if (this.expanded && this.expandProgress < 1) {
                    this.expandProgress = Math.min(1, this.expandProgress + dt * 3);
                } else if (!this.expanded && this.expandProgress > 0) {
                    this.expandProgress = Math.max(0, this.expandProgress - dt * 3);
                }
                
                // Update sub-nodes
                this.subNodes.forEach(sub => {
                    sub.angle += sub.speed * dt;
                    sub.pulse += 4 * dt;
                });
            }
            
            draw() {
                if (!isFinite(this.x) || !isFinite(this.y)) return;
                
                const depth = (this.z + 1) / 2;
                const scale = depth * 0.4 + 0.6;
                const alpha = depth * 0.5 + 0.5;
                const pulseScale = Math.sin(this.pulse) * 0.15 + 1;
                const energyScale = this.energy;
                const size = Math.max(1, this.size * scale * pulseScale * energyScale);
                
                // Outer glow (larger when energized)
                const glowSize = Math.max(1, size * (4 + this.energy * 3));
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                grad.addColorStop(0, this.color + Math.floor(alpha * 0.6 * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(0.3, this.color + Math.floor(alpha * 0.2 * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw internal structure when expanded or always show mini version
                if (this.expandProgress > 0 || showAllStructures) {
                    this.drawInternalStructure(size, alpha);
                } else {
                    // Show mini sub-nodes orbiting (hint of internal structure)
                    this.drawMiniStructure(size, alpha);
                }
                
                // Orbit ring hint
                if (this.energy > 1.2) {
                    ctx.strokeStyle = this.color + '20';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size * 2.5, 0, Math.PI * 2);
                    ctx.stroke();;
                }
                
                // Inner ring
                ctx.strokeStyle = this.color + Math.floor(alpha * 0.8 * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 1.8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Core
                const coreGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
                coreGrad.addColorStop(0, '#fff');
                coreGrad.addColorStop(0.3, this.color);
                coreGrad.addColorStop(1, this.color + '80');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Character
                ctx.fillStyle = '#000';
                ctx.font = `bold ${size * 1.1}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, this.x, this.y + 1);
            }
            
            energize() {
                this.targetEnergy = 2.5;
            }
            
            toggleExpand() {
                this.expanded = !this.expanded;
            }
            
            drawMiniStructure(size, alpha) {
                // Draw tiny orbiting dots to hint at internal structure
                const miniRadius = size * 1.5;
                this.subNodes.forEach((sub, i) => {
                    const subX = this.x + Math.cos(sub.angle) * miniRadius;
                    const subY = this.y + Math.sin(sub.angle) * miniRadius * 0.6;
                    const subSize = Math.max(1, size * sub.size * 0.4);
                    
                    ctx.fillStyle = sub.color + Math.floor(alpha * 0.4 * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(subX, subY, subSize, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            drawInternalStructure(size, alpha) {
                const expandScale = this.expandProgress;
                const structureRadius = size * (2 + expandScale * 4);
                
                // Draw structure ring
                ctx.strokeStyle = this.color + Math.floor(alpha * 0.3 * expandScale * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, structureRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw sub-connections
                this.subConnections.forEach(conn => {
                    const from = this.subNodes[conn.from];
                    const to = this.subNodes[conn.to];
                    
                    const fx = this.x + Math.cos(from.angle) * structureRadius * from.orbitRadius;
                    const fy = this.y + Math.sin(from.angle) * structureRadius * from.orbitRadius * 0.6;
                    const tx = this.x + Math.cos(to.angle) * structureRadius * to.orbitRadius;
                    const ty = this.y + Math.sin(to.angle) * structureRadius * to.orbitRadius * 0.6;
                    
                    ctx.strokeStyle = this.color + Math.floor(alpha * 0.2 * expandScale * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                });
                
                // Draw sub-nodes
                this.subNodes.forEach((sub, i) => {
                    const subX = this.x + Math.cos(sub.angle) * structureRadius * sub.orbitRadius;
                    const subY = this.y + Math.sin(sub.angle) * structureRadius * sub.orbitRadius * 0.6;
                    const subPulse = Math.sin(sub.pulse) * 0.2 + 1;
                    const subSize = Math.max(1, size * sub.size * expandScale * subPulse);
                    
                    // Sub-node glow
                    const subGrad = ctx.createRadialGradient(subX, subY, 0, subX, subY, subSize * 3);
                    subGrad.addColorStop(0, sub.color + Math.floor(alpha * 0.5 * expandScale * 255).toString(16).padStart(2, '0'));
                    subGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = subGrad;
                    ctx.beginPath();
                    ctx.arc(subX, subY, subSize * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sub-node core
                    ctx.fillStyle = sub.color;
                    ctx.globalAlpha = alpha * expandScale;
                    ctx.beginPath();
                    ctx.arc(subX, subY, subSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sub-node character (only when fully expanded)
                    if (expandScale > 0.7) {
                        ctx.fillStyle = '#000';
                        ctx.font = `${Math.max(6, subSize * 0.9)}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(sub.char, subX, subY);
                    }
                    
                    ctx.globalAlpha = 1;
                });
                
                // Draw structure label when expanded
                if (expandScale > 0.5) {
                    ctx.fillStyle = this.color + Math.floor(alpha * expandScale * 200).toString(16).padStart(2, '0');
                    ctx.font = '9px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.structureName, this.x, this.y + structureRadius + 12);
                }
            }
        }
        
        // ============ CONNECTION CLASS ============
        class Connection {
            constructor(a, b) {
                this.a = a;
                this.b = b;
                this.strength = Math.random() * 0.5 + 0.5;
                this.flowPhase = Math.random() * Math.PI * 2;
                this.flowSpeed = Math.random() * 2 + 1;
                this.flowParticles = [];
            }
            
            update(dt) {
                this.flowPhase += this.flowSpeed * dt;
                
                // Spawn flow particles
                if (Math.random() < 0.03 * this.strength) {
                    this.flowParticles.push({
                        pos: 0,
                        speed: 0.3 + Math.random() * 0.4,
                        size: Math.random() * 2 + 1
                    });
                }
                
                this.flowParticles = this.flowParticles.filter(p => {
                    p.pos += p.speed * dt;
                    return p.pos < 1;
                });
            }
            
            draw() {
                if (!isFinite(this.a.x) || !isFinite(this.b.x)) return;
                
                const dx = this.b.x - this.a.x;
                const dy = this.b.y - this.a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 400 || dist < 1) return;
                
                const avgZ = (this.a.z + this.b.z) / 2;
                const depthAlpha = (avgZ + 1) / 2 * 0.5 + 0.3;
                const alpha = (1 - dist / 400) * this.strength * depthAlpha * 0.5;
                
                // Curved line
                const midX = (this.a.x + this.b.x) / 2;
                const midY = (this.a.y + this.b.y) / 2;
                const curve = Math.sin(this.flowPhase * 0.5) * 25;
                const perpX = (-dy / dist) * curve;
                const perpY = (dx / dist) * curve;
                
                const grad = ctx.createLinearGradient(this.a.x, this.a.y, this.b.x, this.b.y);
                grad.addColorStop(0, this.a.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(0.5, '#ffffff' + Math.floor(alpha * 0.5 * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(1, this.b.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
                
                ctx.strokeStyle = grad;
                ctx.lineWidth = this.strength * 2 * depthAlpha;
                ctx.beginPath();
                ctx.moveTo(this.a.x, this.a.y);
                ctx.quadraticCurveTo(midX + perpX, midY + perpY, this.b.x, this.b.y);
                ctx.stroke();
                
                // Flow particles
                this.flowParticles.forEach(p => {
                    const t = p.pos;
                    const tt = 1 - t;
                    // Quadratic bezier position
                    const px = tt * tt * this.a.x + 2 * tt * t * (midX + perpX) + t * t * this.b.x;
                    const py = tt * tt * this.a.y + 2 * tt * t * (midY + perpY) + t * t * this.b.y;
                    
                    if (!isFinite(px) || !isFinite(py)) return;
                    
                    const particleAlpha = Math.sin(p.pos * Math.PI) * alpha * 3;
                    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, particleAlpha)})`;
                    ctx.beginPath();
                    ctx.arc(px, py, Math.max(0.5, p.size), 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        
        // ============ PARTICLE CLASS ============
        class Particle {
            constructor(x, y, color, velocity = null) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = velocity ? velocity.x : (Math.random() - 0.5) * 3;
                this.vy = velocity ? velocity.y : (Math.random() - 0.5) * 3;
                this.life = 1;
                this.decay = 0.01 + Math.random() * 0.02;
                this.size = Math.random() * 3 + 1;
                this.trail = [];
            }
            
            update(dt) {
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 15) this.trail.shift();
                
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
            }
            
            draw() {
                if (this.life <= 0) return;
                
                if (this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = Math.max(0.5, this.size * this.life);
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = this.life * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                const radius = Math.max(0.5, this.size * this.life * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            isDead() { return this.life <= 0; }
        }
        
        // ============ ENERGY WAVE CLASS ============
        class EnergyWave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = 0;
                this.maxRadius = 300;
                this.speed = 200;
                this.life = 1;
            }
            
            update(dt) {
                this.radius += this.speed * dt;
                this.life = 1 - (this.radius / this.maxRadius);
            }
            
            draw() {
                if (!isFinite(this.x) || !isFinite(this.y) || this.life <= 0 || this.radius <= 0) return;
                
                fxCtx.strokeStyle = this.color + Math.floor(this.life * 150).toString(16).padStart(2, '0');
                fxCtx.lineWidth = Math.max(0.5, 3 * this.life);
                fxCtx.beginPath();
                fxCtx.arc(this.x, this.y, Math.max(1, this.radius), 0, Math.PI * 2);
                fxCtx.stroke();
                
                // Inner ring
                const innerRadius = Math.max(1, this.radius * 0.8);
                fxCtx.strokeStyle = this.color + Math.floor(this.life * 80).toString(16).padStart(2, '0');
                fxCtx.lineWidth = 1;
                fxCtx.beginPath();
                fxCtx.arc(this.x, this.y, innerRadius, 0, Math.PI * 2);
                fxCtx.stroke();
            }
            
            isDead() { return this.radius >= this.maxRadius; }
        }
        
        // ============ DATA STREAM CLASS ============
        class DataStream {
            constructor() {
                this.reset();
            }
            
            reset() {
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: this.x = Math.random() * W; this.y = -20; this.vx = 0; this.vy = 2; break;
                    case 1: this.x = W + 20; this.y = Math.random() * H; this.vx = -2; this.vy = 0; break;
                    case 2: this.x = Math.random() * W; this.y = H + 20; this.vx = 0; this.vy = -2; break;
                    case 3: this.x = -20; this.y = Math.random() * H; this.vx = 2; this.vy = 0; break;
                }
                this.targetX = cx + (Math.random() - 0.5) * 200;
                this.targetY = cy + (Math.random() - 0.5) * 200;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.char = geezChars[Math.floor(Math.random() * geezChars.length)];
                this.trail = [];
                this.arrived = false;
            }
            
            update(dt) {
                this.trail.push({x: this.x, y: this.y, char: this.char});
                if (this.trail.length > 20) this.trail.shift();
                
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 50) {
                    this.arrived = true;
                    return;
                }
                
                // Curve toward center
                this.vx += dx * 0.001;
                this.vy += dy * 0.001;
                
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 5) {
                    this.vx = (this.vx / speed) * 5;
                    this.vy = (this.vy / speed) * 5;
                }
                
                this.x += this.vx;
                this.y += this.vy;
            }
            
            draw() {
                // Trail
                this.trail.forEach((p, i) => {
                    const alpha = (i / this.trail.length) * 0.5;
                    topCtx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    topCtx.font = '10px monospace';
                    topCtx.fillText(p.char, p.x, p.y);
                });
                
                // Head
                topCtx.fillStyle = this.color;
                topCtx.font = 'bold 14px monospace';
                topCtx.fillText(this.char, this.x, this.y);
            }
        }
        
        // ============ EXPLOSION CLASS ============
        class Explosion {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.particles = [];
                this.rings = [];
                
                // Create particles
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        size: Math.random() * 4 + 1
                    });
                }
                
                // Create rings
                for (let i = 0; i < 3; i++) {
                    this.rings.push({
                        radius: 0,
                        maxRadius: 80 + i * 40,
                        speed: 150 - i * 30
                    });
                }
            }
            
            update(dt) {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.life -= 0.02;
                });
                
                this.rings.forEach(r => {
                    r.radius += r.speed * dt;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                // Rings
                this.rings.forEach(r => {
                    const alpha = Math.max(0, 1 - r.radius / r.maxRadius);
                    if (alpha <= 0 || r.radius <= 0) return;
                    fxCtx.strokeStyle = this.color + Math.floor(alpha * 200).toString(16).padStart(2, '0');
                    fxCtx.lineWidth = Math.max(0.5, 2 * alpha);
                    fxCtx.beginPath();
                    fxCtx.arc(this.x, this.y, Math.max(1, r.radius), 0, Math.PI * 2);
                    fxCtx.stroke();
                });
                
                // Particles
                this.particles.forEach(p => {
                    if (p.life <= 0) return;
                    const radius = Math.max(0.5, p.size * p.life);
                    fxCtx.fillStyle = this.color + Math.floor(Math.max(0, p.life) * 255).toString(16).padStart(2, '0');
                    fxCtx.beginPath();
                    fxCtx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    fxCtx.fill();
                });
            }
            
            isDead() {
                return this.particles.length === 0 && this.rings.every(r => r.radius >= r.maxRadius);
            }
        }
        
        // ============ LIGHTNING EFFECT CLASS ============
        class Lightning {
            constructor(x1, y1, x2, y2, color) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.color = color;
                this.life = 1;
                this.segments = this.generateSegments();
            }
            
            generateSegments() {
                const segments = [];
                const dx = this.x2 - this.x1;
                const dy = this.y2 - this.y1;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 1) return [{x: this.x1, y: this.y1}, {x: this.x2, y: this.y2}];
                const steps = Math.max(2, Math.floor(dist / 20));
                
                let x = this.x1;
                let y = this.y1;
                segments.push({x, y});
                
                for (let i = 1; i < steps; i++) {
                    const progress = i / steps;
                    const baseX = this.x1 + dx * progress;
                    const baseY = this.y1 + dy * progress;
                    const offset = (Math.random() - 0.5) * 40 * (1 - Math.abs(progress - 0.5) * 2);
                    const perpX = -dy / dist * offset;
                    const perpY = dx / dist * offset;
                    x = baseX + perpX;
                    y = baseY + perpY;
                    segments.push({x, y});
                }
                
                segments.push({x: this.x2, y: this.y2});
                return segments;
            }
            
            update(dt) {
                this.life -= dt * 4;
            }
            
            draw() {
                if (this.life <= 0 || this.segments.length < 2) return;
                
                // Main bolt
                fxCtx.strokeStyle = this.color + Math.floor(Math.max(0, this.life) * 255).toString(16).padStart(2, '0');
                fxCtx.lineWidth = Math.max(1, 3 * this.life);
                fxCtx.lineCap = 'round';
                fxCtx.lineJoin = 'round';
                fxCtx.shadowColor = this.color;
                fxCtx.shadowBlur = 20 * this.life;
                
                fxCtx.beginPath();
                fxCtx.moveTo(this.segments[0].x, this.segments[0].y);
                for (let i = 1; i < this.segments.length; i++) {
                    fxCtx.lineTo(this.segments[i].x, this.segments[i].y);
                }
                fxCtx.stroke();
                
                // Glow layer
                fxCtx.strokeStyle = '#fff' + Math.floor(Math.max(0, this.life) * 100).toString(16).padStart(2, '0');
                fxCtx.lineWidth = 1;
                fxCtx.stroke();
                
                fxCtx.shadowBlur = 0;
            }
            
            isDead() { return this.life <= 0; }
        }
        
        // ============ AURORA WAVE ============
        class AuroraWave {
            constructor() {
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.y = H + 50;
                this.speed = 0.5 + Math.random();
                this.amplitude = 30 + Math.random() * 50;
                this.frequency = 0.005 + Math.random() * 0.01;
                this.phase = Math.random() * Math.PI * 2;
                this.life = 1;
                this.width = 100 + Math.random() * 200;
            }
            
            update(dt) {
                this.phase += this.speed * dt;
                this.y -= 30 * dt;
                this.life -= dt * 0.05;
            }
            
            draw() {
                if (this.life <= 0 || !isFinite(this.y)) return;
                
                const alpha = this.life * 0.1;
                
                bgCtx.beginPath();
                bgCtx.moveTo(0, this.y);
                
                for (let x = 0; x <= W; x += 10) {
                    const y = this.y + Math.sin(x * this.frequency + this.phase) * this.amplitude;
                    bgCtx.lineTo(x, y);
                }
                
                bgCtx.lineTo(W, this.y + this.width);
                bgCtx.lineTo(0, this.y + this.width);
                bgCtx.closePath();
                
                const grad = bgCtx.createLinearGradient(0, this.y, 0, this.y + this.width);
                grad.addColorStop(0, this.color + Math.floor(Math.max(0, alpha) * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(1, 'transparent');
                bgCtx.fillStyle = grad;
                bgCtx.fill();
            }
            
            isDead() { return this.life <= 0 || this.y < -this.width; }
        }
        
        // ============ STRUCTURE OF STRUCTURES ============
        // Each node contains an internal structure that can be revealed
        
        class InnerStructure {
            constructor(parentNode) {
                this.parent = parentNode;
                this.x = parentNode.x;
                this.y = parentNode.y;
                this.expanded = false;
                this.expandProgress = 0;
                this.targetExpand = 0;
                this.innerNodes = [];
                this.innerConnections = [];
                this.metaLevel = parentNode.layer;
                this.buildInnerStructure();
            }
            
            buildInnerStructure() {
                // Each node contains 4-6 inner symbolic elements
                const count = 4 + Math.floor(Math.random() * 3);
                const innerRadius = 25;
                
                const subSymbols = ['⬡', '◇', '△', '○', '□', '⬢', '✦', '⊕', '⊗', '⊙'];
                const properties = ['identity', 'behavior', 'boundary', 'relation', 'state', 'transform'];
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    this.innerNodes.push({
                        angle: angle,
                        radius: innerRadius,
                        symbol: subSymbols[Math.floor(Math.random() * subSymbols.length)],
                        property: properties[i % properties.length],
                        pulse: Math.random() * Math.PI * 2,
                        size: 4 + Math.random() * 2
                    });
                }
                
                // Create inner connections (mesh network)
                for (let i = 0; i < count; i++) {
                    for (let j = i + 1; j < count; j++) {
                        if (Math.random() < 0.6) {
                            this.innerConnections.push({from: i, to: j});
                        }
                    }
                }
            }
            
            toggle() {
                this.targetExpand = this.targetExpand > 0.5 ? 0 : 1;
            }
            
            update(dt) {
                this.x = this.parent.x;
                this.y = this.parent.y;
                
                // Smooth expand/collapse
                this.expandProgress += (this.targetExpand - this.expandProgress) * 5 * dt;
                this.expanded = this.expandProgress > 0.1;
                
                // Update inner nodes
                this.innerNodes.forEach(n => {
                    n.pulse += 0.03;
                });
            }
            
            draw() {
                if (this.expandProgress < 0.05) return;
                if (!isFinite(this.x) || !isFinite(this.y)) return;
                
                const scale = this.expandProgress;
                const alpha = this.expandProgress;
                
                // Expansion ring
                ctx.strokeStyle = this.parent.color + Math.floor(alpha * 100).toString(16).padStart(2, '0');
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, 35 * scale, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Inner connections first (behind nodes)
                this.innerConnections.forEach(c => {
                    const n1 = this.innerNodes[c.from];
                    const n2 = this.innerNodes[c.to];
                    
                    const x1 = this.x + Math.cos(n1.angle) * n1.radius * scale;
                    const y1 = this.y + Math.sin(n1.angle) * n1.radius * scale;
                    const x2 = this.x + Math.cos(n2.angle) * n2.radius * scale;
                    const y2 = this.y + Math.sin(n2.angle) * n2.radius * scale;
                    
                    ctx.strokeStyle = this.parent.color + Math.floor(alpha * 60).toString(16).padStart(2, '0');
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                });
                
                // Inner nodes
                this.innerNodes.forEach((n, i) => {
                    const x = this.x + Math.cos(n.angle) * n.radius * scale;
                    const y = this.y + Math.sin(n.angle) * n.radius * scale;
                    const pulseSize = n.size * (1 + Math.sin(n.pulse) * 0.2);
                    
                    // Glow
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, pulseSize * 3 * scale);
                    grad.addColorStop(0, this.parent.color + Math.floor(alpha * 150).toString(16).padStart(2, '0'));
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.max(1, pulseSize * 3 * scale), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Symbol
                    ctx.fillStyle = '#fff';
                    ctx.globalAlpha = alpha;
                    ctx.font = `${Math.max(6, 10 * scale)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(n.symbol, x, y);
                    ctx.globalAlpha = 1;
                    
                    // Property label (only when fully expanded)
                    if (scale > 0.8) {
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.font = '6px monospace';
                        ctx.fillText(n.property, x, y + 12);
                    }
                });
                
                // Connection to parent center
                this.innerNodes.forEach(n => {
                    const x = this.x + Math.cos(n.angle) * n.radius * scale;
                    const y = this.y + Math.sin(n.angle) * n.radius * scale;
                    
                    ctx.strokeStyle = this.parent.color + Math.floor(alpha * 30).toString(16).padStart(2, '0');
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                });
            }
        }
        
        // ============ META STRUCTURE OVERLAY ============
        class MetaStructure {
            constructor() {
                this.levels = [
                    { name: 'PERCEPTION', y: 0, color: '#00ffff' },
                    { name: 'SYMBOL', y: 1, color: '#00ff88' },
                    { name: 'RELATION', y: 2, color: '#ffff00' },
                    { name: 'INFERENCE', y: 3, color: '#ff8800' },
                    { name: 'META', y: 4, color: '#ff00ff' }
                ];
                this.visible = false;
                this.opacity = 0;
            }
            
            toggle() {
                this.visible = !this.visible;
            }
            
            update(dt) {
                const targetOpacity = this.visible ? 1 : 0;
                this.opacity += (targetOpacity - this.opacity) * 3 * dt;
            }
            
            draw() {
                if (this.opacity < 0.01) return;
                
                const margin = 120;
                const layerHeight = (H - margin * 2) / this.levels.length;
                
                // Draw level bands
                this.levels.forEach((level, i) => {
                    const y = margin + i * layerHeight;
                    
                    // Band background
                    const grad = ctx.createLinearGradient(0, y, 0, y + layerHeight);
                    grad.addColorStop(0, level.color + Math.floor(this.opacity * 15).toString(16).padStart(2, '0'));
                    grad.addColorStop(0.5, level.color + Math.floor(this.opacity * 8).toString(16).padStart(2, '0'));
                    grad.addColorStop(1, level.color + Math.floor(this.opacity * 15).toString(16).padStart(2, '0'));
                    
                    ctx.fillStyle = grad;
                    ctx.fillRect(margin, y, W - margin * 2, layerHeight);
                    
                    // Level line
                    ctx.strokeStyle = level.color + Math.floor(this.opacity * 50).toString(16).padStart(2, '0');
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(margin, y);
                    ctx.lineTo(W - margin, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Level label
                    ctx.fillStyle = level.color + Math.floor(this.opacity * 200).toString(16).padStart(2, '0');
                    ctx.font = '10px Orbitron, monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText(level.name, margin + 10, y + 15);
                    
                    // Structure indicator
                    ctx.font = '8px monospace';
                    ctx.fillStyle = 'rgba(255,255,255,' + (this.opacity * 0.3) + ')';
                    ctx.fillText(`LAYER ${i} — ${3 + i * 2} STRUCTURES`, margin + 10, y + 28);
                });
                
                // Draw hierarchical arrows
                for (let i = 0; i < this.levels.length - 1; i++) {
                    const y1 = margin + (i + 0.5) * layerHeight;
                    const y2 = margin + (i + 1.5) * layerHeight;
                    
                    ctx.strokeStyle = 'rgba(255,255,255,' + (this.opacity * 0.2) + ')';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(W - margin - 30, y1);
                    ctx.lineTo(W - margin - 30, y2 - 10);
                    ctx.lineTo(W - margin - 35, y2 - 15);
                    ctx.moveTo(W - margin - 30, y2 - 10);
                    ctx.lineTo(W - margin - 25, y2 - 15);
                    ctx.stroke();
                }
                
                // Title
                ctx.fillStyle = 'rgba(255,255,255,' + (this.opacity * 0.5) + ')';
                ctx.font = '12px Orbitron, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('STRUCTURE OF STRUCTURES', cx, margin - 20);
                ctx.font = '8px monospace';
                ctx.fillStyle = 'rgba(255,255,255,' + (this.opacity * 0.3) + ')';
                ctx.fillText('NESTED HIERARCHICAL ARCHITECTURE', cx, margin - 8);
            }
        }
        
        let innerStructures = [];
        let metaStructure = new MetaStructure();
        
        // ============ INITIALIZATION ============
        function init() {
            nodes = [];
            connections = [];
            innerStructures = [];
            
            // Create nodes in layers
            for (let layer = 0; layer < 5; layer++) {
                const count = 8 + layer * 3;
                for (let i = 0; i < count; i++) {
                    nodes.push(new Node(layer, i, count));
                }
            }
            
            // Create inner structure for each node
            nodes.forEach(node => {
                innerStructures.push(new InnerStructure(node));
            });
            
            // Create connections
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if (i >= j) return;
                    const layerDiff = Math.abs(n1.layer - n2.layer);
                    if (layerDiff <= 1 && Math.random() < 0.12) {
                        connections.push(new Connection(n1, n2));
                    }
                });
            });
            
            // Initialize data streams
            for (let i = 0; i < 15; i++) {
                dataStreams.push(new DataStream());
            }
            
            // Initialize waveforms
            initWaveforms();
        }
        
        function initWaveforms() {
            ['wave1', 'wave2', 'wave3'].forEach(id => {
                const container = document.getElementById(id);
                container.innerHTML = '';
                for (let i = 0; i < 40; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    bar.style.height = '5px';
                    container.appendChild(bar);
                }
            });
        }
        
        // ============ BACKGROUND ============
        // ═══════════════════════════════════════════════════════════════
        // ENHANCED VISUAL SYSTEM - Nebula, Stars, Atmosphere
        // ═══════════════════════════════════════════════════════════════
        
        // Star field layers (parallax)
        const starLayers = [];
        for (let layer = 0; layer < 3; layer++) {
            const stars = [];
            const count = 80 + layer * 40;
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * 2000,
                    y: Math.random() * 2000,
                    size: Math.random() * (1.5 - layer * 0.3) + 0.5,
                    brightness: Math.random() * 0.5 + 0.2,
                    twinkleSpeed: Math.random() * 3 + 1,
                    twinkleOffset: Math.random() * Math.PI * 2
                });
            }
            starLayers.push({ stars, speed: 0.1 + layer * 0.15, depth: layer });
        }
        
        // Nebula clouds
        const nebulaClouds = [];
        for (let i = 0; i < 6; i++) {
            nebulaClouds.push({
                x: Math.random() * 2000,
                y: Math.random() * 2000,
                radius: 150 + Math.random() * 300,
                color: ['#00ffff', '#ff00ff', '#ff8800', '#00ff88', '#8800ff', '#ff0066'][i],
                opacity: 0.03 + Math.random() * 0.04,
                speed: 0.02 + Math.random() * 0.03,
                angle: Math.random() * Math.PI * 2,
                pulse: Math.random() * Math.PI * 2
            });
        }
        
        // Global breathing state
        let globalBreath = 0;
        let breathDirection = 1;
        
        function drawBackground() {
            // Update global breathing
            globalBreath += 0.003 * breathDirection;
            if (globalBreath > 1) breathDirection = -1;
            if (globalBreath < 0) breathDirection = 1;
            const breathScale = 1 + Math.sin(globalBreath * Math.PI) * 0.02;
            const breathIntensity = 0.8 + Math.sin(globalBreath * Math.PI) * 0.2;
            
            // Deep space base
            const spaceGrad = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H));
            spaceGrad.addColorStop(0, '#0a0a18');
            spaceGrad.addColorStop(0.4, '#050510');
            spaceGrad.addColorStop(1, '#000005');
            bgCtx.fillStyle = spaceGrad;
            bgCtx.fillRect(0, 0, W, H);
            
            // ═══ NEBULA CLOUDS ═══
            nebulaClouds.forEach(cloud => {
                cloud.angle += cloud.speed * 0.01;
                cloud.x += Math.cos(cloud.angle) * cloud.speed;
                cloud.y += Math.sin(cloud.angle) * cloud.speed * 0.5;
                cloud.pulse += 0.02;
                
                // Wrap around
                if (cloud.x < -cloud.radius) cloud.x = W + cloud.radius;
                if (cloud.x > W + cloud.radius) cloud.x = -cloud.radius;
                if (cloud.y < -cloud.radius) cloud.y = H + cloud.radius;
                if (cloud.y > H + cloud.radius) cloud.y = -cloud.radius;
                
                const pulseOpacity = cloud.opacity * (0.7 + Math.sin(cloud.pulse) * 0.3) * breathIntensity;
                const grad = bgCtx.createRadialGradient(
                    cloud.x, cloud.y, 0,
                    cloud.x, cloud.y, cloud.radius * breathScale
                );
                grad.addColorStop(0, cloud.color + Math.floor(pulseOpacity * 255).toString(16).padStart(2, '0'));
                grad.addColorStop(0.3, cloud.color + Math.floor(pulseOpacity * 150).toString(16).padStart(2, '0'));
                grad.addColorStop(0.6, cloud.color + Math.floor(pulseOpacity * 50).toString(16).padStart(2, '0'));
                grad.addColorStop(1, 'transparent');
                
                bgCtx.fillStyle = grad;
                bgCtx.beginPath();
                bgCtx.arc(cloud.x, cloud.y, cloud.radius * breathScale, 0, Math.PI * 2);
                bgCtx.fill();
            });
            
            // ═══ STAR PARALLAX LAYERS ═══
            starLayers.forEach(layer => {
                const parallaxX = (mouseX - cx) * layer.speed * 0.05;
                const parallaxY = (mouseY - cy) * layer.speed * 0.05;
                
                layer.stars.forEach(star => {
                    const x = ((star.x + parallaxX + t * layer.speed * 10) % W + W) % W;
                    const y = ((star.y + parallaxY + t * layer.speed * 5) % H + H) % H;
                    
                    // Twinkle effect
                    const twinkle = Math.sin(t * star.twinkleSpeed + star.twinkleOffset) * 0.5 + 0.5;
                    const alpha = star.brightness * twinkle * breathIntensity;
                    
                    bgCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    bgCtx.beginPath();
                    bgCtx.arc(x, y, star.size, 0, Math.PI * 2);
                    bgCtx.fill();
                    
                    // Star glow for brighter stars
                    if (star.brightness > 0.5 && twinkle > 0.7) {
                        bgCtx.fillStyle = `rgba(200, 220, 255, ${alpha * 0.3})`;
                        bgCtx.beginPath();
                        bgCtx.arc(x, y, star.size * 3, 0, Math.PI * 2);
                        bgCtx.fill();
                    }
                });
            });
            
            // ═══ PERSPECTIVE GRID ═══
            const gridSize = 50;
            const gridOffset = (t * 20) % gridSize;
            const gridFade = 0.04 * breathIntensity;
            
            bgCtx.strokeStyle = `rgba(0, 255, 255, ${gridFade})`;
            bgCtx.lineWidth = 1;
            
            // Vertical lines with perspective
            for (let x = gridOffset; x < W; x += gridSize) {
                const distFromCenter = Math.abs(x - cx) / cx;
                const perspectiveAlpha = gridFade * (1 - distFromCenter * 0.5);
                bgCtx.strokeStyle = `rgba(0, 255, 255, ${perspectiveAlpha})`;
                bgCtx.beginPath();
                bgCtx.moveTo(x, 0);
                bgCtx.lineTo(x, H);
                bgCtx.stroke();
            }
            
            // Horizontal lines
            for (let y = gridOffset; y < H; y += gridSize) {
                const distFromCenter = Math.abs(y - cy) / cy;
                const perspectiveAlpha = gridFade * (1 - distFromCenter * 0.5);
                bgCtx.strokeStyle = `rgba(0, 255, 255, ${perspectiveAlpha})`;
                bgCtx.beginPath();
                bgCtx.moveTo(0, y);
                bgCtx.lineTo(W, y);
                bgCtx.stroke();
            }
            
            // ═══ LIGHT RAYS FROM CENTER ═══
            if (isFinite(cx) && isFinite(cy)) {
                const rayCount = 12;
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2 + t * 0.1;
                    const rayLength = Math.max(W, H) * 0.8;
                    const rayWidth = 0.15 + Math.sin(t * 2 + i) * 0.05;
                    
                    const grad = bgCtx.createLinearGradient(
                        cx, cy,
                        cx + Math.cos(angle) * rayLength,
                        cy + Math.sin(angle) * rayLength
                    );
                    grad.addColorStop(0, `rgba(255, 255, 255, ${0.03 * breathIntensity})`);
                    grad.addColorStop(0.3, `rgba(0, 255, 255, ${0.015 * breathIntensity})`);
                    grad.addColorStop(1, 'transparent');
                    
                    bgCtx.fillStyle = grad;
                    bgCtx.beginPath();
                    bgCtx.moveTo(cx, cy);
                    bgCtx.lineTo(
                        cx + Math.cos(angle - rayWidth) * rayLength,
                        cy + Math.sin(angle - rayWidth) * rayLength
                    );
                    bgCtx.lineTo(
                        cx + Math.cos(angle + rayWidth) * rayLength,
                        cy + Math.sin(angle + rayWidth) * rayLength
                    );
                    bgCtx.closePath();
                    bgCtx.fill();
                }
            }
            
            // ═══ ENHANCED VIGNETTE ═══
            if (isFinite(cx) && isFinite(cy)) {
                const vignetteGrad = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.75);
                vignetteGrad.addColorStop(0, 'rgba(0, 10, 20, 0)');
                vignetteGrad.addColorStop(0.5, 'rgba(0, 5, 15, 0.2)');
                vignetteGrad.addColorStop(0.75, 'rgba(0, 0, 10, 0.5)');
                vignetteGrad.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                bgCtx.fillStyle = vignetteGrad;
                bgCtx.fillRect(0, 0, W, H);
            }
            
            // ═══ ATMOSPHERIC DUST PARTICLES ═══
            bgCtx.fillStyle = `rgba(0, 255, 255, ${0.08 * breathIntensity})`;
            for (let i = 0; i < 60; i++) {
                const dustX = (Math.sin(t * 0.08 + i * 0.6) * 0.5 + 0.5) * W;
                const dustY = (Math.cos(t * 0.12 + i * 0.8) * 0.5 + 0.5) * H;
                const dustSize = Math.max(0.5, Math.sin(t * 1.5 + i) * 1.5 + 2);
                bgCtx.beginPath();
                bgCtx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }
        
        // ============ UPDATE UI ============
        function updateUI() {
            document.getElementById('stat1').textContent = nodes.length;
            document.getElementById('stat2').textContent = connections.length;
            document.getElementById('stat4').textContent = (0.85 + Math.sin(t * 0.5) * 0.12).toFixed(2);
            
            // Pipeline animation
            const step = Math.floor((t * 0.7) % 8);
            for (let i = 1; i <= 8; i++) {
                const el = document.getElementById(`flow${i}`);
                el.classList.remove('active', 'complete');
                if (i < step + 1) el.classList.add('complete');
                if (i === step + 1) el.classList.add('active');
            }
            
            // Waveforms
            ['wave1', 'wave2', 'wave3'].forEach((id, waveIdx) => {
                const bars = document.getElementById(id).children;
                for (let i = 0; i < bars.length; i++) {
                    const h = Math.abs(Math.sin(t * (3 + waveIdx) + i * 0.15 + waveIdx * 2)) * 35 + 5;
                    bars[i].style.height = h + 'px';
                }
            });
        }
        
        // ============ MAIN LOOP ============
        function animate(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            t += dt;
            
            // Clear canvases
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, W, H);
            fxCtx.clearRect(0, 0, W, H);
            topCtx.clearRect(0, 0, W, H);
            
            // Draw background
            drawBackground();
            
            // Update and draw connections (back layer)
            connections.forEach(c => {
                c.update(dt);
                c.draw();
            });
            
            // Update and draw nodes
            nodes.sort((a, b) => a.z - b.z);
            nodes.forEach(n => {
                n.update(dt);
                n.draw();
            });
            
            // Update and draw inner structures (Structure of Structures)
            innerStructures.forEach(s => {
                s.update(dt);
                s.draw();
            });
            
            // Update and draw meta structure overlay
            metaStructure.update(dt);
            metaStructure.draw();
            
            // Update and draw particles
            particles = particles.filter(p => {
                p.update(dt);
                p.draw();
                return !p.isDead();
            });
            
            // Update and draw energy waves
            energyWaves = energyWaves.filter(w => {
                w.update(dt);
                w.draw();
                return !w.isDead();
            });
            
            // Update and draw explosions
            explosions = explosions.filter(e => {
                e.update(dt);
                e.draw();
                return !e.isDead();
            });
            
            // Update and draw lightnings
            lightnings = lightnings.filter(l => {
                l.update(dt);
                l.draw();
                return !l.isDead();
            });
            
            // Update and draw aurora waves
            auroraWaves = auroraWaves.filter(a => {
                a.update(dt);
                a.draw();
                return !a.isDead();
            });
            
            // Update data streams
            dataStreams.forEach(s => {
                s.update(dt);
                s.draw();
                if (s.arrived) s.reset();
            });
            
            // Spawn ambient particles
            if (Math.random() < 0.05) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 200 + Math.random() * 200;
                particles.push(new Particle(
                    cx + Math.cos(angle) * dist,
                    cy + Math.sin(angle) * dist,
                    colors[Math.floor(Math.random() * colors.length)]
                ));
            }
            
            // Spawn ambient energy waves
            if (Math.random() < 0.01) {
                const node = nodes[Math.floor(Math.random() * nodes.length)];
                if (node && isFinite(node.x)) {
                    energyWaves.push(new EnergyWave(node.x, node.y, node.color));
                    node.energize();
                }
            }
            
            // Spawn ambient lightning between random nodes
            if (Math.random() < 0.008 && nodes.length > 1) {
                const n1 = nodes[Math.floor(Math.random() * nodes.length)];
                const n2 = nodes[Math.floor(Math.random() * nodes.length)];
                if (n1 && n2 && n1 !== n2 && isFinite(n1.x) && isFinite(n2.x)) {
                    lightnings.push(new Lightning(n1.x, n1.y, n2.x, n2.y, n1.color));
                    n1.energize();
                    n2.energize();
                }
            }
            
            // Spawn aurora waves
            if (Math.random() < 0.005) {
                auroraWaves.push(new AuroraWave());
            }
            
            // STRUCTURE OF STRUCTURES - Draw fractal rings when active
            if (showAllStructures && isFinite(cx) && isFinite(cy)) {
                drawStructureOfStructures();
            }
            
            // Draw causal chain overlay when active
            if (showCausalChain) {
                drawCausalOverlay();
            }
            
            // Draw Wh-Logic connections when active
            if (showWhLogic && selectedNode) {
                drawWhLogicOverlay();
            }
            
            // ═══ ENHANCED CENTER GLOW ═══
            if (isFinite(cx) && isFinite(cy)) {
                const pulse = Math.sin(t * 2) * 0.2 + 1;
                const breathPulse = Math.sin(t * 0.5) * 0.3 + 1;
                
                // Outer halo
                const haloGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 200 * breathPulse);
                haloGrad.addColorStop(0, 'rgba(0,255,255,0.02)');
                haloGrad.addColorStop(0.5, 'rgba(255,0,255,0.01)');
                haloGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = haloGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, 200 * breathPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Middle glow ring
                const ringGrad = ctx.createRadialGradient(cx, cy, 50 * pulse, cx, cy, 120 * pulse);
                ringGrad.addColorStop(0, 'transparent');
                ringGrad.addColorStop(0.3, 'rgba(0,255,255,0.04)');
                ringGrad.addColorStop(0.6, 'rgba(255,255,255,0.02)');
                ringGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = ringGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, 120 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Core glow
                const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80 * pulse);
                coreGrad.addColorStop(0, 'rgba(255,255,255,0.2)');
                coreGrad.addColorStop(0.2, 'rgba(0,255,255,0.12)');
                coreGrad.addColorStop(0.5, 'rgba(255,0,255,0.05)');
                coreGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, 80 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Center point
                ctx.fillStyle = `rgba(255,255,255,${0.3 + Math.sin(t * 4) * 0.2})`;
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw nested preview canvas if structures visible
            drawNestedPreview();
            
            updateUI();
            // Use window.animate if set (allows enhancements), else self
            requestAnimationFrame(window.animateLoop || animate);
        }
        
        // ============ INTERACTION ============
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        // Hold-to-dive functionality
        let holdStartTime = 0;
        let holdNode = null;
        
        document.addEventListener('mousedown', (e) => {
            const clickX = e.clientX;
            const clickY = e.clientY;
            
            // Find nearby node
            nodes.forEach(n => {
                const d = Math.sqrt((n.x - clickX) ** 2 + (n.y - clickY) ** 2);
                if (d < 50) {
                    holdNode = n;
                    holdStartTime = Date.now();
                }
            });
            
            // Start hold timer
            if (holdNode) {
                holdTimer = setTimeout(() => {
                    // Held for 500ms - dive into structure
                    zoomIntoStructure(holdNode);
                    holdNode = null;
                }, 500);
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            holdNode = null;
        });
        
        document.addEventListener('click', (e) => {
            const clickX = e.clientX;
            const clickY = e.clientY;
            
            // Find nearby node
            let closest = null;
            let closestDist = Infinity;
            
            nodes.forEach(n => {
                const d = Math.sqrt((n.x - clickX) ** 2 + (n.y - clickY) ** 2);
                if (d < closestDist && d < 100) {
                    closest = n;
                    closestDist = d;
                }
            });
            
            if (closest) {
                // Select this node
                selectedNode = closest;
                
                // Toggle node's internal structure (Structure of Structures concept)
                closest.toggleExpand();
                
                // Update structure tree visualization
                updateStructureTree();
                updateStructurePanel();
                updateStructureDNA(closest);
                if (showWhLogic) updateWhLogicDisplay();
                
                // Show zoom indicator
                showZoomIndicator(
                    closest.expanded ? 'DIVING IN' : 'COLLAPSING',
                    `Layer ${closest.layer} → ${closest.structureName}`
                );
                
                // Toggle inner structure (Structure of Structures)
                const innerStruct = innerStructures[nodes.indexOf(closest)];
                if (innerStruct) {
                    // Collapse any other expanded structures
                    innerStructures.forEach(s => {
                        if (s !== innerStruct && s.expanded) {
                            s.targetExpand = 0;
                        }
                    });
                    innerStruct.toggle();
                }
                
                // Energize the node and create explosion
                closest.energize();
                explosions.push(new Explosion(closest.x, closest.y, closest.color));
                
                // Create particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(closest.x, closest.y, closest.color));
                }
                
                // Propagate energy to connected nodes with LIGHTNING
                connections.forEach(c => {
                    if (c.a === closest) {
                        c.b.energize();
                        energyWaves.push(new EnergyWave(c.b.x, c.b.y, c.b.color));
                        lightnings.push(new Lightning(closest.x, closest.y, c.b.x, c.b.y, closest.color));
                    } else if (c.b === closest) {
                        c.a.energize();
                        energyWaves.push(new EnergyWave(c.a.x, c.a.y, c.a.color));
                        lightnings.push(new Lightning(closest.x, closest.y, c.a.x, c.a.y, closest.color));
                    }
                });
            } else {
                // Click in empty space - create wave from click point
                selectedNode = null;
                updateStructureDNA(null);
                if (showWhLogic) updateWhLogicDisplay();
                
                explosions.push(new Explosion(clickX, clickY, colors[Math.floor(Math.random() * colors.length)]));
                
                // Lightning to nearest nodes
                const nearNodes = nodes.filter(n => {
                    const d = Math.sqrt((n.x - clickX) ** 2 + (n.y - clickY) ** 2);
                    return d < 300;
                }).slice(0, 5);
                
                nearNodes.forEach(n => {
                    lightnings.push(new Lightning(clickX, clickY, n.x, n.y, n.color));
                    n.energize();
                });
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                // Energize all nodes
                nodes.forEach(n => n.energize());
                energyWaves.push(new EnergyWave(cx, cy, '#ffffff'));
                explosions.push(new Explosion(cx, cy, '#ffffff'));
                
                // Lightning storm - connect random pairs
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const n1 = nodes[Math.floor(Math.random() * nodes.length)];
                        const n2 = nodes[Math.floor(Math.random() * nodes.length)];
                        if (n1 && n2 && n1 !== n2 && isFinite(n1.x) && isFinite(n2.x)) {
                            lightnings.push(new Lightning(n1.x, n1.y, n2.x, n2.y, colors[Math.floor(Math.random() * colors.length)]));
                        }
                    }, i * 50);
                }
                
                // Spawn aurora burst
                for (let i = 0; i < 3; i++) {
                    auroraWaves.push(new AuroraWave());
                }
            }
            
            // M key - toggle Meta Structure view
            if (e.code === 'KeyM') {
                metaStructure.toggle();
            }
            
            // S key - toggle Structure of Structures view (all nodes expand)
            if (e.code === 'KeyS') {
                showAllStructures = !showAllStructures;
                nodes.forEach(n => {
                    n.expanded = showAllStructures;
                });
                document.getElementById('nestedPreview').classList.toggle('active', showAllStructures);
                updateStructureTree();
                updateStructurePanel();
                
                // Also toggle inner structures for compatibility
                const allExpanded = innerStructures.every(s => s.targetExpand > 0.5);
                innerStructures.forEach(s => {
                    s.targetExpand = allExpanded ? 0 : 1;
                });
                
                // Visual feedback
                if (showAllStructures) {
                    energyWaves.push(new EnergyWave(cx, cy, '#ff00ff'));
                }
            }
            
            // D key - increase recursion depth visualization
            if (e.code === 'KeyD') {
                currentDepth = (currentDepth + 1) % 6;
                updateDepthBars();
                showZoomIndicator(`DEPTH ${currentDepth}`, getDepthPath());
            }
            
            // Z key - zoom into selected node's structure
            if (e.code === 'KeyZ' && selectedNode) {
                zoomIntoStructure(selectedNode);
            }
            
            // X key - zoom out of current structure
            if (e.code === 'KeyX') {
                zoomOutStructure();
            }
            
            // W key - toggle Wh-Logic panel
            if (e.code === 'KeyW') {
                showWhLogic = !showWhLogic;
                document.getElementById('whLogicPanel').classList.toggle('active', showWhLogic);
                if (showWhLogic) {
                    updateWhLogicDisplay();
                }
            }
            
            // C key - toggle Causal Chain panel
            if (e.code === 'KeyC') {
                showCausalChain = !showCausalChain;
                document.getElementById('causalPanel').classList.toggle('active', showCausalChain);
                if (showCausalChain) {
                    animateCausalChain();
                }
            }
            
            // Number keys 1-5 - expand structures in specific layer
            if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                const layer = parseInt(e.code.replace('Digit', '')) - 1;
                innerStructures.forEach((s, i) => {
                    if (nodes[i] && nodes[i].layer === layer) {
                        s.toggle();
                    }
                });
            }
        });
        
        // ============ STRUCTURE OF STRUCTURES SYSTEM ============
        
        // The path names for each depth level
        const structurePaths = [
            ['MULLU SGI'],
            ['Perception', 'Reasoning', 'Abstraction', 'Meta-Cognition'],
            ['Symbols', 'Causality', 'Ontology', 'Self-Model'],
            ['Atoms', 'Chains', 'Graphs', 'Coherence'],
            ['Quanta', 'Links', 'Vertices', 'Fields'],
            ['∞', '∞', '∞', '∞']
        ];
        
        // Structure DNA metadata definitions
        const structureBehaviors = ['Transform', 'Propagate', 'Filter', 'Amplify', 'Invert', 'Compose'];
        const structureProperties = ['Atomic', 'Composite', 'Recursive', 'Terminal', 'Gateway', 'Hub'];
        const structureBoundaries = ['Permeable', 'Selective', 'Rigid', 'Adaptive', 'Quantum', 'Fuzzy'];
        
        // Update Structure DNA panel when a node is selected
        function updateStructureDNA(node) {
            const panel = document.getElementById('structureDNA');
            if (!node) {
                panel.classList.remove('active');
                return;
            }
            
            panel.classList.add('active');
            
            // Generate DNA values based on node properties
            document.getElementById('dnaIdentity').textContent = node.structureName || `Node-${node.layer}-${node.index}`;
            document.getElementById('dnaBehavior').textContent = structureBehaviors[node.layer % structureBehaviors.length];
            document.getElementById('dnaProperty').textContent = structureProperties[(node.index + node.layer) % structureProperties.length];
            document.getElementById('dnaBoundary').textContent = structureBoundaries[node.index % structureBoundaries.length];
            document.getElementById('dnaChildren').textContent = node.subNodes ? node.subNodes.length : 0;
            document.getElementById('dnaDepth').textContent = `L${node.layer} → L${Math.min(4, node.layer + 1)}`;
        }
        
        // Wh-Logic display system
        const whQueries = {
            what: ['Identity', 'Structure', 'Symbol', 'Form'],
            why: ['Purpose', 'Causation', 'Reason', 'Goal'],
            how: ['Mechanism', 'Process', 'Method', 'Transform'],
            when: ['Sequence', 'Timing', 'Phase', 'Trigger'],
            where: ['Location', 'Layer', 'Position', 'Context'],
            who: ['Agent', 'Owner', 'Creator', 'Observer']
        };
        
        function updateWhLogicDisplay() {
            const queryEl = document.getElementById('whActiveQuery');
            if (selectedNode) {
                const layerNames = ['Perception', 'Tokenization', 'Abstraction', 'Reasoning', 'Meta'];
                queryEl.innerHTML = `
                    <div style="color:#0f8;margin-bottom:5px;">▸ ${selectedNode.structureName}</div>
                    <div>Layer: ${layerNames[selectedNode.layer]}</div>
                    <div>Children: ${selectedNode.subNodes?.length || 0}</div>
                `;
            } else {
                queryEl.textContent = 'SELECT A STRUCTURE';
            }
        }
        
        // Handle Wh-gate clicks
        document.querySelectorAll('.wh-gate').forEach(gate => {
            gate.addEventListener('click', () => {
                const wh = gate.dataset.wh;
                document.querySelectorAll('.wh-gate').forEach(g => g.classList.remove('active'));
                gate.classList.add('active');
                activeWhGate = wh;
                
                // Update query display
                const queryEl = document.getElementById('whActiveQuery');
                if (selectedNode) {
                    const query = whQueries[wh][Math.floor(Math.random() * whQueries[wh].length)];
                    queryEl.innerHTML = `
                        <div style="color:#0f8;margin-bottom:3px;">${wh.toUpperCase()}?</div>
                        <div>→ ${query}</div>
                        <div style="font-size:0.9em;opacity:0.6;">of ${selectedNode.structureName}</div>
                    `;
                    
                    // Visual effect - draw Wh connections
                    drawWhConnections(wh);
                } else {
                    queryEl.innerHTML = `<div style="color:#ff0;">SELECT A NODE FIRST</div>`;
                }
            });
        });
        
        function drawWhConnections(wh) {
            if (!selectedNode) return;
            
            // Create lightning to connected nodes based on Wh type
            const connectedNodes = connections
                .filter(c => c.a === selectedNode || c.b === selectedNode)
                .map(c => c.a === selectedNode ? c.b : c.a)
                .slice(0, 3);
            
            connectedNodes.forEach((n, i) => {
                setTimeout(() => {
                    lightnings.push(new Lightning(selectedNode.x, selectedNode.y, n.x, n.y, '#0f8'));
                    n.energize();
                }, i * 100);
            });
        }
        
        // Causal Chain animation system
        function animateCausalChain() {
            if (!showCausalChain) return;
            
            const causalNodes = document.querySelectorAll('.causal-node');
            causalFlowPhase = 0;
            
            function pulseNext() {
                if (!showCausalChain) return;
                
                causalNodes.forEach(n => n.classList.remove('active'));
                causalNodes[causalFlowPhase % 3].classList.add('active');
                causalFlowPhase++;
                
                // Update inversion status
                const inversionStatus = document.querySelector('.inversion-status');
                if (causalFlowPhase % 6 < 3) {
                    inversionStatus.textContent = 'FORWARD';
                    inversionStatus.style.color = '#0f8';
                } else {
                    inversionStatus.textContent = 'INVERSE';
                    inversionStatus.style.color = '#f0f';
                }
                
                setTimeout(pulseNext, 800);
            }
            
            pulseNext();
        }
        
        // Draw causal flow lines on canvas when active
        function drawCausalOverlay() {
            if (!showCausalChain || !selectedNode) return;
            
            // Find causal chain through connections
            const chainNodes = [selectedNode];
            let current = selectedNode;
            
            for (let i = 0; i < 3; i++) {
                const nextConn = connections.find(c => 
                    (c.a === current && !chainNodes.includes(c.b)) ||
                    (c.b === current && !chainNodes.includes(c.a))
                );
                if (nextConn) {
                    current = nextConn.a === current ? nextConn.b : nextConn.a;
                    chainNodes.push(current);
                }
            }
            
            // Draw causal flow
            if (chainNodes.length > 1) {
                const flowPos = (t * 0.5) % 1;
                
                for (let i = 0; i < chainNodes.length - 1; i++) {
                    const n1 = chainNodes[i];
                    const n2 = chainNodes[i + 1];
                    
                    // Draw chain link
                    fxCtx.strokeStyle = '#ff0';
                    fxCtx.lineWidth = 2;
                    fxCtx.setLineDash([8, 4]);
                    fxCtx.beginPath();
                    fxCtx.moveTo(n1.x, n1.y);
                    fxCtx.lineTo(n2.x, n2.y);
                    fxCtx.stroke();
                    fxCtx.setLineDash([]);
                    
                    // Draw flow particle
                    const px = n1.x + (n2.x - n1.x) * ((flowPos + i * 0.3) % 1);
                    const py = n1.y + (n2.y - n1.y) * ((flowPos + i * 0.3) % 1);
                    
                    fxCtx.fillStyle = '#ff0';
                    fxCtx.beginPath();
                    fxCtx.arc(px, py, 4, 0, Math.PI * 2);
                    fxCtx.fill();
                    
                    // Arrow indicator
                    const angle = Math.atan2(n2.y - n1.y, n2.x - n1.x);
                    fxCtx.save();
                    fxCtx.translate(px, py);
                    fxCtx.rotate(angle);
                    fxCtx.fillStyle = '#ff0';
                    fxCtx.beginPath();
                    fxCtx.moveTo(6, 0);
                    fxCtx.lineTo(-3, -4);
                    fxCtx.lineTo(-3, 4);
                    fxCtx.closePath();
                    fxCtx.fill();
                    fxCtx.restore();
                }
                
                // Label chain nodes
                chainNodes.forEach((n, i) => {
                    const labels = ['CAUSE', 'MECHANISM', 'EFFECT', 'PROPAGATION'];
                    fxCtx.fillStyle = '#ff0';
                    fxCtx.font = '9px monospace';
                    fxCtx.textAlign = 'center';
                    fxCtx.fillText(labels[i] || '...', n.x, n.y - 25);
                });
            }
        }
        
        // Draw Wh-Logic overlay - shows conceptual connections based on Wh questions
        function drawWhLogicOverlay() {
            if (!selectedNode) return;
            
            const whColors = {
                what: '#0ff',
                why: '#f80',
                how: '#0f8',
                when: '#ff0',
                where: '#f0f',
                who: '#88f'
            };
            
            const whLabels = {
                what: '?ምን',
                why: '?ለምን',
                how: '?እንዴት',
                when: '?መቼ',
                where: '?የት',
                who: '?ማን'
            };
            
            // Draw Wh connection web around selected node
            const whTypes = Object.keys(whColors);
            const webRadius = 60 + Math.sin(t * 2) * 10;
            
            whTypes.forEach((wh, i) => {
                const angle = (i / whTypes.length) * Math.PI * 2 - Math.PI / 2 + t * 0.2;
                const x = selectedNode.x + Math.cos(angle) * webRadius;
                const y = selectedNode.y + Math.sin(angle) * webRadius;
                
                // Connection line
                fxCtx.strokeStyle = whColors[wh] + (activeWhGate === wh ? 'aa' : '40');
                fxCtx.lineWidth = activeWhGate === wh ? 2 : 1;
                fxCtx.setLineDash(activeWhGate === wh ? [] : [4, 4]);
                fxCtx.beginPath();
                fxCtx.moveTo(selectedNode.x, selectedNode.y);
                fxCtx.lineTo(x, y);
                fxCtx.stroke();
                fxCtx.setLineDash([]);
                
                // Wh node
                const nodeSize = activeWhGate === wh ? 18 : 12;
                const grad = fxCtx.createRadialGradient(x, y, 0, x, y, nodeSize);
                grad.addColorStop(0, whColors[wh] + (activeWhGate === wh ? 'ff' : '80'));
                grad.addColorStop(1, 'transparent');
                fxCtx.fillStyle = grad;
                fxCtx.beginPath();
                fxCtx.arc(x, y, nodeSize, 0, Math.PI * 2);
                fxCtx.fill();
                
                // Wh label
                fxCtx.fillStyle = whColors[wh];
                fxCtx.font = activeWhGate === wh ? 'bold 11px sans-serif' : '9px sans-serif';
                fxCtx.textAlign = 'center';
                fxCtx.textBaseline = 'middle';
                fxCtx.fillText(whLabels[wh], x, y);
            });
            
            // Draw inter-Wh connections (mesh network concept)
            fxCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            fxCtx.lineWidth = 0.5;
            for (let i = 0; i < whTypes.length; i++) {
                for (let j = i + 2; j < whTypes.length; j++) {
                    const angle1 = (i / whTypes.length) * Math.PI * 2 - Math.PI / 2 + t * 0.2;
                    const angle2 = (j / whTypes.length) * Math.PI * 2 - Math.PI / 2 + t * 0.2;
                    const x1 = selectedNode.x + Math.cos(angle1) * webRadius;
                    const y1 = selectedNode.y + Math.sin(angle1) * webRadius;
                    const x2 = selectedNode.x + Math.cos(angle2) * webRadius;
                    const y2 = selectedNode.y + Math.sin(angle2) * webRadius;
                    
                    fxCtx.beginPath();
                    fxCtx.moveTo(x1, y1);
                    fxCtx.lineTo(x2, y2);
                    fxCtx.stroke();
                }
            }
            
            // Center label
            fxCtx.fillStyle = '#fff';
            fxCtx.font = '10px Orbitron';
            fxCtx.textAlign = 'center';
            fxCtx.fillText('WH-LOGIC', selectedNode.x, selectedNode.y - webRadius - 15);
        }
        
        // Recursive fractal structure visualization
        // This embodies the "Structure of Structures" concept - every structure contains nested structures
        function drawFractalStructure(x, y, size, depth, angleOffset) {
            if (depth <= 0 || size < 3) return;
            
            const numChildren = 6; // Number of sub-structures at each level
            const childSize = size * 0.45;
            const orbit = size * 0.8;
            const rotation = t * (0.3 - depth * 0.05) + angleOffset;
            const alpha = Math.max(0.1, 0.6 - (5 - depth) * 0.1);
            const color = colors[depth % colors.length];
            
            // Draw the structure boundary (dashed hexagonal shape)
            fxCtx.strokeStyle = color + Math.floor(alpha * 100).toString(16).padStart(2, '0');
            fxCtx.lineWidth = Math.max(0.5, depth * 0.3);
            fxCtx.setLineDash([2, 4]);
            fxCtx.beginPath();
            for (let i = 0; i <= numChildren; i++) {
                const angle = (i / numChildren) * Math.PI * 2 + rotation;
                const px = x + Math.cos(angle) * orbit;
                const py = y + Math.sin(angle) * orbit * 0.6;
                if (i === 0) {
                    fxCtx.moveTo(px, py);
                } else {
                    fxCtx.lineTo(px, py);
                }
            }
            fxCtx.stroke();
            fxCtx.setLineDash([]);
            
            // Draw connection lines from center to each child
            for (let i = 0; i < numChildren; i++) {
                const angle = (i / numChildren) * Math.PI * 2 + rotation;
                const childX = x + Math.cos(angle) * orbit;
                const childY = y + Math.sin(angle) * orbit * 0.6;
                
                // Connection line
                fxCtx.strokeStyle = color + Math.floor(alpha * 50).toString(16).padStart(2, '0');
                fxCtx.lineWidth = 0.5;
                fxCtx.beginPath();
                fxCtx.moveTo(x, y);
                fxCtx.lineTo(childX, childY);
                fxCtx.stroke();
                
                // Child node marker
                const pulse = Math.sin(t * 3 + i) * 0.2 + 1;
                const markerSize = Math.max(1, childSize * 0.15 * pulse);
                
                const grad = fxCtx.createRadialGradient(childX, childY, 0, childX, childY, markerSize * 2);
                grad.addColorStop(0, color + Math.floor(alpha * 200).toString(16).padStart(2, '0'));
                grad.addColorStop(1, 'transparent');
                fxCtx.fillStyle = grad;
                fxCtx.beginPath();
                fxCtx.arc(childX, childY, markerSize * 2, 0, Math.PI * 2);
                fxCtx.fill();
                
                // Recursively draw sub-structures
                if (depth > 1) {
                    drawFractalStructure(childX, childY, childSize, depth - 1, angle);
                }
            }
            
            // Draw center node
            const centerPulse = Math.sin(t * 2 + depth) * 0.3 + 1;
            const centerSize = Math.max(2, size * 0.12 * centerPulse);
            
            const centerGrad = fxCtx.createRadialGradient(x, y, 0, x, y, centerSize * 3);
            centerGrad.addColorStop(0, '#ffffff' + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
            centerGrad.addColorStop(0.5, color + Math.floor(alpha * 150).toString(16).padStart(2, '0'));
            centerGrad.addColorStop(1, 'transparent');
            fxCtx.fillStyle = centerGrad;
            fxCtx.beginPath();
            fxCtx.arc(x, y, centerSize * 3, 0, Math.PI * 2);
            fxCtx.fill();
        }
        
        // Draw the main STRUCTURE OF STRUCTURES visualization
        function drawStructureOfStructures() {
            const maxDepth = 5;
            
            // Draw central recursive fractal structure
            drawFractalStructure(cx, cy, 60, currentDepth + 2, 0);
            
            // Draw recursive connection webs between layers
            for (let depth = 0; depth < maxDepth; depth++) {
                const layerNodes = nodes.filter(n => n.layer === depth);
                const nextLayerNodes = nodes.filter(n => n.layer === depth + 1);
                
                if (layerNodes.length && nextLayerNodes.length) {
                    // Draw inter-layer structure connections
                    layerNodes.forEach(n1 => {
                        if (!n1.expanded) return;
                        
                        // Find nearest nodes in next layer
                        const nearest = nextLayerNodes
                            .map(n2 => ({ node: n2, dist: Math.sqrt((n1.x - n2.x) ** 2 + (n1.y - n2.y) ** 2) }))
                            .sort((a, b) => a.dist - b.dist)
                            .slice(0, 2);
                        
                        nearest.forEach(({ node: n2 }) => {
                            // Dashed structure line
                            fxCtx.strokeStyle = n1.color + '30';
                            fxCtx.lineWidth = 1;
                            fxCtx.setLineDash([4, 8]);
                            fxCtx.beginPath();
                            fxCtx.moveTo(n1.x, n1.y);
                            fxCtx.lineTo(n2.x, n2.y);
                            fxCtx.stroke();
                            fxCtx.setLineDash([]);
                        });
                    });
                }
            }
            
            // Draw fractal depth rings from center
            for (let ring = 1; ring <= currentDepth + 1; ring++) {
                const baseR = 50 + ring * 70;
                const wobble = Math.sin(t * 0.5 + ring) * 5;
                const r = baseR + wobble;
                
                // Main ring
                fxCtx.strokeStyle = colors[ring % colors.length] + Math.floor(40 - ring * 5).toString(16).padStart(2, '0');
                fxCtx.lineWidth = 2 - ring * 0.3;
                fxCtx.setLineDash([ring * 2, ring * 4]);
                fxCtx.beginPath();
                fxCtx.arc(cx, cy, r, 0, Math.PI * 2);
                fxCtx.stroke();
                fxCtx.setLineDash([]);
                
                // Depth label on ring
                const labelAngle = -Math.PI / 2 + t * 0.1 * (ring % 2 === 0 ? 1 : -1);
                const labelX = cx + Math.cos(labelAngle) * r;
                const labelY = cy + Math.sin(labelAngle) * r;
                
                fxCtx.fillStyle = colors[ring % colors.length] + '80';
                fxCtx.font = '8px monospace';
                fxCtx.textAlign = 'center';
                fxCtx.fillText(`L${ring}`, labelX, labelY);
            }
            
            // Draw "recursion points" - small markers showing nested structure entry
            nodes.forEach(node => {
                if (node.expanded && node.subNodes) {
                    // Draw recursion indicator
                    const indicatorSize = 3;
                    const indicatorDist = 20 + Math.sin(t * 3) * 3;
                    
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + t * 2;
                        const ix = node.x + Math.cos(angle) * indicatorDist;
                        const iy = node.y + Math.sin(angle) * indicatorDist;
                        
                        fxCtx.fillStyle = node.color + '60';
                        fxCtx.beginPath();
                        fxCtx.arc(ix, iy, indicatorSize, 0, Math.PI * 2);
                        fxCtx.fill();
                        
                        // Connection to center
                        fxCtx.strokeStyle = node.color + '20';
                        fxCtx.lineWidth = 0.5;
                        fxCtx.beginPath();
                        fxCtx.moveTo(node.x, node.y);
                        fxCtx.lineTo(ix, iy);
                        fxCtx.stroke();
                    }
                }
            });
            
            // Draw "structure bridge" - visual connection between selected node and center
            if (selectedNode && selectedNode.expanded) {
                const gradient = fxCtx.createLinearGradient(cx, cy, selectedNode.x, selectedNode.y);
                gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
                gradient.addColorStop(0.5, selectedNode.color + '30');
                gradient.addColorStop(1, 'transparent');
                
                fxCtx.strokeStyle = gradient;
                fxCtx.lineWidth = 3;
                fxCtx.setLineDash([8, 4]);
                fxCtx.beginPath();
                fxCtx.moveTo(cx, cy);
                
                // Curved path
                const midX = (cx + selectedNode.x) / 2;
                const midY = (cy + selectedNode.y) / 2 - 50;
                fxCtx.quadraticCurveTo(midX, midY, selectedNode.x, selectedNode.y);
                fxCtx.stroke();
                fxCtx.setLineDash([]);
                
                // Structure label
                fxCtx.fillStyle = '#fff';
                fxCtx.font = '10px Orbitron';
                fxCtx.textAlign = 'center';
                fxCtx.fillText('STRUCTURE DIVE', midX, midY - 10);
            }
        }
        
        function getDepthPath() {
            let path = 'MULLU';
            for (let i = 1; i <= currentDepth; i++) {
                const idx = Math.floor(Math.random() * structurePaths[i].length);
                path += ' → ' + structurePaths[i][idx];
            }
            return path;
        }
        
        function updateDepthBars() {
            const bars = document.querySelectorAll('.depth-bar');
            bars.forEach((bar, i) => {
                const height = Math.max(5, 100 - (i * 15) - (currentDepth * 10));
                bar.style.height = height + '%';
                bar.style.opacity = i <= currentDepth ? 1 : 0.3;
            });
        }
        
        function showZoomIndicator(level, path) {
            const indicator = document.getElementById('zoomIndicator');
            const levelEl = document.getElementById('zoomLevel');
            const pathEl = document.getElementById('zoomPath');
            
            levelEl.textContent = level;
            pathEl.innerHTML = path.split(' → ').map((p, i) => 
                i === 0 ? `<span>${p}</span>` : p
            ).join(' → ');
            
            indicator.classList.add('active');
            setTimeout(() => indicator.classList.remove('active'), 2000);
        }
        
        function updateStructureTree() {
            // Animate the tree lines based on current state
            const lines = document.querySelectorAll('.structure-line');
            lines.forEach((line, i) => {
                const depth = parseInt(line.dataset.depth) || 0;
                line.style.opacity = showAllStructures || depth <= currentDepth + 1 ? 1 : 0.4;
            });
        }
        
        // Update the structure panel to reflect current state
        function updateStructurePanel() {
            const panel = document.getElementById('structurePanel');
            const treeEl = document.getElementById('structureTree');
            
            // Panel was removed - skip if not present
            if (!panel || !treeEl) return;
            
            if (showAllStructures) {
                panel.classList.add('expanded');
                
                // Dynamically generate tree based on nodes
                let treeHTML = `<div class="structure-line level-0 active" data-depth="0">◆ <span class="symbol">ሙ</span> MULLU SGI <span class="node-count">[${nodes.length} nodes]</span></div>`;
                
                // Group by layer
                const layerNames = ['Perception', 'Tokenization', 'Abstraction', 'Reasoning', 'Meta-Cognition'];
                const layerCounts = [0, 0, 0, 0, 0];
                nodes.forEach(n => layerCounts[n.layer]++);
                
                layerNames.forEach((name, i) => {
                    const isLast = i === layerNames.length - 1;
                    const branch = isLast ? '└─' : '├─';
                    const prefix = isLast ? '  ' : '│ ';
                    
                    treeHTML += `<div class="structure-line level-1 ${selectedNode && selectedNode.layer === i ? 'active' : ''}" data-depth="1">
                        <span class="branch">${branch}</span> <span class="symbol">◈</span> ${name} <span class="node-count">[${layerCounts[i]}]</span>
                    </div>`;
                    
                    // Show expanded sub-structure for selected layer
                    if (selectedNode && selectedNode.layer === i) {
                        treeHTML += `<div class="structure-line level-2" data-depth="2">
                            <span class="branch">${prefix}├─</span> ${selectedNode.structureName}
                        </div>`;
                        
                        // Show sub-nodes
                        selectedNode.subNodes.forEach((sub, si) => {
                            const isSubLast = si === selectedNode.subNodes.length - 1;
                            treeHTML += `<div class="structure-line level-3" data-depth="3">
                                <span class="branch">${prefix}│ ${isSubLast ? '└─' : '├─'}</span> <span class="symbol">${sub.char}</span> SubNode-${si}
                            </div>`;
                        });
                    }
                });
                
                treeEl.innerHTML = treeHTML;
            } else {
                panel.classList.remove('expanded');
            }
            
            // Update depth bars
            updateDepthBars();
        }
        
        // Zoom into a node's internal structure
        function zoomIntoStructure(node) {
            if (!node) return;
            
            currentDepth = Math.min(5, currentDepth + 1);
            selectedNode = node;
            node.expanded = true;
            
            // Visual effect
            energyWaves.push(new EnergyWave(node.x, node.y, node.color));
            explosions.push(new Explosion(node.x, node.y, node.color));
            
            // Lightning to center
            if (isFinite(node.x) && isFinite(cx)) {
                lightnings.push(new Lightning(cx, cy, node.x, node.y, '#ffffff'));
            }
            
            // Show indicator
            const path = `MULLU → ${['Perception', 'Token', 'Abstract', 'Reason', 'Meta'][node.layer]} → ${node.structureName}`;
            showZoomIndicator(`DEPTH ${currentDepth}`, path);
            
            updateStructurePanel();
        }
        
        // Zoom out of current structure
        function zoomOutStructure() {
            if (currentDepth > 0) {
                currentDepth--;
                
                // Visual effect
                energyWaves.push(new EnergyWave(cx, cy, '#ffffff'));
                
                if (currentDepth === 0) {
                    selectedNode = null;
                    nodes.forEach(n => n.expanded = false);
                }
                
                showZoomIndicator(`DEPTH ${currentDepth}`, getDepthPath());
                updateStructurePanel();
            }
        }
        
        // Draw the nested preview canvas
        function drawNestedPreview() {
            if (!showAllStructures) return;
            
            const w = 180, h = 180;
            const ncx = w / 2, ncy = h / 2;
            
            nestedCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            nestedCtx.fillRect(0, 0, w, h);
            
            // Draw fractal-like nested structure
            const depth = currentDepth + 1;
            const baseRadius = 60;
            
            // Draw recursive rings
            for (let d = 0; d < depth; d++) {
                const r = baseRadius - d * 12;
                if (r < 5) break;
                
                // Ring
                nestedCtx.strokeStyle = colors[d % colors.length] + '40';
                nestedCtx.lineWidth = 1;
                nestedCtx.setLineDash([2, 4]);
                nestedCtx.beginPath();
                nestedCtx.arc(ncx, ncy, r, 0, Math.PI * 2);
                nestedCtx.stroke();
                nestedCtx.setLineDash([]);
                
                // Sub-nodes on ring
                const nodeCount = 3 + d * 2;
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * Math.PI * 2 + t * (0.5 - d * 0.1);
                    const nx = ncx + Math.cos(angle) * r;
                    const ny = ncy + Math.sin(angle) * r;
                    const size = Math.max(2, 6 - d);
                    
                    // Node glow
                    const grad = nestedCtx.createRadialGradient(nx, ny, 0, nx, ny, size * 2);
                    grad.addColorStop(0, colors[d % colors.length] + '80');
                    grad.addColorStop(1, 'transparent');
                    nestedCtx.fillStyle = grad;
                    nestedCtx.beginPath();
                    nestedCtx.arc(nx, ny, size * 2, 0, Math.PI * 2);
                    nestedCtx.fill();
                    
                    // Node core
                    nestedCtx.fillStyle = colors[d % colors.length];
                    nestedCtx.beginPath();
                    nestedCtx.arc(nx, ny, size, 0, Math.PI * 2);
                    nestedCtx.fill();
                    
                    // Connection to center (partial)
                    if (Math.random() < 0.3) {
                        nestedCtx.strokeStyle = colors[d % colors.length] + '30';
                        nestedCtx.lineWidth = 0.5;
                        nestedCtx.beginPath();
                        nestedCtx.moveTo(nx, ny);
                        nestedCtx.lineTo(ncx + (nx - ncx) * 0.3, ncy + (ny - ncy) * 0.3);
                        nestedCtx.stroke();
                    }
                }
            }
            
            // Center symbol
            nestedCtx.fillStyle = '#fff';
            nestedCtx.font = 'bold 16px sans-serif';
            nestedCtx.textAlign = 'center';
            nestedCtx.textBaseline = 'middle';
            nestedCtx.fillText('ሙ', ncx, ncy);
            
            // Depth indicator
            nestedCtx.fillStyle = 'rgba(255,255,255,0.5)';
            nestedCtx.font = '9px monospace';
            nestedCtx.fillText(`DEPTH: ${currentDepth}`, ncx, h - 15);
        }
        
        // ============ LOADING SEQUENCE ============
        function runLoadingSequence() {
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingBar = document.getElementById('loadingBar');
            const items = [
                document.getElementById('load1'),
                document.getElementById('load2'),
                document.getElementById('load3'),
                document.getElementById('load4'),
                document.getElementById('load5'),
                document.getElementById('load6')
            ];
            
            let progress = 0;
            const totalDuration = 3000; // 3 seconds total
            const stepDuration = totalDuration / items.length;
            
            // Animate progress bar and items
            items.forEach((item, index) => {
                setTimeout(() => {
                    item.classList.add('visible');
                    progress = ((index + 1) / items.length) * 100;
                    loadingBar.style.width = progress + '%';
                }, stepDuration * index);
            });
            
            // Hide loading screen after completion
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, totalDuration + 500);
        }
        
        // ============ FLOATING GE'EZ CHARACTERS - PHYSICS BASED ============
        function createFloatingChars() {
            const container = document.getElementById('floatingChars');
            if (!container) { console.error('No floatingChars container'); return; }
            
            // Fidel families - each row is one consonant with all 7 vowel forms
            const fidelFamilies = [
                ['ሀ','ሁ','ሂ','ሃ','ሄ','ህ','ሆ'],
                ['ለ','ሉ','ሊ','ላ','ሌ','ል','ሎ'],
                ['ሐ','ሑ','ሒ','ሓ','ሔ','ሕ','ሖ'],
                ['መ','ሙ','ሚ','ማ','ሜ','ም','ሞ'],
                ['ረ','ሩ','ሪ','ራ','ሬ','ር','ሮ'],
                ['ሰ','ሱ','ሲ','ሳ','ሴ','ስ','ሶ'],
                ['ሸ','ሹ','ሺ','ሻ','ሼ','ሽ','ሾ'],
                ['ቀ','ቁ','ቂ','ቃ','ቄ','ቅ','ቆ'],
                ['በ','ቡ','ቢ','ባ','ቤ','ብ','ቦ'],
                ['ተ','ቱ','ቲ','ታ','ቴ','ት','ቶ'],
                ['ቸ','ቹ','ቺ','ቻ','ቼ','ች','ቾ'],
                ['ነ','ኑ','ኒ','ና','ኔ','ን','ኖ'],
                ['አ','ኡ','ኢ','ኣ','ኤ','እ','ኦ'],
                ['ከ','ኩ','ኪ','ካ','ኬ','ክ','ኮ'],
                ['ወ','ዉ','ዊ','ዋ','ዌ','ው','ዎ'],
                ['ዘ','ዙ','ዚ','ዛ','ዜ','ዝ','ዞ'],
                ['የ','ዩ','ዪ','ያ','ዬ','ይ','ዮ'],
                ['ደ','ዱ','ዲ','ዳ','ዴ','ድ','ዶ'],
                ['ገ','ጉ','ጊ','ጋ','ጌ','ግ','ጎ'],
                ['ጠ','ጡ','ጢ','ጣ','ጤ','ጥ','ጦ'],
                ['ጰ','ጱ','ጲ','ጳ','ጴ','ጵ','ጶ'],
                ['ጸ','ጹ','ጺ','ጻ','ጼ','ጽ','ጾ'],
                ['ፈ','ፉ','ፊ','ፋ','ፌ','ፍ','ፎ'],
                ['ፐ','ፑ','ፒ','ፓ','ፔ','ፕ','ፖ'],
            ];
            
            // Physics behavior types
            const PHYSICS = {
                FLOAT_UP: 0,      // Classic float upward
                DRIFT: 1,         // Gentle horizontal drift
                SPIRAL: 2,        // Spiral motion
                WAVE: 3,          // Sine wave path
                BOUNCE: 4,        // Bouncing motion
                ORBIT: 5,         // Circular orbit
                ZIGZAG: 6,        // Zigzag path
                GRAVITY: 7,       // Fall then float
            };
            
            // Random color palettes
            const colorPalettes = [
                ['#00ffff', '#00e5ff', '#00ccff'], // Cyan
                ['#ff00ff', '#ff00cc', '#cc00ff'], // Magenta
                ['#ffff00', '#ffcc00', '#ffaa00'], // Yellow/Gold
                ['#00ff88', '#00ff66', '#00ffaa'], // Green
                ['#ff8800', '#ff6600', '#ffaa00'], // Orange
                ['#8800ff', '#aa00ff', '#6600ff'], // Purple
                ['#ff0066', '#ff0088', '#ff00aa'], // Pink
                ['#00ffff', '#ff00ff', '#ffff00'], // Rainbow mix
            ];
            
            const activeChars = [];
            let lastSpawn = 0;
            
            function randomRange(min, max) {
                return min + Math.random() * (max - min);
            }
            
            function spawnChar() {
                const el = document.createElement('div');
                el.className = 'float-char';
                
                const family = fidelFamilies[Math.floor(Math.random() * fidelFamilies.length)];
                const palette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
                const physicsType = Math.floor(Math.random() * 8);
                
                // Random spawn position based on physics type
                let startX, startY;
                switch(physicsType) {
                    case PHYSICS.GRAVITY:
                        startX = randomRange(10, 90);
                        startY = -5;
                        break;
                    case PHYSICS.DRIFT:
                        startX = Math.random() < 0.5 ? -5 : 105;
                        startY = randomRange(20, 80);
                        break;
                    default:
                        startX = randomRange(5, 95);
                        startY = 105;
                }
                
                const charData = {
                    el: el,
                    family: family,
                    order: Math.floor(Math.random() * 7), // Random starting vowel
                    palette: palette,
                    colorIndex: 0,
                    
                    // Position & physics
                    x: startX,
                    y: startY,
                    vx: randomRange(-0.3, 0.3),
                    vy: randomRange(-0.8, -0.3),
                    ax: 0,
                    ay: 0,
                    physics: physicsType,
                    
                    // Rotation
                    rotation: 0,
                    rotationSpeed: randomRange(-2, 2),
                    
                    // Scale / zoom
                    scale: randomRange(0.5, 1.5),
                    targetScale: randomRange(0.5, 2),
                    scaleSpeed: randomRange(0.001, 0.005),
                    scaleDirection: Math.random() < 0.5 ? 1 : -1,
                    minScale: randomRange(0.3, 0.8),
                    maxScale: randomRange(1.5, 3),
                    
                    // Timing
                    cycleInterval: randomRange(300, 1500),
                    colorInterval: randomRange(500, 2000),
                    lastCycle: performance.now(),
                    lastColorChange: performance.now(),
                    
                    // Physics parameters
                    spiralAngle: Math.random() * Math.PI * 2,
                    spiralSpeed: randomRange(0.02, 0.08),
                    spiralRadius: randomRange(0.5, 2),
                    waveAmplitude: randomRange(1, 4),
                    waveFrequency: randomRange(0.02, 0.08),
                    bouncePhase: 0,
                    orbitCenterX: randomRange(30, 70),
                    orbitCenterY: randomRange(30, 70),
                    orbitRadius: randomRange(10, 30),
                    orbitSpeed: randomRange(0.01, 0.04),
                    orbitAngle: Math.random() * Math.PI * 2,
                    zigzagPhase: 0,
                    zigzagWidth: randomRange(2, 8),
                    gravityPhase: 0,
                    
                    // Lifetime
                    created: performance.now(),
                    duration: randomRange(8000, 25000),
                    opacity: 0,
                    fadeIn: true,
                };
                
                el.textContent = family[charData.order];
                el.style.color = palette[0];
                el.style.fontSize = (1 + charData.scale) + 'em';
                el.style.position = 'absolute';
                el.style.left = charData.x + '%';
                el.style.top = charData.y + '%';
                el.style.opacity = '0';
                el.style.textShadow = `0 0 10px currentColor`;
                el.style.transition = 'none';
                el.style.willChange = 'transform, opacity, color';
                
                container.appendChild(el);
                activeChars.push(charData);
            }
            
            function updatePhysics(c, dt, now) {
                const t = (now - c.created) / 1000;
                
                switch(c.physics) {
                    case PHYSICS.FLOAT_UP:
                        c.vy = -randomRange(0.5, 1.2);
                        c.vx += Math.sin(t * 2) * 0.01;
                        break;
                        
                    case PHYSICS.DRIFT:
                        c.vx = c.x < 50 ? 0.5 : -0.5;
                        c.vy = Math.sin(t) * 0.3;
                        break;
                        
                    case PHYSICS.SPIRAL:
                        c.spiralAngle += c.spiralSpeed;
                        c.vx = Math.cos(c.spiralAngle) * c.spiralRadius;
                        c.vy = -0.5 + Math.sin(c.spiralAngle) * c.spiralRadius * 0.3;
                        break;
                        
                    case PHYSICS.WAVE:
                        c.vy = -0.6;
                        c.x = c.x + Math.sin(t * c.waveFrequency * 10) * c.waveAmplitude * 0.1;
                        break;
                        
                    case PHYSICS.BOUNCE:
                        c.bouncePhase += 0.05;
                        c.vy = -0.4 + Math.abs(Math.sin(c.bouncePhase)) * -0.8;
                        c.vx = Math.sin(t * 0.5) * 0.3;
                        break;
                        
                    case PHYSICS.ORBIT:
                        c.orbitAngle += c.orbitSpeed;
                        c.x = c.orbitCenterX + Math.cos(c.orbitAngle) * c.orbitRadius;
                        c.y = c.orbitCenterY + Math.sin(c.orbitAngle) * c.orbitRadius;
                        // Slowly move center upward
                        c.orbitCenterY -= 0.1;
                        c.vx = 0; c.vy = 0;
                        break;
                        
                    case PHYSICS.ZIGZAG:
                        c.zigzagPhase += 0.1;
                        c.vy = -0.7;
                        c.vx = Math.sign(Math.sin(c.zigzagPhase)) * c.zigzagWidth * 0.1;
                        break;
                        
                    case PHYSICS.GRAVITY:
                        c.gravityPhase += 0.02;
                        if (c.gravityPhase < 1) {
                            // Falling
                            c.vy = Math.min(c.vy + 0.05, 2);
                        } else {
                            // Float up
                            c.vy = Math.max(c.vy - 0.02, -0.8);
                        }
                        c.vx += Math.sin(t * 3) * 0.02;
                        break;
                }
                
                // Apply velocity
                if (c.physics !== PHYSICS.ORBIT) {
                    c.x += c.vx;
                    c.y += c.vy;
                }
                
                // Rotation
                c.rotation += c.rotationSpeed;
                
                // Scale breathing / zoom
                c.scale += c.scaleSpeed * c.scaleDirection;
                if (c.scale >= c.maxScale) {
                    c.scaleDirection = -1;
                    c.targetScale = randomRange(c.minScale, c.scale);
                } else if (c.scale <= c.minScale) {
                    c.scaleDirection = 1;
                    c.targetScale = randomRange(c.scale, c.maxScale);
                }
                
                // Fade in/out
                const age = now - c.created;
                const remainingLife = c.duration - age;
                if (age < 500) {
                    c.opacity = age / 500;
                } else if (remainingLife < 1000) {
                    c.opacity = remainingLife / 1000;
                } else {
                    c.opacity = 0.6 + Math.sin(t * 2) * 0.3;
                }
            }
            
            function updateChars(now) {
                const dt = 16; // ~60fps
                
                for (let i = activeChars.length - 1; i >= 0; i--) {
                    const c = activeChars[i];
                    const age = now - c.created;
                    
                    // Remove if expired or out of bounds
                    if (age > c.duration || c.y < -20 || c.y > 120 || c.x < -20 || c.x > 120) {
                        c.el.remove();
                        activeChars.splice(i, 1);
                        continue;
                    }
                    
                    // Update physics
                    updatePhysics(c, dt, now);
                    
                    // Cycle Fidel family (vowel order)
                    if (now - c.lastCycle > c.cycleInterval) {
                        c.order = (c.order + 1) % 7;
                        c.el.textContent = c.family[c.order];
                        c.lastCycle = now;
                        
                        // Randomize next cycle interval
                        c.cycleInterval = randomRange(200, 1500);
                        
                        // Pulse effect
                        c.el.style.textShadow = `0 0 ${20 + c.scale * 10}px currentColor, 0 0 ${40 + c.scale * 15}px currentColor`;
                        setTimeout(() => {
                            if (c.el.parentNode) {
                                c.el.style.textShadow = `0 0 ${5 + c.scale * 5}px currentColor`;
                            }
                        }, 100);
                    }
                    
                    // Cycle color
                    if (now - c.lastColorChange > c.colorInterval) {
                        c.colorIndex = (c.colorIndex + 1) % c.palette.length;
                        c.el.style.color = c.palette[c.colorIndex];
                        c.lastColorChange = now;
                        c.colorInterval = randomRange(400, 2500);
                    }
                    
                    // Apply transforms
                    c.el.style.left = c.x + '%';
                    c.el.style.top = c.y + '%';
                    c.el.style.opacity = c.opacity;
                    c.el.style.fontSize = (0.8 + c.scale * 1.5) + 'em';
                    c.el.style.transform = `rotate(${c.rotation}deg) scale(${0.5 + c.scale * 0.5})`;
                }
                
                requestAnimationFrame(updateChars);
            }
            
            // Start update loop
            requestAnimationFrame(updateChars);
            
            // Spawn initial batch with variety
            for (let i = 0; i < 15; i++) {
                setTimeout(spawnChar, i * 150);
            }
            
            // Continue spawning at random intervals
            function scheduleNextSpawn() {
                const delay = randomRange(400, 1200);
                setTimeout(() => {
                    if (activeChars.length < 30) {
                        spawnChar();
                    }
                    scheduleNextSpawn();
                }, delay);
            }
            scheduleNextSpawn();
        }
        
        // Start loading sequence
        runLoadingSequence();
        
        // Start floating chars after loading
        // Floating chars moved to architect area
        // setTimeout(createFloatingChars, 3500);
        
        // ═══════════════════════════════════════════════════════════════
        // PRODUCTION HARDENING
        // ═══════════════════════════════════════════════════════════════
        
        // Pause animation when tab hidden (saves CPU/battery)
        let RUNNING = true;
        document.addEventListener('visibilitychange', () => {
            RUNNING = !document.hidden;
            if (RUNNING) requestAnimationFrame(animate);
        });
        
        // Memory caps - prevent long-session degradation
        function cap(arr, max) {
            if (arr.length > max) arr.splice(0, arr.length - max);
        }
        
        // Apply caps in animation loop (will be called periodically)
        function enforceMemoryCaps() {
            cap(particles, 800);
            cap(lightnings, 50);
            cap(explosions, 30);
            cap(energyWaves, 20);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // HELP PANEL
        // ═══════════════════════════════════════════════════════════════
        
        const helpToggle = document.getElementById('helpToggle');
        const helpPanel = document.getElementById('helpPanel');
        let helpVisible = false;
        
        if (helpToggle && helpPanel) {
            helpToggle.addEventListener('click', () => {
                helpVisible = !helpVisible;
                helpPanel.classList.toggle('visible', helpVisible);
                helpToggle.textContent = helpVisible ? '×' : '?';
            });
        }
        
        // ═══════════════════════════════════════════════════════════════
        // METRICS PANEL
        // ═══════════════════════════════════════════════════════════════
        
        const metricsPanel = document.getElementById('metricsPanel');
        let metricsVisible = false;
        
        function updateMetrics() {
            if (!metricsVisible) return;
            
            const symbolCount = nodes.length;
            const connectionCount = connections.length;
            const particleCount = particles.length;
            const effectCount = lightnings.length + explosions.length + energyWaves.length;
            const depth = currentDepth;
            
            // Calculate Wh-Entropy (based on active gates and connections)
            const activeGates = showWhLogic ? (activeWhGate ? 1 : 0) : 0;
            const entropy = (activeGates * 0.2 + (selectedNode ? 0.3 : 0) + (showCausalChain ? 0.2 : 0) + (depth * 0.1)).toFixed(2);
            
            // System load estimate
            const load = Math.min(100, Math.round((particleCount / 800 * 40) + (effectCount / 100 * 30) + (symbolCount / 80 * 30)));
            
            document.getElementById('metricSymbols').textContent = symbolCount;
            document.getElementById('metricConnections').textContent = connectionCount;
            document.getElementById('metricParticles').textContent = particleCount;
            document.getElementById('metricEffects').textContent = effectCount;
            document.getElementById('metricDepth').textContent = depth;
            document.getElementById('metricEntropy').textContent = entropy;
            document.getElementById('metricLoad').textContent = load + '%';
            document.getElementById('metricLoadBar').style.width = load + '%';
        }
        
        // Update metrics every 500ms
        setInterval(updateMetrics, 500);
        
        // ═══════════════════════════════════════════════════════════════
        // FPS COUNTER
        // ═══════════════════════════════════════════════════════════════
        
        const fpsCounter = document.getElementById('fpsCounter');
        let fpsVisible = false;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let currentFps = 60;
        
        function updateFps() {
            frameCount++;
            const now = performance.now();
            const delta = now - lastFpsTime;
            
            if (delta >= 1000) {
                currentFps = Math.round(frameCount * 1000 / delta);
                frameCount = 0;
                lastFpsTime = now;
                
                if (fpsVisible && fpsCounter) {
                    fpsCounter.textContent = currentFps + ' FPS';
                    fpsCounter.classList.remove('warning', 'critical');
                    if (currentFps < 30) {
                        fpsCounter.classList.add('critical');
                    } else if (currentFps < 45) {
                        fpsCounter.classList.add('warning');
                    }
                }
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // SCREENSHOT FUNCTIONALITY
        // ═══════════════════════════════════════════════════════════════
        
        function takeScreenshot() {
            // Create combined canvas
            const combinedCanvas = document.createElement('canvas');
            combinedCanvas.width = window.innerWidth;
            combinedCanvas.height = window.innerHeight;
            const ctx = combinedCanvas.getContext('2d');
            
            // Draw all canvas layers
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
            ctx.drawImage(bgCanvas, 0, 0);
            ctx.drawImage(mainCanvas, 0, 0);
            ctx.drawImage(fxCanvas, 0, 0);
            ctx.drawImage(topCanvas, 0, 0);
            
            // Add watermark
            ctx.font = '14px Orbitron';
            ctx.fillStyle = 'rgba(0,255,255,0.5)';
            ctx.fillText('MULLU SGI • mullusi.com', 20, combinedCanvas.height - 20);
            
            // Flash effect
            const flash = document.getElementById('screenshotFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 300);
            
            // Download
            const link = document.createElement('a');
            link.download = `mullu-sgi-${Date.now()}.png`;
            link.href = combinedCanvas.toDataURL('image/png');
            link.click();
            
            // Toast notification
            const toast = document.getElementById('screenshotToast');
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 2000);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // KEYBOARD EXTENSIONS (M, F, P, G, E)
        // ═══════════════════════════════════════════════════════════════
        
        // Effect element references
        const effectElements = {
            scanlines: document.querySelector('.scanlines'),
            grain: document.querySelector('.film-grain'),
            chromatic: document.querySelector('.chromatic-aberration'),
            bloom: document.querySelector('.bloom-overlay'),
            atmosphere: document.querySelector('.atmosphere-glow'),
            vignette: document.querySelector('.vignette')
        };
        
        let effectsEnabled = true;
        let grainEnabled = true;
        
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            // M - Toggle metrics
            if (key === 'm') {
                metricsVisible = !metricsVisible;
                metricsPanel.classList.toggle('visible', metricsVisible);
            }
            
            // F - Toggle FPS counter
            if (key === 'f') {
                fpsVisible = !fpsVisible;
                fpsCounter.classList.toggle('visible', fpsVisible);
            }
            
            // P - Screenshot
            if (key === 'p') {
                takeScreenshot();
            }
            
            // H - Toggle help (alternative)
            if (key === 'h') {
                helpVisible = !helpVisible;
                helpPanel.classList.toggle('visible', helpVisible);
                helpToggle.textContent = helpVisible ? '×' : '?';
            }
            
            // E - Toggle post-processing effects
            if (key === 'e') {
                effectsEnabled = !effectsEnabled;
                const opacity = effectsEnabled ? '' : '0';
                if (effectElements.chromatic) effectElements.chromatic.style.opacity = opacity;
                if (effectElements.bloom) effectElements.bloom.style.opacity = opacity;
                if (effectElements.atmosphere) effectElements.atmosphere.style.opacity = opacity;
                if (effectElements.scanlines) effectElements.scanlines.style.opacity = effectsEnabled ? '0.25' : '0';
            }
            
            // G - Toggle film grain
            if (key === 'g') {
                grainEnabled = !grainEnabled;
                if (effectElements.grain) effectElements.grain.style.opacity = grainEnabled ? '0.04' : '0';
            }
            
            // V - Toggle vignette
            if (key === 'v') {
                if (effectElements.vignette) {
                    const current = effectElements.vignette.style.opacity;
                    effectElements.vignette.style.opacity = current === '0' ? '' : '0';
                }
            }
        });
        
        // ═══════════════════════════════════════════════════════════════
        // ENHANCED ANIMATION LOOP WITH PRODUCTION FEATURES
        // ═══════════════════════════════════════════════════════════════
        
        let frameCounter = 0;
        
        // Enhanced animate with production features + architect beams
        function enhancedAnimateLoop(timestamp) {
            if (!RUNNING) return;
            
            // Update FPS
            updateFps();
            
            // Enforce memory caps every 60 frames
            frameCounter++;
            if (frameCounter % 60 === 0) {
                enforceMemoryCaps();
            }
            
            // Draw architect -> system connection when active
            if (typeof architectActive !== 'undefined' && architectActive && architectCredit) {
                const rect = architectCredit.getBoundingClientRect();
                const ax = rect.left + rect.width / 2;
                const ay = rect.top + rect.height / 2;
                
                // Draw beams to layer 0 nodes
                fxCtx.save();
                if (architectConnections) {
                    architectConnections.forEach(node => {
                        const gradient = fxCtx.createLinearGradient(ax, ay, node.x, node.y);
                        gradient.addColorStop(0, 'rgba(0,255,255,0.6)');
                        gradient.addColorStop(0.5, 'rgba(255,0,255,0.4)');
                        gradient.addColorStop(1, 'rgba(255,255,0,0.2)');
                        
                        fxCtx.strokeStyle = gradient;
                        fxCtx.lineWidth = 2;
                        fxCtx.setLineDash([8, 4]);
                        fxCtx.lineDashOffset = -timestamp * 0.02;
                        fxCtx.beginPath();
                        fxCtx.moveTo(ax, ay);
                        fxCtx.lineTo(node.x, node.y);
                        fxCtx.stroke();
                        
                        // Pulse at connection point
                        const pulseSize = 4 + Math.sin(timestamp * 0.005) * 2;
                        fxCtx.fillStyle = '#0ff';
                        fxCtx.beginPath();
                        fxCtx.arc(node.x, node.y, pulseSize, 0, Math.PI * 2);
                        fxCtx.fill();
                    });
                }
                fxCtx.setLineDash([]);
                fxCtx.restore();
            }
            
            // Call original animation
            animate(timestamp);
        }
        
        // Set the loop reference
        window.animateLoop = enhancedAnimateLoop;
        
        // ═══════════════════════════════════════════════════════════════
        // ARCHITECT HOLOGRAPHIC ENHANCEMENT
        // ═══════════════════════════════════════════════════════════════
        
        const architectCredit = document.querySelector('.architect-credit');
        const architectPhoto = document.querySelector('.architect-photo');
        let architectActive = false;
        let architectConnections = [];
        
        // Wrap photo in container and add holographic elements
        if (architectPhoto && architectCredit) {
            // Create container
            const container = document.createElement('div');
            container.className = 'architect-photo-container';
            container.style.cssText = 'position:relative;width:70px;height:70px;';
            
            // Move photo into container
            architectPhoto.parentNode.insertBefore(container, architectPhoto);
            container.appendChild(architectPhoto);
            
            // Add orbital rings
            for (let i = 1; i <= 3; i++) {
                const ring = document.createElement('div');
                ring.className = `photo-ring photo-ring-${i}`;
                container.appendChild(ring);
            }
            
            // Add orbiting particles
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'photo-particle';
                container.appendChild(particle);
            }
            
            // Add scanline
            const scanline = document.createElement('div');
            scanline.className = 'photo-scanline';
            container.appendChild(scanline);
            
            // Add energy burst element
            const burst = document.createElement('div');
            burst.className = 'photo-energy-burst';
            burst.id = 'photoBurst';
            container.appendChild(burst);
            
            // Add Ge'ez title
            const geezTitle = document.createElement('div');
            geezTitle.className = 'architect-title-geez';
            geezTitle.textContent = 'ሙሉ ፈጣሪ';
            architectCredit.querySelector('.architect-info').appendChild(geezTitle);
            
            // Add ID for JS reference
            architectCredit.id = 'architectCredit';
        }
        
        // Architect click handler - energy burst + lightning to system
        if (architectCredit) {
            architectCredit.addEventListener('click', (e) => {
                e.stopPropagation();
                architectActive = !architectActive;
                architectCredit.classList.toggle('active', architectActive);
                
                // Trigger energy burst
                const burst = document.getElementById('photoBurst');
                if (burst) {
                    burst.classList.remove('active');
                    void burst.offsetWidth; // Force reflow
                    burst.classList.add('active');
                }
                
                // Get architect position
                const rect = architectCredit.getBoundingClientRect();
                const ax = rect.left + rect.width / 2;
                const ay = rect.top + rect.height / 2;
                
                // Create explosion at architect
                explosions.push(new Explosion(ax, ay, architectActive ? '#0ff' : '#f0f'));
                
                // Lightning to random nodes
                const targetNodes = nodes.slice().sort(() => Math.random() - 0.5).slice(0, 5);
                targetNodes.forEach((node, i) => {
                    setTimeout(() => {
                        lightnings.push(new Lightning(ax, ay, node.x, node.y, architectActive ? '#0ff' : '#f0f'));
                        // Energize target node
                        node.energized = true;
                        node.energyColor = architectActive ? '#0ff' : '#f0f';
                        setTimeout(() => node.energized = false, 500);
                    }, i * 100);
                });
                
                // Create energy wave
                energyWaves.push({
                    x: ax,
                    y: ay,
                    radius: 0,
                    maxRadius: 400,
                    alpha: 1,
                    color: architectActive ? '#0ff' : '#f0f'
                });
                
                // If active, start drawing connections to center
                if (architectActive) {
                    architectConnections = nodes.filter(n => n.layer === 0);
                }
            });
            
            // Hover effect - subtle lightning preview
            architectCredit.addEventListener('mouseenter', () => {
                const rect = architectCredit.getBoundingClientRect();
                const ax = rect.left + rect.width / 2;
                const ay = rect.top + rect.height / 2;
                
                // Mini particles
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(
                        ax + (Math.random() - 0.5) * 50,
                        ay + (Math.random() - 0.5) * 50,
                        ['#0ff', '#f0f', '#ff0'][Math.floor(Math.random() * 3)]
                    ));
                }
            });
        }
        
        // ═══════════════════════════════════════════════════════════════
        // MFIDEL SYMBOLIC SYSTEM - Atomic Units of Mullu SGI
        // ═══════════════════════════════════════════════════════════════
        
        // Complete MFIDEL structure with symbolic metadata
        const MFIDEL = {
            name: 'MFIDEL',
            fullName: 'Mullu Fidel',
            amharic: 'ሙሉ ፊደል',
            description: 'Symbolic Atomic Units',
            totalFamilies: 34,
            vowelOrders: 7,
            totalSymbols: 238,
            
            // 7 Vowel orders (ስርዓተ ፊደል)
            orders: [
                { id: 1, geez: 'ግዕዝ', name: 'Geez', sound: 'ä', desc: 'Base form' },
                { id: 2, geez: 'ካዕብ', name: 'Kaeb', sound: 'u', desc: 'Second' },
                { id: 3, geez: 'ሣልስ', name: 'Salis', sound: 'i', desc: 'Third' },
                { id: 4, geez: 'ራብዕ', name: 'Rabi', sound: 'a', desc: 'Fourth' },
                { id: 5, geez: 'ኃምስ', name: 'Hamis', sound: 'e', desc: 'Fifth' },
                { id: 6, geez: 'ሳድስ', name: 'Sadis', sound: 'ə', desc: 'Sixth' },
                { id: 7, geez: 'ሳብዕ', name: 'Sabi', sound: 'o', desc: 'Seventh' },
            ],
            
            // Mfidel families with rich metadata
            families: [
                { id: 1, root: 'ሀ', name: 'HOY', amh: 'ሆይ', chars: ['ሀ','ሁ','ሂ','ሃ','ሄ','ህ','ሆ'], 
                  meaning: 'Being', category: 'existence', color: '#00ffff' },
                { id: 2, root: 'ለ', name: 'LAWI', amh: 'ላዊ', chars: ['ለ','ሉ','ሊ','ላ','ሌ','ል','ሎ'], 
                  meaning: 'To/For', category: 'relation', color: '#00ff88' },
                { id: 3, root: 'ሐ', name: 'HAWT', amh: 'ሐውት', chars: ['ሐ','ሑ','ሒ','ሓ','ሔ','ሕ','ሖ'], 
                  meaning: 'Life', category: 'existence', color: '#88ff00' },
                { id: 4, root: 'መ', name: 'MAY', amh: 'ማይ', chars: ['መ','ሙ','ሚ','ማ','ሜ','ም','ሞ'], 
                  meaning: 'What', category: 'query', color: '#ffff00' },
                { id: 5, root: 'ሠ', name: 'SAWT', amh: 'ሣውት', chars: ['ሠ','ሡ','ሢ','ሣ','ሤ','ሥ','ሦ'], 
                  meaning: 'Voice', category: 'expression', color: '#ff8800' },
                { id: 6, root: 'ረ', name: 'REYS', amh: 'ርእስ', chars: ['ረ','ሩ','ሪ','ራ','ሬ','ር','ሮ'], 
                  meaning: 'Head', category: 'body', color: '#ff0088' },
                { id: 7, root: 'ሰ', name: 'SAT', amh: 'ሳት', chars: ['ሰ','ሱ','ሲ','ሳ','ሴ','ስ','ሶ'], 
                  meaning: 'Give', category: 'action', color: '#ff00ff' },
                { id: 8, root: 'ሸ', name: 'SHA', amh: 'ሻ', chars: ['ሸ','ሹ','ሺ','ሻ','ሼ','ሽ','ሾ'], 
                  meaning: 'Thousand', category: 'quantity', color: '#8800ff' },
                { id: 9, root: 'ቀ', name: 'QAF', amh: 'ቃፍ', chars: ['ቀ','ቁ','ቂ','ቃ','ቄ','ቅ','ቆ'], 
                  meaning: 'Word', category: 'symbol', color: '#0088ff' },
                { id: 10, root: 'በ', name: 'BET', amh: 'ቤት', chars: ['በ','ቡ','ቢ','ባ','ቤ','ብ','ቦ'], 
                  meaning: 'House', category: 'structure', color: '#00ddff' },
                { id: 11, root: 'ቨ', name: 'VE', amh: 'ቬ', chars: ['ቨ','ቩ','ቪ','ቫ','ቬ','ቭ','ቮ'], 
                  meaning: 'Foreign', category: 'external', color: '#00ff99' },
                { id: 12, root: 'ተ', name: 'TAW', amh: 'ታው', chars: ['ተ','ቱ','ቲ','ታ','ቴ','ት','ቶ'], 
                  meaning: 'Sign', category: 'symbol', color: '#99ff00' },
                { id: 13, root: 'ቸ', name: 'CHA', amh: 'ቻ', chars: ['ቸ','ቹ','ቺ','ቻ','ቼ','ች','ቾ'], 
                  meaning: 'Able', category: 'capability', color: '#ffdd00' },
                { id: 14, root: 'ኀ', name: 'HARM', amh: 'ኀርም', chars: ['ኀ','ኁ','ኂ','ኃ','ኄ','ኅ','ኆ'], 
                  meaning: 'Silk', category: 'material', color: '#ff9900' },
                { id: 15, root: 'ነ', name: 'NAHAS', amh: 'ንሐስ', chars: ['ነ','ኑ','ኒ','ና','ኔ','ን','ኖ'], 
                  meaning: 'Copper', category: 'material', color: '#ff0066' },
                { id: 16, root: 'ኘ', name: 'NYA', amh: 'ኛ', chars: ['ኘ','ኙ','ኚ','ኛ','ኜ','ኝ','ኞ'], 
                  meaning: 'Self', category: 'identity', color: '#ff00cc' },
                { id: 17, root: 'አ', name: 'ALF', amh: 'አልፍ', chars: ['አ','ኡ','ኢ','ኣ','ኤ','እ','ኦ'], 
                  meaning: 'First', category: 'order', color: '#9900ff' },
                { id: 18, root: 'ከ', name: 'KAF', amh: 'ካፍ', chars: ['ከ','ኩ','ኪ','ካ','ኬ','ክ','ኮ'], 
                  meaning: 'Palm', category: 'body', color: '#0066ff' },
                { id: 19, root: 'ኸ', name: 'KHA', amh: 'ኻ', chars: ['ኸ','ኹ','ኺ','ኻ','ኼ','ኽ','ኾ'], 
                  meaning: 'Open', category: 'state', color: '#00ccff' },
                { id: 20, root: 'ወ', name: 'WAWE', amh: 'ዋዌ', chars: ['ወ','ዉ','ዊ','ዋ','ዌ','ው','ዎ'], 
                  meaning: 'And', category: 'connector', color: '#00ffcc' },
                { id: 21, root: 'ዐ', name: 'AYN', amh: 'ዐይን', chars: ['ዐ','ዑ','ዒ','ዓ','ዔ','ዕ','ዖ'], 
                  meaning: 'Eye', category: 'perception', color: '#66ff00' },
                { id: 22, root: 'ዘ', name: 'ZAY', amh: 'ዛይ', chars: ['ዘ','ዙ','ዚ','ዛ','ዜ','ዝ','ዞ'], 
                  meaning: 'This', category: 'reference', color: '#ccff00' },
                { id: 23, root: 'ዠ', name: 'ZHA', amh: 'ዣ', chars: ['ዠ','ዡ','ዢ','ዣ','ዤ','ዥ','ዦ'], 
                  meaning: 'Sharp', category: 'quality', color: '#ffcc00' },
                { id: 24, root: 'የ', name: 'YAMAN', amh: 'የማን', chars: ['የ','ዩ','ዪ','ያ','ዬ','ይ','ዮ'], 
                  meaning: 'Right', category: 'direction', color: '#ff6600' },
                { id: 25, root: 'ደ', name: 'DINT', amh: 'ድንት', chars: ['ደ','ዱ','ዲ','ዳ','ዴ','ድ','ዶ'], 
                  meaning: 'Stone', category: 'material', color: '#ff0044' },
                { id: 26, root: 'ጀ', name: 'JA', amh: 'ጃ', chars: ['ጀ','ጁ','ጂ','ጃ','ጄ','ጅ','ጆ'], 
                  meaning: 'Start', category: 'action', color: '#ff00aa' },
                { id: 27, root: 'ገ', name: 'GAML', amh: 'ገምል', chars: ['ገ','ጉ','ጊ','ጋ','ጌ','ግ','ጎ'], 
                  meaning: 'Camel', category: 'creature', color: '#aa00ff' },
                { id: 28, root: 'ጠ', name: 'TAYT', amh: 'ጣይት', chars: ['ጠ','ጡ','ጢ','ጣ','ጤ','ጥ','ጦ'], 
                  meaning: 'Clay', category: 'material', color: '#4400ff' },
                { id: 29, root: 'ጨ', name: 'TSA', amh: 'ጫ', chars: ['ጨ','ጩ','ጪ','ጫ','ጬ','ጭ','ጮ'], 
                  meaning: 'Tight', category: 'quality', color: '#0044ff' },
                { id: 30, root: 'ጰ', name: 'TSAPA', amh: 'ጳ', chars: ['ጰ','ጱ','ጲ','ጳ','ጴ','ጵ','ጶ'], 
                  meaning: 'Light', category: 'element', color: '#00aaff' },
                { id: 31, root: 'ጸ', name: 'TSADIY', amh: 'ጻድቅ', chars: ['ጸ','ጹ','ጺ','ጻ','ጼ','ጽ','ጾ'], 
                  meaning: 'Righteous', category: 'virtue', color: '#00ffaa' },
                { id: 32, root: 'ፀ', name: 'TSALAT', amh: 'ፀሎት', chars: ['ፀ','ፁ','ፂ','ፃ','ፄ','ፅ','ፆ'], 
                  meaning: 'Prayer', category: 'spiritual', color: '#44ff00' },
                { id: 33, root: 'ፈ', name: 'AF', amh: 'አፍ', chars: ['ፈ','ፉ','ፊ','ፋ','ፌ','ፍ','ፎ'], 
                  meaning: 'Mouth', category: 'body', color: '#aaff00' },
                { id: 34, root: 'ፐ', name: 'PSA', amh: 'ፕሳ', chars: ['ፐ','ፑ','ፒ','ፓ','ፔ','ፕ','ፖ'], 
                  meaning: 'Letter', category: 'symbol', color: '#ffaa00' },
            ],
        };
        
        function initMfidelDisplaySystem() {
            const box = document.querySelector('.architect-credit');
            const photoContainer = document.querySelector('.architect-photo-container');
            if (!box || !photoContainer) return;
            
            box.style.overflow = 'visible';
            
            // ═══ MFIDEL FRAME ═══
            const frame = document.createElement('div');
            frame.className = 'mfidel-frame';
            frame.style.cssText = `
                position: absolute;
                inset: -35px;
                pointer-events: none;
                z-index: 1;
            `;
            box.appendChild(frame);
            
            // Top arc (first 8 roots)
            const topArc = document.createElement('div');
            topArc.style.cssText = `
                position: absolute;
                top: 0; left: 20px; right: 20px;
                display: flex; justify-content: space-between;
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.85em;
            `;
            MFIDEL.families.slice(0, 9).forEach(f => {
                const span = document.createElement('span');
                span.textContent = f.root;
                span.title = `${f.name}: ${f.meaning}`;
                span.style.cssText = `color: ${f.color}; text-shadow: 0 0 6px ${f.color}; opacity: 0.7;`;
                topArc.appendChild(span);
            });
            frame.appendChild(topArc);
            
            // Bottom arc
            const bottomArc = document.createElement('div');
            bottomArc.style.cssText = `
                position: absolute;
                bottom: 0; left: 20px; right: 20px;
                display: flex; justify-content: space-between;
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.85em;
            `;
            MFIDEL.families.slice(9, 18).forEach(f => {
                const span = document.createElement('span');
                span.textContent = f.root;
                span.title = `${f.name}: ${f.meaning}`;
                span.style.cssText = `color: ${f.color}; text-shadow: 0 0 6px ${f.color}; opacity: 0.7;`;
                bottomArc.appendChild(span);
            });
            frame.appendChild(bottomArc);
            
            // Left column
            const leftCol = document.createElement('div');
            leftCol.style.cssText = `
                position: absolute;
                left: 0; top: 28px; bottom: 28px;
                display: flex; flex-direction: column; justify-content: space-between;
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.8em;
            `;
            MFIDEL.families.slice(18, 26).forEach(f => {
                const span = document.createElement('span');
                span.textContent = f.root;
                span.style.cssText = `color: ${f.color}; text-shadow: 0 0 5px ${f.color}; opacity: 0.6;`;
                leftCol.appendChild(span);
            });
            frame.appendChild(leftCol);
            
            // Right column
            const rightCol = document.createElement('div');
            rightCol.style.cssText = `
                position: absolute;
                right: 0; top: 28px; bottom: 28px;
                display: flex; flex-direction: column; justify-content: space-between;
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.8em;
            `;
            MFIDEL.families.slice(26, 34).forEach(f => {
                const span = document.createElement('span');
                span.textContent = f.root;
                span.style.cssText = `color: ${f.color}; text-shadow: 0 0 5px ${f.color}; opacity: 0.6;`;
                rightCol.appendChild(span);
            });
            frame.appendChild(rightCol);
            
            // Corner emblems - ሙሉ (MULLU)
            const corners = [
                { pos: 'top: -8px; left: -8px;', char: 'ሙ', hue: 180 },
                { pos: 'top: -8px; right: -8px;', char: 'ሉ', hue: 300 },
                { pos: 'bottom: -8px; left: -8px;', char: 'ሉ', hue: 60 },
                { pos: 'bottom: -8px; right: -8px;', char: '፡', hue: 120 },
            ];
            corners.forEach(c => {
                const el = document.createElement('div');
                el.textContent = c.char;
                el.style.cssText = `
                    position: absolute; ${c.pos}
                    font-family: 'Nyala', 'Abyssinica SIL', serif;
                    font-size: 1.3em;
                    color: hsl(${c.hue}, 100%, 70%);
                    text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
                `;
                frame.appendChild(el);
            });
            
            // ═══ HEADER ═══
            const header = document.createElement('div');
            header.style.cssText = `
                position: absolute;
                top: -52px; left: 50%;
                transform: translateX(-50%);
                display: flex; flex-direction: column; align-items: center;
                pointer-events: none;
            `;
            
            const title = document.createElement('div');
            title.id = 'mfidelTitle';
            title.style.cssText = `
                font-family: 'Orbitron', monospace;
                font-size: 0.7em;
                color: #0ff;
                letter-spacing: 4px;
                text-shadow: 0 0 10px currentColor;
            `;
            title.textContent = 'MFIDEL';
            header.appendChild(title);
            
            const subtitle = document.createElement('div');
            subtitle.style.cssText = `
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.55em;
                color: rgba(255,255,255,0.5);
                margin-top: 2px;
            `;
            subtitle.textContent = 'ሙሉ ፊደል';
            header.appendChild(subtitle);
            
            box.appendChild(header);
            
            // ═══ STATS FOOTER ═══
            const stats = document.createElement('div');
            stats.style.cssText = `
                position: absolute;
                bottom: -50px; left: 50%;
                transform: translateX(-50%);
                display: flex; gap: 12px;
                font-family: 'Orbitron', monospace;
                font-size: 0.4em;
                color: rgba(255,255,255,0.5);
            `;
            stats.innerHTML = `
                <span><span style="color:#0ff">34</span> ቤተሰብ</span>
                <span><span style="color:#f0f">×7</span> ስርዓት</span>
                <span><span style="color:#ff0">=238</span> ፊደል</span>
            `;
            box.appendChild(stats);
            
            // Touch hint for mobile
            const touchHint = document.createElement('div');
            touchHint.id = 'mfidelTouchHint';
            touchHint.style.cssText = `
                position: absolute;
                bottom: -65px; left: 50%;
                transform: translateX(-50%);
                font-family: 'Orbitron', monospace;
                font-size: 0.35em;
                color: rgba(0,255,255,0.5);
                white-space: nowrap;
                display: none;
            `;
            touchHint.textContent = 'TAP TO EXPLORE';
            box.appendChild(touchHint);
            
            // Show hint on touch devices
            if ('ontouchstart' in window) {
                touchHint.style.display = 'block';
            }
            
            // ═══ CENTER OVERLAY ═══
            const overlay = document.createElement('div');
            overlay.id = 'mfidelOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                display: flex; flex-direction: column;
                align-items: center; justify-content: center;
                background: radial-gradient(circle, rgba(0,5,15,0.95) 0%, rgba(0,10,20,0.98) 100%);
                border-radius: 50%;
                opacity: 0;
                transition: opacity 0.3s ease;
                z-index: 5;
                pointer-events: none;
            `;
            
            // Main character
            const mainChar = document.createElement('div');
            mainChar.id = 'mfidelMainChar';
            mainChar.style.cssText = `
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 2.5em;
                color: #fff;
                text-shadow: 0 0 15px #0ff, 0 0 30px #0ff, 0 0 45px #08f;
                line-height: 1;
                transition: transform 0.1s ease, color 0.15s, text-shadow 0.15s;
            `;
            mainChar.textContent = 'ሙ';
            overlay.appendChild(mainChar);
            
            // Order name (ግዕዝ/ካዕብ/etc)
            const orderName = document.createElement('div');
            orderName.id = 'mfidelOrderName';
            orderName.style.cssText = `
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.5em;
                color: rgba(255,255,255,0.6);
                margin-top: 2px;
            `;
            orderName.textContent = 'ካዕብ';
            overlay.appendChild(orderName);
            
            // Family row (all 7 vowels)
            const familyRow = document.createElement('div');
            familyRow.id = 'mfidelFamilyRow';
            familyRow.style.cssText = `
                display: flex; gap: 3px;
                margin-top: 5px;
                font-family: 'Nyala', 'Abyssinica SIL', serif;
                font-size: 0.6em;
            `;
            for (let i = 0; i < 7; i++) {
                const char = document.createElement('span');
                char.style.cssText = `
                    color: rgba(255,255,255,0.25);
                    text-shadow: 0 0 3px currentColor;
                    transition: all 0.12s ease;
                    padding: 0 1px;
                `;
                familyRow.appendChild(char);
            }
            overlay.appendChild(familyRow);
            
            // Info container
            const info = document.createElement('div');
            info.style.cssText = `
                display: flex; flex-direction: column; align-items: center;
                margin-top: 4px;
            `;
            
            const familyName = document.createElement('div');
            familyName.id = 'mfidelFamilyName';
            familyName.style.cssText = `
                font-family: 'Orbitron', monospace;
                font-size: 0.38em;
                color: #0ff;
                letter-spacing: 1px;
            `;
            info.appendChild(familyName);
            
            const meaning = document.createElement('div');
            meaning.id = 'mfidelMeaning';
            meaning.style.cssText = `
                font-size: 0.32em;
                color: rgba(255,255,255,0.5);
                margin-top: 1px;
            `;
            info.appendChild(meaning);
            
            const category = document.createElement('div');
            category.id = 'mfidelCategory';
            category.style.cssText = `
                font-size: 0.28em;
                color: rgba(255,255,255,0.35);
                margin-top: 1px;
                text-transform: uppercase;
                letter-spacing: 1px;
            `;
            info.appendChild(category);
            
            overlay.appendChild(info);
            
            // Progress
            const progress = document.createElement('div');
            progress.id = 'mfidelProgress';
            progress.style.cssText = `
                position: absolute;
                bottom: 6px;
                font-family: monospace;
                font-size: 0.28em;
                color: rgba(255,255,255,0.4);
            `;
            progress.textContent = '1/238';
            overlay.appendChild(progress);
            
            photoContainer.appendChild(overlay);
            
            // ═══ STATE ═══
            let familyIdx = 3;  // Start with መ (M in MULLU)
            let orderIdx = 1;   // ካዕብ (u) for ሙ
            let timer = null;
            let persistent = false;
            
            function update() {
                const family = MFIDEL.families[familyIdx];
                const order = MFIDEL.orders[orderIdx];
                const char = family.chars[orderIdx];
                
                // Main character
                mainChar.style.transform = 'scale(1.15)';
                mainChar.textContent = char;
                mainChar.style.color = family.color;
                mainChar.style.textShadow = `0 0 15px ${family.color}, 0 0 30px ${family.color}, 0 0 45px ${family.color}80`;
                setTimeout(() => mainChar.style.transform = 'scale(1)', 80);
                
                // Order name
                orderName.textContent = order.geez;
                orderName.style.color = `${family.color}bb`;
                
                // Family row
                Array.from(familyRow.children).forEach((el, i) => {
                    el.textContent = family.chars[i];
                    if (i === orderIdx) {
                        el.style.color = '#fff';
                        el.style.transform = 'scale(1.3)';
                        el.style.textShadow = `0 0 8px ${family.color}`;
                    } else {
                        el.style.color = 'rgba(255,255,255,0.25)';
                        el.style.transform = 'scale(1)';
                        el.style.textShadow = '0 0 3px currentColor';
                    }
                });
                
                // Info
                familyName.textContent = `${family.root}・${family.name}`;
                familyName.style.color = family.color;
                meaning.textContent = `"${family.meaning}"`;
                category.textContent = family.category;
                
                // Progress
                const total = familyIdx * 7 + orderIdx + 1;
                progress.textContent = `${total}/${MFIDEL.totalSymbols}`;
            }
            
            function next() {
                orderIdx = (orderIdx + 1) % 7;
                if (orderIdx === 0) {
                    familyIdx = (familyIdx + 1) % MFIDEL.families.length;
                }
                update();
            }
            
            function start() {
                if (timer) return;
                overlay.style.opacity = '1';
                update();
                timer = setInterval(next, 280);
            }
            
            function stop() {
                if (persistent) return;
                overlay.style.opacity = '0';
                if (timer) { clearInterval(timer); timer = null; }
            }
            
            // Interactions
            box.addEventListener('mouseenter', start);
            box.addEventListener('mouseleave', stop);
            
            box.addEventListener('click', (e) => {
                e.stopPropagation();
                persistent = !persistent;
                title.textContent = persistent ? 'MFIDEL ▶' : 'MFIDEL';
                title.style.color = persistent ? '#fff' : '#0ff';
                box.style.boxShadow = persistent 
                    ? '0 0 40px rgba(0,255,255,0.5), inset 0 0 25px rgba(0,255,255,0.1)'
                    : '';
                if (persistent) start(); else stop();
            });
            
            box.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                familyIdx = Math.floor(Math.random() * MFIDEL.families.length);
                orderIdx = 0;
                update();
            });
        }
        
        // Initialize Mfidel
        setTimeout(initMfidelDisplaySystem, 1000);
        
        // ═══════════════════════════════════════════════════════════════
        // MOBILE TOUCH SUPPORT
        // ═══════════════════════════════════════════════════════════════
        
        const isTouchDevice = ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0) ||
                              (navigator.msMaxTouchPoints > 0);
        
        function initMobileSupport() {
            if (!isTouchDevice) return;
            
            // Add touch class to body for CSS targeting
            document.body.classList.add('touch-device');
            
            // Get architect box
            const architectBox = document.querySelector('.architect-credit');
            if (architectBox) {
                // Convert hover to tap for MFIDEL display
                let mfidelActive = false;
                
                architectBox.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mfidelActive = !mfidelActive;
                    
                    // Trigger mouseenter/mouseleave
                    if (mfidelActive) {
                        architectBox.dispatchEvent(new Event('mouseenter'));
                    } else {
                        // Force stop even in persistent mode
                        const overlay = document.getElementById('mfidelOverlay');
                        if (overlay) overlay.style.opacity = '0';
                    }
                }, { passive: false });
            }
            
            // Make help panel touch-scrollable
            const helpPanel = document.getElementById('helpPanel');
            if (helpPanel) {
                helpPanel.style.overflowY = 'auto';
                helpPanel.style.webkitOverflowScrolling = 'touch';
            }
            
            // Improve canvas touch interactions
            const canvas = document.getElementById('canvas');
            if (canvas) {
                let lastTap = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    // Convert touch to mouse event for existing handlers
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        bubbles: true
                    });
                    canvas.dispatchEvent(mouseEvent);
                    
                    // Double tap detection
                    if (tapLength < 300 && tapLength > 0) {
                        const dblClickEvent = new MouseEvent('dblclick', {
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            bubbles: true
                        });
                        canvas.dispatchEvent(dblClickEvent);
                    }
                    lastTap = currentTime;
                }, { passive: true });
                
                canvas.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        bubbles: true
                    });
                    canvas.dispatchEvent(mouseEvent);
                }, { passive: true });
                
                canvas.addEventListener('touchend', (e) => {
                    const mouseEvent = new MouseEvent('mouseup', {
                        bubbles: true
                    });
                    canvas.dispatchEvent(mouseEvent);
                }, { passive: true });
            }
            
            // Add mobile-friendly button feedback
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('touchstart', () => {
                    btn.style.transform = 'scale(0.95)';
                    btn.style.opacity = '0.8';
                }, { passive: true });
                
                btn.addEventListener('touchend', () => {
                    btn.style.transform = '';
                    btn.style.opacity = '';
                }, { passive: true });
            });
            
            // Prevent zoom on double-tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, { passive: false });
            
            // Adjust node sizes for touch
            if (window.innerWidth < 768) {
                // Will be picked up by animation loop
                window.mobileNodeScale = 1.3;
            }
            
            console.log('Mobile touch support initialized');
        }
        
        // Initialize mobile support
        initMobileSupport();
        
        // Mobile menu button
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        const mobileHelpPanel = document.getElementById('helpPanel');
        
        if (mobileMenuBtn && mobileHelpPanel) {
            mobileMenuBtn.addEventListener('click', () => {
                const isVisible = mobileHelpPanel.classList.contains('visible');
                if (isVisible) {
                    mobileHelpPanel.classList.remove('visible');
                    mobileHelpPanel.style.display = 'none';
                    mobileMenuBtn.textContent = '☰';
                } else {
                    mobileHelpPanel.classList.add('visible');
                    mobileHelpPanel.style.display = 'block';
                    mobileMenuBtn.textContent = '✕';
                }
            });
        }
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                // Trigger window resize event which is handled by existing resize function
                window.dispatchEvent(new Event('resize'));
            }, 100);
        });
        
        // Handle resize debounced
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Canvas resize is handled by existing resize() function
            }, 150);
        });
        
        
        
        // Start main animation
        init();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
