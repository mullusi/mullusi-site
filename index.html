<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logos-LCS v3.0 | Recursive Refinement Engine</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Playfair+Display:wght@400;500;600&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --void: #05060a;
            --abyss: #0a0c12;
            --deep: #0f1218;
            --surface: #161a24;
            --elevated: #1e232f;
            
            --gold: #e5b978;
            --gold-dim: rgba(229, 185, 120, 0.5);
            --cyan: #5eead4;
            --cyan-dim: rgba(94, 234, 212, 0.4);
            --magenta: #f472b6;
            --violet: #a78bfa;
            --emerald: #34d399;
            --amber: #fbbf24;
            --rose: #fb7185;
            --sky: #38bdf8;
            --indigo: #818cf8;
            
            --pass-1: #ef4444;
            --pass-2: #f97316;
            --pass-3: #eab308;
            --pass-4: #22c55e;
            --pass-5: #06b6d4;
            --pass-6: #8b5cf6;
            --pass-7: #ec4899;
            --pass-8: #6366f1;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--void);
            color: #e8e8e8;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-rows: 50px 1fr 200px;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(90deg, var(--abyss) 0%, var(--deep) 100%);
            border-bottom: 1px solid rgba(229, 185, 120, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo h1 {
            font-family: 'Playfair Display', serif;
            font-size: 1.4rem;
            color: var(--gold);
            font-weight: 500;
        }

        .version-badge {
            background: linear-gradient(135deg, var(--violet) 0%, var(--indigo) 100%);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: white;
            font-weight: 500;
        }

        .header-stats {
            display: flex;
            gap: 25px;
        }

        .header-stat {
            text-align: center;
        }

        .header-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--cyan);
        }

        .header-stat-label {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .ctrl-btn {
            background: rgba(229, 185, 120, 0.1);
            border: 1px solid rgba(229, 185, 120, 0.3);
            color: var(--gold);
            padding: 6px 14px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ctrl-btn:hover {
            background: rgba(229, 185, 120, 0.2);
        }

        .ctrl-btn.active {
            background: var(--gold);
            color: var(--void);
        }

        .ctrl-btn.danger {
            border-color: var(--rose);
            color: var(--rose);
        }

        /* Main Area */
        .main-area {
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            gap: 0;
        }

        /* Left Panel - Pass Indicators & Ontology */
        .left-panel {
            background: var(--abyss);
            border-right: 1px solid rgba(229, 185, 120, 0.1);
            overflow-y: auto;
            padding: 15px;
        }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: 'â—†';
            font-size: 0.6rem;
        }

        .pass-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.02);
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .pass-indicator:hover {
            background: rgba(255,255,255,0.05);
        }

        .pass-indicator.active {
            background: rgba(255,255,255,0.08);
        }

        .pass-num {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--void);
        }

        .pass-info {
            flex: 1;
        }

        .pass-name {
            font-size: 0.75rem;
            font-weight: 500;
            color: #fff;
        }

        .pass-desc {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
        }

        .pass-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--emerald);
        }

        /* Ontology Tree */
        .ontology-section {
            margin-top: 20px;
        }

        .ontology-node {
            padding: 6px 10px;
            margin: 2px 0;
            background: rgba(255,255,255,0.02);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--cyan);
            cursor: pointer;
            transition: all 0.2s;
        }

        .ontology-node:hover {
            background: rgba(94, 234, 212, 0.1);
        }

        .ontology-node.level-1 { margin-left: 12px; }
        .ontology-node.level-2 { margin-left: 24px; }

        /* Center - Visualization */
        .center-panel {
            background: var(--void);
            position: relative;
        }

        #main-canvas {
            width: 100%;
            height: 100%;
        }

        .viz-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
        }

        .viz-mode {
            background: rgba(10, 12, 18, 0.9);
            border: 1px solid rgba(229, 185, 120, 0.2);
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.2s;
        }

        .viz-mode:hover, .viz-mode.active {
            border-color: var(--gold);
            color: var(--gold);
        }

        .introspection-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 220px;
            background: rgba(10, 12, 18, 0.95);
            border: 1px solid rgba(167, 139, 250, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.65rem;
        }

        .introspection-title {
            font-family: 'JetBrains Mono', monospace;
            color: var(--violet);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .emergent-pattern {
            background: rgba(167, 139, 250, 0.1);
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            color: var(--violet);
        }

        .anomaly-item {
            background: rgba(251, 113, 133, 0.1);
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            color: var(--rose);
        }

        /* Right Panel - Wh Gates & Inference */
        .right-panel {
            background: var(--abyss);
            border-left: 1px solid rgba(229, 185, 120, 0.1);
            overflow-y: auto;
            padding: 15px;
        }

        .wh-category {
            margin-bottom: 15px;
        }

        .wh-category-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--amber);
            padding: 6px 10px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
            margin-bottom: 6px;
        }

        .wh-gate-mini {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 3px;
            margin: 2px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        .wh-gate-mini:hover {
            background: rgba(94, 234, 212, 0.1);
            color: var(--cyan);
        }

        .wh-gate-mini.active {
            background: rgba(52, 211, 153, 0.2);
            color: var(--emerald);
        }

        .wh-gate-mini .dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
        }

        .wh-gate-mini.active .dot {
            background: var(--emerald);
            box-shadow: 0 0 6px var(--emerald);
        }

        /* Inference Panel */
        .inference-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.05);
        }

        .inference-result {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .inference-label {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
        }

        .inference-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--emerald);
        }

        /* Bottom Panel - SymQL Console & Timeline */
        .bottom-panel {
            display: grid;
            grid-template-columns: 1fr 400px;
            background: var(--deep);
            border-top: 1px solid rgba(229, 185, 120, 0.15);
        }

        /* SymQL Console */
        .symql-console {
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .console-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .console-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--indigo);
        }

        .symql-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .symql-input {
            flex: 1;
            background: var(--void);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: #fff;
            outline: none;
        }

        .symql-input:focus {
            border-color: var(--indigo);
        }

        .symql-input::placeholder {
            color: rgba(255,255,255,0.3);
        }

        .symql-run {
            background: var(--indigo);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: white;
            cursor: pointer;
        }

        .symql-output {
            flex: 1;
            background: var(--void);
            border-radius: 4px;
            padding: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--cyan);
            overflow-y: auto;
            white-space: pre-wrap;
        }

        /* Timeline */
        .timeline-panel {
            background: var(--abyss);
            border-left: 1px solid rgba(229, 185, 120, 0.1);
            padding: 15px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .timeline-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--magenta);
        }

        .timeline-controls {
            display: flex;
            gap: 6px;
        }

        .timeline-btn {
            background: rgba(236, 72, 153, 0.1);
            border: 1px solid rgba(236, 72, 153, 0.3);
            color: var(--magenta);
            padding: 4px 10px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            cursor: pointer;
        }

        .timeline-btn:hover {
            background: rgba(236, 72, 153, 0.2);
        }

        .timeline-track {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .snapshot-marker {
            min-width: 40px;
            height: 50px;
            background: rgba(236, 72, 153, 0.1);
            border: 1px solid rgba(236, 72, 153, 0.2);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .snapshot-marker:hover {
            background: rgba(236, 72, 153, 0.2);
            border-color: var(--magenta);
        }

        .snapshot-marker.current {
            background: var(--magenta);
            border-color: var(--magenta);
        }

        .snapshot-marker.current .snap-tick,
        .snapshot-marker.current .snap-label {
            color: white;
        }

        .snap-tick {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--magenta);
        }

        .snap-label {
            font-size: 0.5rem;
            color: rgba(255,255,255,0.4);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 5px; height: 5px; }
        ::-webkit-scrollbar-track { background: var(--void); }
        ::-webkit-scrollbar-thumb { background: rgba(229, 185, 120, 0.3); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <h1>LOGOS-LCS</h1>
                <span class="version-badge">v3.0 RECURSIVE REFINEMENT</span>
            </div>
            <div class="header-stats">
                <div class="header-stat">
                    <div class="header-stat-value" id="stat-symbols">0</div>
                    <div class="header-stat-label">Symbols</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="stat-chains">0</div>
                    <div class="header-stat-label">Chains</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="stat-wh">0/45</div>
                    <div class="header-stat-label">Wh Gates</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="stat-emergent">0</div>
                    <div class="header-stat-label">Emergent</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value" id="stat-ms">0.00</div>
                    <div class="header-stat-label">Avg Ms</div>
                </div>
            </div>
            <div class="header-controls">
                <button class="ctrl-btn" id="btn-snapshot">ðŸ“¸ Snapshot</button>
                <button class="ctrl-btn" id="btn-introspect">ðŸ”® Introspect</button>
                <button class="ctrl-btn active" id="btn-run">â–¶ Running</button>
            </div>
        </header>

        <!-- Main Area -->
        <main class="main-area">
            <!-- Left Panel -->
            <aside class="left-panel">
                <div class="section-title">8 Optimization Passes</div>
                <div id="passes-container"></div>

                <div class="ontology-section">
                    <div class="section-title">Symbol Ontology</div>
                    <div id="ontology-tree"></div>
                </div>
            </aside>

            <!-- Center Visualization -->
            <section class="center-panel">
                <canvas id="main-canvas"></canvas>
                <div class="viz-overlay">
                    <button class="viz-mode active" data-mode="mesh">Mesh</button>
                    <button class="viz-mode" data-mode="causal">Causal Graph</button>
                    <button class="viz-mode" data-mode="inference">Inference</button>
                    <button class="viz-mode" data-mode="attention">Attention</button>
                </div>
                <div class="introspection-panel" id="introspection-panel" style="display: none;">
                    <div class="introspection-title">ðŸ”® Meta-Cognitive Introspection</div>
                    <div id="introspection-content"></div>
                </div>
            </section>

            <!-- Right Panel -->
            <aside class="right-panel">
                <div class="section-title">45 Wh Logic Gates</div>
                <div id="wh-gates-compact"></div>

                <div class="inference-section">
                    <div class="section-title">Causal Inference</div>
                    <div class="inference-result">
                        <div class="inference-label">P(Effect | Cause)</div>
                        <div class="inference-value" id="inference-forward">0.000</div>
                    </div>
                    <div class="inference-result">
                        <div class="inference-label">P(Cause | Effect)</div>
                        <div class="inference-value" id="inference-backward">0.000</div>
                    </div>
                    <div class="inference-result">
                        <div class="inference-label">Causal Bottlenecks</div>
                        <div class="inference-value" id="inference-bottlenecks">-</div>
                    </div>
                </div>
            </aside>
        </main>

        <!-- Bottom Panel -->
        <footer class="bottom-panel">
            <!-- SymQL Console -->
            <div class="symql-console">
                <div class="console-header">
                    <h3>â—ˆ SymQL Console</h3>
                    <span style="font-size: 0.6rem; color: rgba(255,255,255,0.3);">Symbolic Query Language</span>
                </div>
                <div class="symql-input-container">
                    <input type="text" class="symql-input" id="symql-input" 
                           placeholder="SELECT * FROM symbols WHERE ms > 0.5 ORDER BY ms DESC LIMIT 10">
                    <button class="symql-run" id="symql-run">Execute</button>
                </div>
                <div class="symql-output" id="symql-output">// Results will appear here...</div>
            </div>

            <!-- Timeline -->
            <div class="timeline-panel">
                <div class="timeline-header">
                    <h3>â—ˆ Temporal Timeline</h3>
                    <div class="timeline-controls">
                        <button class="timeline-btn" id="btn-undo">â—€ Undo</button>
                        <button class="timeline-btn" id="btn-redo">Redo â–¶</button>
                    </div>
                </div>
                <div class="timeline-track" id="timeline-track"></div>
            </div>
        </footer>
    </div>

    <script>
    // ============================================================================
    // LOGOS-LCS v3.0 - RECURSIVE REFINEMENT ENGINE
    // ============================================================================

    const OPTIMIZATION_PASSES = [
        { id: 1, name: "Core Architecture", desc: "Type Ontology & Refinement", color: "#ef4444" },
        { id: 2, name: "Wh Gate Enhancement", desc: "Combinators & Temporal Expr", color: "#f97316" },
        { id: 3, name: "DS-DNA Upgrade", desc: "Self-Modification & Gradients", color: "#eab308" },
        { id: 4, name: "Causal Intelligence", desc: "Inference & Probabilistic", color: "#22c55e" },
        { id: 5, name: "Meta-Cognitive", desc: "Self-Reflection & Emergent", color: "#06b6d4" },
        { id: 6, name: "Performance", desc: "Spatial Index & Batch", color: "#8b5cf6" },
        { id: 7, name: "Temporal System", desc: "Snapshots & Time Travel", color: "#ec4899" },
        { id: 8, name: "Query Language", desc: "SymQL Interface", color: "#6366f1" }
    ];

    const WH_GATE_CATEGORIES = {
        temporal: ['WHEN_NOW', 'WHEN_BEFORE', 'WHEN_AFTER', 'WHEN_DURING', 'WHEN_CYCLE', 'WHEN_PHASE', 'WHEN_DELAY', 'WHEN_DURATION', 'WHEN_SEQUENCE'],
        spatial: ['WHERE_AT', 'WHERE_NEAR', 'WHERE_IN', 'WHERE_ON', 'WHERE_BETWEEN', 'WHERE_FACING', 'WHERE_REGION', 'WHERE_PATH', 'WHERE_BOUNDARY'],
        identity: ['WHAT_TYPE', 'WHAT_STATE', 'WHAT_PROPERTY', 'WHO_AGENT', 'WHO_TARGET', 'WHO_OWNER', 'WHAT_CATEGORY', 'WHAT_INSTANCE', 'WHO_GROUP'],
        causation: ['WHY_CAUSE', 'WHY_PURPOSE', 'WHY_TRIGGER', 'HOW_METHOD', 'HOW_DEGREE', 'HOW_MANNER', 'WHY_CHAIN', 'HOW_TRANSFORM', 'WHY_CONSTRAINT'],
        quantitative: ['HOW_MUCH', 'HOW_MANY', 'HOW_OFTEN', 'HOW_LONG', 'HOW_FAR', 'HOW_FAST', 'HOW_RATIO', 'HOW_RANGE', 'HOW_DELTA']
    };

    const ONTOLOGY = {
        ROOT: { children: ['FUNDAMENTAL', 'STRUCTURAL', 'CAUSAL_AGENT', 'AUTHORITY', 'OBSERVER'] },
        FUNDAMENTAL: { children: [] },
        STRUCTURAL: { children: ['ENVIRONMENT', 'MATERIAL'] },
        CAUSAL_AGENT: { children: ['ENTITY', 'LIGHT'] },
        AUTHORITY: { children: [] },
        OBSERVER: { children: [] },
        ENVIRONMENT: { children: [] },
        MATERIAL: { children: [] },
        ENTITY: { children: [] },
        LIGHT: { children: [] }
    };

    // ============================================================================
    // SIMPLIFIED v3 ENGINE (Browser-compatible)
    // ============================================================================

    class LCSSymbolV3 {
        constructor(name, layer, config = {}) {
            this.id = `sym_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            this.name = name;
            this.layer = layer;
            this.type = config.type || 'ENTITY';
            this.baseValue = config.baseValue ?? 1.0;
            this.symbolWeight = config.symbolWeight ?? 1.0;
            this.modifier = 1.0;
            this.state = new Map(Object.entries(config.initialState || {}));
            this.causes = new Set();
            this.effects = new Set();
            this.position = { x: 0, y: 0, z: layer };
            this.activations = 0;
            this.lastActivated = null;
            
            // DNA
            this.dna = {
                memory: [],
                reinforcement: new Map(),
                patterns: new Map()
            };
        }
        
        calculateMs() {
            return this.baseValue * this.symbolWeight * this.modifier;
        }
        
        applyModifier(mod) {
            this.modifier *= mod;
        }
        
        resetModifier() {
            this.modifier = 1.0;
        }
        
        causesSymbol(target) {
            this.effects.add(target);
            target.causes.add(this);
        }
        
        remember(tag, data) {
            this.dna.memory.unshift({ tag, data, time: Date.now() });
            if (this.dna.memory.length > 50) this.dna.memory.pop();
        }
    }

    class LogosLCSV3Engine {
        constructor() {
            this.symbols = new Map();
            this.whGateStates = new Map();
            this.causalChains = [];
            this.snapshots = [];
            this.currentSnapshotIndex = -1;
            this.emergentPatterns = [];
            this.anomalies = [];
            this.running = true;
            this.tickCount = 0;
            
            // Causal inference
            this.causalGraph = new Map();
            
            // Attention
            this.salienceMap = new Map();
            this.focus = null;
            
            // Initialize Wh gates
            Object.values(WH_GATE_CATEGORIES).flat().forEach(gate => {
                this.whGateStates.set(gate, { active: false, fireCount: 0, lastFired: null });
            });
        }
        
        createSymbol(name, layer, config = {}) {
            const symbol = new LCSSymbolV3(name, layer, config);
            this.symbols.set(symbol.id, symbol);
            this.positionSymbol(symbol);
            return symbol;
        }
        
        positionSymbol(symbol) {
            const layerSymbols = Array.from(this.symbols.values()).filter(s => s.layer === symbol.layer);
            const angle = layerSymbols.length * 0.618 * Math.PI * 2;
            const radius = 100 + symbol.layer * 40;
            symbol.position.x = Math.cos(angle) * radius;
            symbol.position.y = Math.sin(angle) * radius;
        }
        
        evaluateWhGate(gateId, context = {}) {
            const state = this.whGateStates.get(gateId);
            if (!state) return false;
            
            // Simplified evaluation
            let fires = false;
            if (gateId === 'WHEN_NOW') fires = context.immediate === true;
            else if (gateId === 'WHEN_CYCLE') fires = (this.tickCount % 60) === 0;
            else if (gateId === 'WHERE_NEAR') fires = (context.distance || Infinity) < 50;
            else fires = Math.random() > 0.95; // Random for demo
            
            state.active = fires;
            if (fires) {
                state.fireCount++;
                state.lastFired = Date.now();
            }
            return fires;
        }
        
        processCausalChain(root, trigger, context = {}) {
            const chain = {
                id: `chain_${Date.now()}`,
                trigger,
                source: root.name,
                effects: [],
                whGatesUsed: [],
                totalMs: 0,
                probability: Math.random() * 0.5 + 0.5
            };
            
            const queue = [root];
            const visited = new Set();
            
            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current.id)) continue;
                visited.add(current.id);
                
                current.activations++;
                current.lastActivated = Date.now();
                current.remember(trigger, context);
                
                const ms = current.calculateMs();
                chain.effects.push({ symbol: current.name, ms });
                chain.totalMs += ms;
                
                for (const effect of current.effects) {
                    if (!visited.has(effect.id)) queue.push(effect);
                }
            }
            
            this.causalChains.unshift(chain);
            if (this.causalChains.length > 100) this.causalChains.pop();
            
            return chain;
        }
        
        takeSnapshot(label = '') {
            const snapshot = {
                id: `snap_${Date.now()}`,
                label: label || `Tick ${this.tickCount}`,
                tickCount: this.tickCount,
                timestamp: Date.now(),
                symbolCount: this.symbols.size,
                data: Array.from(this.symbols.values()).map(s => ({
                    id: s.id, name: s.name, layer: s.layer,
                    baseValue: s.baseValue, symbolWeight: s.symbolWeight
                }))
            };
            
            this.snapshots.push(snapshot);
            this.currentSnapshotIndex = this.snapshots.length - 1;
            if (this.snapshots.length > 50) this.snapshots.shift();
            
            return snapshot;
        }
        
        restoreSnapshot(snapshotId) {
            const snapshot = this.snapshots.find(s => s.id === snapshotId);
            if (!snapshot) return null;
            this.currentSnapshotIndex = this.snapshots.indexOf(snapshot);
            return snapshot;
        }
        
        detectEmergentPatterns() {
            const patternCounts = new Map();
            
            for (const chain of this.causalChains.slice(0, 50)) {
                const sig = chain.effects.map(e => e.symbol).join('->');
                patternCounts.set(sig, (patternCounts.get(sig) || 0) + 1);
            }
            
            this.emergentPatterns = Array.from(patternCounts.entries())
                .filter(([_, count]) => count >= 3)
                .map(([pattern, count]) => ({ pattern, occurrences: count }));
            
            return this.emergentPatterns;
        }
        
        updateAttention() {
            for (const symbol of this.symbols.values()) {
                let salience = 0;
                const timeSince = Date.now() - (symbol.lastActivated || 0);
                salience += Math.exp(-timeSince / 5000);
                salience += symbol.calculateMs() * 0.5;
                salience += (symbol.effects.size + symbol.causes.size) * 0.1;
                this.salienceMap.set(symbol.id, salience);
            }
            
            let maxSalience = 0;
            for (const [id, salience] of this.salienceMap) {
                if (salience > maxSalience) {
                    maxSalience = salience;
                    this.focus = id;
                }
            }
        }
        
        executeSymQL(query) {
            try {
                const upper = query.toUpperCase();
                if (!upper.includes('SELECT')) return 'Error: Only SELECT queries supported';
                
                let results = Array.from(this.symbols.values()).map(s => ({
                    name: s.name,
                    layer: s.layer,
                    type: s.type,
                    ms: s.calculateMs().toFixed(3),
                    activations: s.activations,
                    effects: s.effects.size,
                    causes: s.causes.size
                }));
                
                // Simple WHERE parsing
                const whereMatch = query.match(/WHERE\s+(\w+)\s*(>|<|=)\s*([\d.]+)/i);
                if (whereMatch) {
                    const [_, field, op, val] = whereMatch;
                    const numVal = parseFloat(val);
                    results = results.filter(r => {
                        const v = parseFloat(r[field]) || 0;
                        if (op === '>') return v > numVal;
                        if (op === '<') return v < numVal;
                        return v == numVal;
                    });
                }
                
                // Simple ORDER BY
                const orderMatch = query.match(/ORDER BY\s+(\w+)\s*(DESC|ASC)?/i);
                if (orderMatch) {
                    const [_, field, dir] = orderMatch;
                    results.sort((a, b) => {
                        const av = parseFloat(a[field]) || a[field];
                        const bv = parseFloat(b[field]) || b[field];
                        return dir?.toUpperCase() === 'DESC' ? bv - av : av - bv;
                    });
                }
                
                // LIMIT
                const limitMatch = query.match(/LIMIT\s+(\d+)/i);
                if (limitMatch) {
                    results = results.slice(0, parseInt(limitMatch[1]));
                }
                
                return JSON.stringify(results, null, 2);
            } catch (e) {
                return `Error: ${e.message}`;
            }
        }
        
        tick() {
            if (!this.running) return;
            this.tickCount++;
            
            // Evaluate time-based gates
            this.evaluateWhGate('WHEN_NOW', { immediate: true });
            this.evaluateWhGate('WHEN_CYCLE', {});
            
            // Reset modifiers
            for (const symbol of this.symbols.values()) {
                symbol.resetModifier();
            }
            
            // Periodic analysis
            if (this.tickCount % 60 === 0) {
                this.updateAttention();
            }
            if (this.tickCount % 180 === 0) {
                this.detectEmergentPatterns();
            }
            
            // Auto-snapshot
            if (this.tickCount % 300 === 0) {
                this.takeSnapshot('auto');
            }
        }
        
        getStats() {
            const activeGates = Array.from(this.whGateStates.values()).filter(s => s.active).length;
            const symbols = Array.from(this.symbols.values());
            const totalMs = symbols.reduce((s, sym) => s + sym.calculateMs(), 0);
            
            return {
                symbols: this.symbols.size,
                chains: this.causalChains.length,
                activeWhGates: activeGates,
                emergent: this.emergentPatterns.length,
                avgMs: symbols.length ? (totalMs / symbols.length).toFixed(3) : '0.000',
                snapshots: this.snapshots.length,
                tickCount: this.tickCount
            };
        }
    }

    // ============================================================================
    // RENDERER
    // ============================================================================

    class V3Renderer {
        constructor(canvas, engine) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.engine = engine;
            this.mode = 'mesh';
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }
        
        resize() {
            this.canvas.width = this.canvas.parentElement.clientWidth;
            this.canvas.height = this.canvas.parentElement.clientHeight;
            this.cx = this.canvas.width / 2;
            this.cy = this.canvas.height / 2;
        }
        
        render() {
            const ctx = this.ctx;
            ctx.fillStyle = 'rgba(5, 6, 10, 0.2)';
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            if (this.mode === 'mesh' || this.mode === 'causal') {
                this.drawConnections();
                this.drawSymbols();
            } else if (this.mode === 'inference') {
                this.drawInferenceGraph();
            } else if (this.mode === 'attention') {
                this.drawAttentionMap();
            }
        }
        
        drawConnections() {
            const ctx = this.ctx;
            
            for (const symbol of this.engine.symbols.values()) {
                const fx = this.cx + symbol.position.x;
                const fy = this.cy + symbol.position.y;
                
                for (const effect of symbol.effects) {
                    const tx = this.cx + effect.position.x;
                    const ty = this.cy + effect.position.y;
                    
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.lineTo(tx, ty);
                    ctx.strokeStyle = 'rgba(94, 234, 212, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Arrow
                    const angle = Math.atan2(ty - fy, tx - fx);
                    ctx.beginPath();
                    ctx.moveTo(tx, ty);
                    ctx.lineTo(tx - 8 * Math.cos(angle - 0.3), ty - 8 * Math.sin(angle - 0.3));
                    ctx.lineTo(tx - 8 * Math.cos(angle + 0.3), ty - 8 * Math.sin(angle + 0.3));
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(94, 234, 212, 0.5)';
                    ctx.fill();
                }
            }
        }
        
        drawSymbols() {
            const ctx = this.ctx;
            const passColors = OPTIMIZATION_PASSES.map(p => p.color);
            
            for (const symbol of this.engine.symbols.values()) {
                const x = this.cx + symbol.position.x;
                const y = this.cy + symbol.position.y;
                const ms = symbol.calculateMs();
                const size = 8 + ms * 5;
                const color = passColors[symbol.layer % passColors.length];
                
                // Focus highlight
                if (this.engine.focus === symbol.id) {
                    ctx.beginPath();
                    ctx.arc(x, y, size + 15, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(167, 139, 250, 0.2)';
                    ctx.fill();
                }
                
                // Recent activation glow
                const timeSince = Date.now() - (symbol.lastActivated || 0);
                if (timeSince < 500) {
                    ctx.beginPath();
                    ctx.arc(x, y, size + 10, 0, Math.PI * 2);
                    ctx.fillStyle = color + '40';
                    ctx.fill();
                }
                
                // Symbol
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                // Inner
                ctx.beginPath();
                ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                // Label
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(symbol.name.split('_')[0], x, y + size + 14);
            }
        }
        
        drawInferenceGraph() {
            const ctx = this.ctx;
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.font = '12px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('Causal Inference View', this.cx, this.cy - 50);
            ctx.fillText(`P(Effect|Cause) computed for ${this.engine.causalChains.length} chains`, this.cx, this.cy);
            
            // Draw simplified Bayesian network
            const chains = this.engine.causalChains.slice(0, 5);
            chains.forEach((chain, i) => {
                const y = 100 + i * 40;
                ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                ctx.fillText(`${chain.source} â†’ P=${chain.probability.toFixed(2)}`, this.cx, y);
            });
        }
        
        drawAttentionMap() {
            const ctx = this.ctx;
            
            for (const symbol of this.engine.symbols.values()) {
                const x = this.cx + symbol.position.x;
                const y = this.cy + symbol.position.y;
                const salience = this.engine.salienceMap.get(symbol.id) || 0;
                const size = 10 + salience * 30;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(167, 139, 250, ${salience * 0.5})`;
                ctx.fill();
                
                if (this.engine.focus === symbol.id) {
                    ctx.strokeStyle = '#a78bfa';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }
    }

    // ============================================================================
    // UI MANAGER
    // ============================================================================

    class UIManager {
        constructor(engine) {
            this.engine = engine;
            this.initPasses();
            this.initOntology();
            this.initWhGates();
            this.initControls();
            this.startLoop();
        }
        
        initPasses() {
            const container = document.getElementById('passes-container');
            OPTIMIZATION_PASSES.forEach(pass => {
                const div = document.createElement('div');
                div.className = 'pass-indicator';
                div.style.borderLeftColor = pass.color;
                div.innerHTML = `
                    <div class="pass-num" style="background: ${pass.color}">${pass.id}</div>
                    <div class="pass-info">
                        <div class="pass-name">${pass.name}</div>
                        <div class="pass-desc">${pass.desc}</div>
                    </div>
                    <div class="pass-status"></div>
                `;
                div.addEventListener('click', () => this.activatePass(pass.id));
                container.appendChild(div);
            });
        }
        
        activatePass(passId) {
            // Create symbols related to pass
            const names = ['Core', 'Processor', 'Handler', 'Manager', 'Engine'];
            const name = `Pass${passId}_${names[Math.floor(Math.random() * names.length)]}`;
            const symbol = this.engine.createSymbol(name, passId, {
                baseValue: 0.5 + Math.random() * 0.5,
                type: 'CAUSAL_AGENT'
            });
            
            // Connect to existing
            const existing = Array.from(this.engine.symbols.values());
            if (existing.length > 1) {
                const target = existing[Math.floor(Math.random() * (existing.length - 1))];
                if (target.id !== symbol.id) symbol.causesSymbol(target);
            }
            
            // Trigger chain
            this.engine.processCausalChain(symbol, `pass_${passId}_activate`, {});
        }
        
        initOntology() {
            const container = document.getElementById('ontology-tree');
            const renderNode = (name, level = 0) => {
                const div = document.createElement('div');
                div.className = `ontology-node level-${level}`;
                div.textContent = name;
                div.addEventListener('click', () => this.spawnOntologySymbol(name));
                container.appendChild(div);
                
                if (ONTOLOGY[name]) {
                    ONTOLOGY[name].children.forEach(child => renderNode(child, level + 1));
                }
            };
            renderNode('ROOT');
        }
        
        spawnOntologySymbol(type) {
            const name = `${type}_${Date.now() % 1000}`;
            const symbol = this.engine.createSymbol(name, Math.floor(Math.random() * 5) + 1, { type });
            this.engine.processCausalChain(symbol, 'ontology_spawn', {});
        }
        
        initWhGates() {
            const container = document.getElementById('wh-gates-compact');
            Object.entries(WH_GATE_CATEGORIES).forEach(([category, gates]) => {
                const catDiv = document.createElement('div');
                catDiv.className = 'wh-category';
                catDiv.innerHTML = `<div class="wh-category-header">${category.toUpperCase()} (${gates.length})</div>`;
                
                gates.forEach(gate => {
                    const gateDiv = document.createElement('div');
                    gateDiv.className = 'wh-gate-mini';
                    gateDiv.id = `wh-${gate}`;
                    gateDiv.innerHTML = `<span class="dot"></span>${gate.replace('WHEN_', '').replace('WHERE_', '').replace('WHAT_', '').replace('WHO_', '').replace('WHY_', '').replace('HOW_', '')}`;
                    gateDiv.addEventListener('click', () => {
                        this.engine.evaluateWhGate(gate, { immediate: true });
                    });
                    catDiv.appendChild(gateDiv);
                });
                
                container.appendChild(catDiv);
            });
        }
        
        initControls() {
            // Snapshot
            document.getElementById('btn-snapshot').addEventListener('click', () => {
                this.engine.takeSnapshot('manual');
                this.updateTimeline();
            });
            
            // Introspect
            document.getElementById('btn-introspect').addEventListener('click', () => {
                const panel = document.getElementById('introspection-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                this.updateIntrospection();
            });
            
            // Run/Pause
            document.getElementById('btn-run').addEventListener('click', (e) => {
                this.engine.running = !this.engine.running;
                e.target.textContent = this.engine.running ? 'â–¶ Running' : 'â¸ Paused';
                e.target.classList.toggle('active', this.engine.running);
            });
            
            // Viz modes
            document.querySelectorAll('.viz-mode').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.viz-mode').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    window.renderer.mode = btn.dataset.mode;
                });
            });
            
            // SymQL
            document.getElementById('symql-run').addEventListener('click', () => {
                const query = document.getElementById('symql-input').value;
                const result = this.engine.executeSymQL(query);
                document.getElementById('symql-output').textContent = result;
            });
            
            document.getElementById('symql-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('symql-run').click();
            });
            
            // Timeline
            document.getElementById('btn-undo').addEventListener('click', () => {
                if (this.engine.currentSnapshotIndex > 0) {
                    this.engine.currentSnapshotIndex--;
                    this.updateTimeline();
                }
            });
            
            document.getElementById('btn-redo').addEventListener('click', () => {
                if (this.engine.currentSnapshotIndex < this.engine.snapshots.length - 1) {
                    this.engine.currentSnapshotIndex++;
                    this.updateTimeline();
                }
            });
        }
        
        startLoop() {
            setInterval(() => this.update(), 100);
        }
        
        update() {
            const stats = this.engine.getStats();
            
            document.getElementById('stat-symbols').textContent = stats.symbols;
            document.getElementById('stat-chains').textContent = stats.chains;
            document.getElementById('stat-wh').textContent = `${stats.activeWhGates}/45`;
            document.getElementById('stat-emergent').textContent = stats.emergent;
            document.getElementById('stat-ms').textContent = stats.avgMs;
            
            // Update Wh gate indicators
            for (const [gateId, state] of this.engine.whGateStates) {
                const el = document.getElementById(`wh-${gateId}`);
                if (el) el.classList.toggle('active', state.active);
            }
            
            // Update inference
            const lastChain = this.engine.causalChains[0];
            if (lastChain) {
                document.getElementById('inference-forward').textContent = lastChain.probability.toFixed(3);
                document.getElementById('inference-backward').textContent = (1 - lastChain.probability * 0.5).toFixed(3);
            }
            
            // Bottlenecks
            const symbolsByEffects = Array.from(this.engine.symbols.values())
                .sort((a, b) => b.effects.size - a.effects.size)
                .slice(0, 3)
                .map(s => s.name.split('_')[0]);
            document.getElementById('inference-bottlenecks').textContent = symbolsByEffects.join(', ') || '-';
        }
        
        updateIntrospection() {
            this.engine.detectEmergentPatterns();
            this.engine.updateAttention();
            
            const content = document.getElementById('introspection-content');
            let html = '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5); margin-bottom: 8px;">Emergent Patterns</div>';
            
            this.engine.emergentPatterns.slice(0, 3).forEach(p => {
                html += `<div class="emergent-pattern">${p.pattern.slice(0, 20)}... (${p.occurrences}x)</div>`;
            });
            
            html += '<div style="font-size: 0.6rem; color: rgba(255,255,255,0.5); margin: 10px 0 8px;">Current Focus</div>';
            const focusSymbol = this.engine.symbols.get(this.engine.focus);
            html += `<div style="color: var(--violet);">${focusSymbol?.name || 'None'}</div>`;
            
            content.innerHTML = html;
        }
        
        updateTimeline() {
            const track = document.getElementById('timeline-track');
            track.innerHTML = '';
            
            this.engine.snapshots.forEach((snap, i) => {
                const marker = document.createElement('div');
                marker.className = 'snapshot-marker' + (i === this.engine.currentSnapshotIndex ? ' current' : '');
                marker.innerHTML = `
                    <div class="snap-tick">${snap.tickCount}</div>
                    <div class="snap-label">${snap.label}</div>
                `;
                marker.addEventListener('click', () => {
                    this.engine.restoreSnapshot(snap.id);
                    this.updateTimeline();
                });
                track.appendChild(marker);
            });
        }
    }

    // ============================================================================
    // DEMO BUILDER
    // ============================================================================

    function buildDemo(engine) {
        // Create initial symbols across layers
        const symbols = [];
        
        for (let pass = 1; pass <= 8; pass++) {
            const count = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < count; i++) {
                const names = ['Core', 'Handler', 'Processor', 'Manager', 'Engine', 'System'];
                const name = `P${pass}_${names[i % names.length]}`;
                symbols.push(engine.createSymbol(name, pass, {
                    baseValue: 0.5 + Math.random() * 0.5,
                    symbolWeight: 0.8 + Math.random() * 0.4
                }));
            }
        }
        
        // Create connections
        for (let i = 1; i < symbols.length; i++) {
            if (Math.random() > 0.4) {
                const target = symbols[Math.floor(Math.random() * i)];
                symbols[i].causesSymbol(target);
            }
        }
        
        // Initial snapshot
        engine.takeSnapshot('initial');
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    document.addEventListener('DOMContentLoaded', () => {
        const engine = new LogosLCSV3Engine();
        const canvas = document.getElementById('main-canvas');
        const renderer = new V3Renderer(canvas, engine);
        const ui = new UIManager(engine);
        
        window.engine = engine;
        window.renderer = renderer;
        
        buildDemo(engine);
        
        // Main loop
        function loop() {
            engine.tick();
            renderer.render();
            requestAnimationFrame(loop);
        }
        loop();
        
        // Periodic events
        setInterval(() => {
            if (!engine.running) return;
            const symbols = Array.from(engine.symbols.values());
            if (symbols.length > 0) {
                const root = symbols[Math.floor(Math.random() * symbols.length)];
                engine.processCausalChain(root, 'auto_pulse', { immediate: true });
            }
        }, 1500);
        
        console.log('Logos-LCS v3.0 Recursive Refinement Engine initialized');
        console.log('Access: window.engine, window.renderer');
    });
    </script>
</body>
</html>
